<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage-filtered.info - /usr/include/opencv4/opencv2/imgproc.hpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">usr/include/opencv4/opencv2</a> - imgproc.hpp<span style="font-size: 80%;"> (source / <a href="imgproc.hpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage-filtered.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-04-09 11:21:13</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
            | Branches:
            <span class="coverLegendCov">+</span> taken
            <span class="coverLegendNoCov">-</span> not taken
            <span class="coverLegendNoCov">#</span> not executed
</td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntryHi">-</td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">           Branch data     Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>                :            : /*M///////////////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">       2 </span>                :            : //
<span class="lineNum">       3 </span>                :            : //  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
<span class="lineNum">       4 </span>                :            : //
<span class="lineNum">       5 </span>                :            : //  By downloading, copying, installing or using the software you agree to this license.
<span class="lineNum">       6 </span>                :            : //  If you do not agree to this license, do not download, install,
<span class="lineNum">       7 </span>                :            : //  copy or use the software.
<span class="lineNum">       8 </span>                :            : //
<span class="lineNum">       9 </span>                :            : //
<span class="lineNum">      10 </span>                :            : //                           License Agreement
<span class="lineNum">      11 </span>                :            : //                For Open Source Computer Vision Library
<span class="lineNum">      12 </span>                :            : //
<span class="lineNum">      13 </span>                :            : // Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
<span class="lineNum">      14 </span>                :            : // Copyright (C) 2009, Willow Garage Inc., all rights reserved.
<span class="lineNum">      15 </span>                :            : // Third party copyrights are property of their respective owners.
<span class="lineNum">      16 </span>                :            : //
<span class="lineNum">      17 </span>                :            : // Redistribution and use in source and binary forms, with or without modification,
<span class="lineNum">      18 </span>                :            : // are permitted provided that the following conditions are met:
<span class="lineNum">      19 </span>                :            : //
<span class="lineNum">      20 </span>                :            : //   * Redistribution's of source code must retain the above copyright notice,
<span class="lineNum">      21 </span>                :            : //     this list of conditions and the following disclaimer.
<span class="lineNum">      22 </span>                :            : //
<span class="lineNum">      23 </span>                :            : //   * Redistribution's in binary form must reproduce the above copyright notice,
<span class="lineNum">      24 </span>                :            : //     this list of conditions and the following disclaimer in the documentation
<span class="lineNum">      25 </span>                :            : //     and/or other materials provided with the distribution.
<span class="lineNum">      26 </span>                :            : //
<span class="lineNum">      27 </span>                :            : //   * The name of the copyright holders may not be used to endorse or promote products
<span class="lineNum">      28 </span>                :            : //     derived from this software without specific prior written permission.
<span class="lineNum">      29 </span>                :            : //
<span class="lineNum">      30 </span>                :            : // This software is provided by the copyright holders and contributors &quot;as is&quot; and
<span class="lineNum">      31 </span>                :            : // any express or implied warranties, including, but not limited to, the implied
<span class="lineNum">      32 </span>                :            : // warranties of merchantability and fitness for a particular purpose are disclaimed.
<span class="lineNum">      33 </span>                :            : // In no event shall the Intel Corporation or contributors be liable for any direct,
<span class="lineNum">      34 </span>                :            : // indirect, incidental, special, exemplary, or consequential damages
<span class="lineNum">      35 </span>                :            : // (including, but not limited to, procurement of substitute goods or services;
<span class="lineNum">      36 </span>                :            : // loss of use, data, or profits; or business interruption) however caused
<span class="lineNum">      37 </span>                :            : // and on any theory of liability, whether in contract, strict liability,
<span class="lineNum">      38 </span>                :            : // or tort (including negligence or otherwise) arising in any way out of
<span class="lineNum">      39 </span>                :            : // the use of this software, even if advised of the possibility of such damage.
<span class="lineNum">      40 </span>                :            : //
<span class="lineNum">      41 </span>                :            : //M*/
<span class="lineNum">      42 </span>                :            : 
<span class="lineNum">      43 </span>                :            : #ifndef OPENCV_IMGPROC_HPP
<span class="lineNum">      44 </span>                :            : #define OPENCV_IMGPROC_HPP
<span class="lineNum">      45 </span>                :            : 
<span class="lineNum">      46 </span>                :            : #include &quot;opencv2/core.hpp&quot;
<span class="lineNum">      47 </span>                :            : 
<span class="lineNum">      48 </span>                :            : /**
<span class="lineNum">      49 </span>                :            :   @defgroup imgproc Image Processing
<span class="lineNum">      50 </span>                :            : 
<span class="lineNum">      51 </span>                :            : This module includes image-processing functions.
<span class="lineNum">      52 </span>                :            : 
<span class="lineNum">      53 </span>                :            :   @{
<span class="lineNum">      54 </span>                :            :     @defgroup imgproc_filter Image Filtering
<span class="lineNum">      55 </span>                :            : 
<span class="lineNum">      56 </span>                :            : Functions and classes described in this section are used to perform various linear or non-linear
<span class="lineNum">      57 </span>                :            : filtering operations on 2D images (represented as Mat's). It means that for each pixel location
<span class="lineNum">      58 </span>                :            : \f$(x,y)\f$ in the source image (normally, rectangular), its neighborhood is considered and used to
<span class="lineNum">      59 </span>                :            : compute the response. In case of a linear filter, it is a weighted sum of pixel values. In case of
<span class="lineNum">      60 </span>                :            : morphological operations, it is the minimum or maximum values, and so on. The computed response is
<span class="lineNum">      61 </span>                :            : stored in the destination image at the same location \f$(x,y)\f$. It means that the output image
<span class="lineNum">      62 </span>                :            : will be of the same size as the input image. Normally, the functions support multi-channel arrays,
<span class="lineNum">      63 </span>                :            : in which case every channel is processed independently. Therefore, the output image will also have
<span class="lineNum">      64 </span>                :            : the same number of channels as the input one.
<span class="lineNum">      65 </span>                :            : 
<span class="lineNum">      66 </span>                :            : Another common feature of the functions and classes described in this section is that, unlike
<span class="lineNum">      67 </span>                :            : simple arithmetic functions, they need to extrapolate values of some non-existing pixels. For
<span class="lineNum">      68 </span>                :            : example, if you want to smooth an image using a Gaussian \f$3 \times 3\f$ filter, then, when
<span class="lineNum">      69 </span>                :            : processing the left-most pixels in each row, you need pixels to the left of them, that is, outside
<span class="lineNum">      70 </span>                :            : of the image. You can let these pixels be the same as the left-most image pixels (&quot;replicated
<span class="lineNum">      71 </span>                :            : border&quot; extrapolation method), or assume that all the non-existing pixels are zeros (&quot;constant
<span class="lineNum">      72 </span>                :            : border&quot; extrapolation method), and so on. OpenCV enables you to specify the extrapolation method.
<span class="lineNum">      73 </span>                :            : For details, see #BorderTypes
<span class="lineNum">      74 </span>                :            : 
<span class="lineNum">      75 </span>                :            : @anchor filter_depths
<span class="lineNum">      76 </span>                :            : ### Depth combinations
<span class="lineNum">      77 </span>                :            : Input depth (src.depth()) | Output depth (ddepth)
<span class="lineNum">      78 </span>                :            : --------------------------|----------------------
<span class="lineNum">      79 </span>                :            : CV_8U                     | -1/CV_16S/CV_32F/CV_64F
<span class="lineNum">      80 </span>                :            : CV_16U/CV_16S             | -1/CV_32F/CV_64F
<span class="lineNum">      81 </span>                :            : CV_32F                    | -1/CV_32F/CV_64F
<span class="lineNum">      82 </span>                :            : CV_64F                    | -1/CV_64F
<span class="lineNum">      83 </span>                :            : 
<span class="lineNum">      84 </span>                :            : @note when ddepth=-1, the output image will have the same depth as the source.
<span class="lineNum">      85 </span>                :            : 
<span class="lineNum">      86 </span>                :            :     @defgroup imgproc_transform Geometric Image Transformations
<span class="lineNum">      87 </span>                :            : 
<span class="lineNum">      88 </span>                :            : The functions in this section perform various geometrical transformations of 2D images. They do not
<span class="lineNum">      89 </span>                :            : change the image content but deform the pixel grid and map this deformed grid to the destination
<span class="lineNum">      90 </span>                :            : image. In fact, to avoid sampling artifacts, the mapping is done in the reverse order, from
<span class="lineNum">      91 </span>                :            : destination to the source. That is, for each pixel \f$(x, y)\f$ of the destination image, the
<span class="lineNum">      92 </span>                :            : functions compute coordinates of the corresponding &quot;donor&quot; pixel in the source image and copy the
<span class="lineNum">      93 </span>                :            : pixel value:
<span class="lineNum">      94 </span>                :            : 
<span class="lineNum">      95 </span>                :            : \f[\texttt{dst} (x,y)= \texttt{src} (f_x(x,y), f_y(x,y))\f]
<span class="lineNum">      96 </span>                :            : 
<span class="lineNum">      97 </span>                :            : In case when you specify the forward mapping \f$\left&lt;g_x, g_y\right&gt;: \texttt{src} \rightarrow
<span class="lineNum">      98 </span>                :            : \texttt{dst}\f$, the OpenCV functions first compute the corresponding inverse mapping
<span class="lineNum">      99 </span>                :            : \f$\left&lt;f_x, f_y\right&gt;: \texttt{dst} \rightarrow \texttt{src}\f$ and then use the above formula.
<span class="lineNum">     100 </span>                :            : 
<span class="lineNum">     101 </span>                :            : The actual implementations of the geometrical transformations, from the most generic remap and to
<span class="lineNum">     102 </span>                :            : the simplest and the fastest resize, need to solve two main problems with the above formula:
<span class="lineNum">     103 </span>                :            : 
<span class="lineNum">     104 </span>                :            : - Extrapolation of non-existing pixels. Similarly to the filtering functions described in the
<span class="lineNum">     105 </span>                :            : previous section, for some \f$(x,y)\f$, either one of \f$f_x(x,y)\f$, or \f$f_y(x,y)\f$, or both
<span class="lineNum">     106 </span>                :            : of them may fall outside of the image. In this case, an extrapolation method needs to be used.
<span class="lineNum">     107 </span>                :            : OpenCV provides the same selection of extrapolation methods as in the filtering functions. In
<span class="lineNum">     108 </span>                :            : addition, it provides the method #BORDER_TRANSPARENT. This means that the corresponding pixels in
<span class="lineNum">     109 </span>                :            : the destination image will not be modified at all.
<span class="lineNum">     110 </span>                :            : 
<span class="lineNum">     111 </span>                :            : - Interpolation of pixel values. Usually \f$f_x(x,y)\f$ and \f$f_y(x,y)\f$ are floating-point
<span class="lineNum">     112 </span>                :            : numbers. This means that \f$\left&lt;f_x, f_y\right&gt;\f$ can be either an affine or perspective
<span class="lineNum">     113 </span>                :            : transformation, or radial lens distortion correction, and so on. So, a pixel value at fractional
<span class="lineNum">     114 </span>                :            : coordinates needs to be retrieved. In the simplest case, the coordinates can be just rounded to the
<span class="lineNum">     115 </span>                :            : nearest integer coordinates and the corresponding pixel can be used. This is called a
<span class="lineNum">     116 </span>                :            : nearest-neighbor interpolation. However, a better result can be achieved by using more
<span class="lineNum">     117 </span>                :            : sophisticated [interpolation methods](http://en.wikipedia.org/wiki/Multivariate_interpolation) ,
<span class="lineNum">     118 </span>                :            : where a polynomial function is fit into some neighborhood of the computed pixel \f$(f_x(x,y),
<span class="lineNum">     119 </span>                :            : f_y(x,y))\f$, and then the value of the polynomial at \f$(f_x(x,y), f_y(x,y))\f$ is taken as the
<span class="lineNum">     120 </span>                :            : interpolated pixel value. In OpenCV, you can choose between several interpolation methods. See
<span class="lineNum">     121 </span>                :            : resize for details.
<span class="lineNum">     122 </span>                :            : 
<span class="lineNum">     123 </span>                :            : @note The geometrical transformations do not work with `CV_8S` or `CV_32S` images.
<span class="lineNum">     124 </span>                :            : 
<span class="lineNum">     125 </span>                :            :     @defgroup imgproc_misc Miscellaneous Image Transformations
<span class="lineNum">     126 </span>                :            :     @defgroup imgproc_draw Drawing Functions
<span class="lineNum">     127 </span>                :            : 
<span class="lineNum">     128 </span>                :            : Drawing functions work with matrices/images of arbitrary depth. The boundaries of the shapes can be
<span class="lineNum">     129 </span>                :            : rendered with antialiasing (implemented only for 8-bit images for now). All the functions include
<span class="lineNum">     130 </span>                :            : the parameter color that uses an RGB value (that may be constructed with the Scalar constructor )
<span class="lineNum">     131 </span>                :            : for color images and brightness for grayscale images. For color images, the channel ordering is
<span class="lineNum">     132 </span>                :            : normally *Blue, Green, Red*. This is what imshow, imread, and imwrite expect. So, if you form a
<span class="lineNum">     133 </span>                :            : color using the Scalar constructor, it should look like:
<span class="lineNum">     134 </span>                :            : 
<span class="lineNum">     135 </span>                :            : \f[\texttt{Scalar} (blue \_ component, green \_ component, red \_ component[, alpha \_ component])\f]
<span class="lineNum">     136 </span>                :            : 
<span class="lineNum">     137 </span>                :            : If you are using your own image rendering and I/O functions, you can use any channel ordering. The
<span class="lineNum">     138 </span>                :            : drawing functions process each channel independently and do not depend on the channel order or even
<span class="lineNum">     139 </span>                :            : on the used color space. The whole image can be converted from BGR to RGB or to a different color
<span class="lineNum">     140 </span>                :            : space using cvtColor .
<span class="lineNum">     141 </span>                :            : 
<span class="lineNum">     142 </span>                :            : If a drawn figure is partially or completely outside the image, the drawing functions clip it. Also,
<span class="lineNum">     143 </span>                :            : many drawing functions can handle pixel coordinates specified with sub-pixel accuracy. This means
<span class="lineNum">     144 </span>                :            : that the coordinates can be passed as fixed-point numbers encoded as integers. The number of
<span class="lineNum">     145 </span>                :            : fractional bits is specified by the shift parameter and the real point coordinates are calculated as
<span class="lineNum">     146 </span>                :            : \f$\texttt{Point}(x,y)\rightarrow\texttt{Point2f}(x*2^{-shift},y*2^{-shift})\f$ . This feature is
<span class="lineNum">     147 </span>                :            : especially effective when rendering antialiased shapes.
<span class="lineNum">     148 </span>                :            : 
<span class="lineNum">     149 </span>                :            : @note The functions do not support alpha-transparency when the target image is 4-channel. In this
<span class="lineNum">     150 </span>                :            : case, the color[3] is simply copied to the repainted pixels. Thus, if you want to paint
<span class="lineNum">     151 </span>                :            : semi-transparent shapes, you can paint them in a separate buffer and then blend it with the main
<span class="lineNum">     152 </span>                :            : image.
<span class="lineNum">     153 </span>                :            : 
<span class="lineNum">     154 </span>                :            :     @defgroup imgproc_color_conversions Color Space Conversions
<span class="lineNum">     155 </span>                :            :     @defgroup imgproc_colormap ColorMaps in OpenCV
<span class="lineNum">     156 </span>                :            : 
<span class="lineNum">     157 </span>                :            : The human perception isn't built for observing fine changes in grayscale images. Human eyes are more
<span class="lineNum">     158 </span>                :            : sensitive to observing changes between colors, so you often need to recolor your grayscale images to
<span class="lineNum">     159 </span>                :            : get a clue about them. OpenCV now comes with various colormaps to enhance the visualization in your
<span class="lineNum">     160 </span>                :            : computer vision application.
<span class="lineNum">     161 </span>                :            : 
<span class="lineNum">     162 </span>                :            : In OpenCV you only need applyColorMap to apply a colormap on a given image. The following sample
<span class="lineNum">     163 </span>                :            : code reads the path to an image from command line, applies a Jet colormap on it and shows the
<span class="lineNum">     164 </span>                :            : result:
<span class="lineNum">     165 </span>                :            : 
<span class="lineNum">     166 </span>                :            : @include snippets/imgproc_applyColorMap.cpp
<span class="lineNum">     167 </span>                :            : 
<span class="lineNum">     168 </span>                :            : @see #ColormapTypes
<span class="lineNum">     169 </span>                :            : 
<span class="lineNum">     170 </span>                :            :     @defgroup imgproc_subdiv2d Planar Subdivision
<span class="lineNum">     171 </span>                :            : 
<span class="lineNum">     172 </span>                :            : The Subdiv2D class described in this section is used to perform various planar subdivision on
<span class="lineNum">     173 </span>                :            : a set of 2D points (represented as vector of Point2f). OpenCV subdivides a plane into triangles
<span class="lineNum">     174 </span>                :            : using the Delaunay's algorithm, which corresponds to the dual graph of the Voronoi diagram.
<span class="lineNum">     175 </span>                :            : In the figure below, the Delaunay's triangulation is marked with black lines and the Voronoi
<span class="lineNum">     176 </span>                :            : diagram with red lines.
<span class="lineNum">     177 </span>                :            : 
<span class="lineNum">     178 </span>                :            : ![Delaunay triangulation (black) and Voronoi (red)](pics/delaunay_voronoi.png)
<span class="lineNum">     179 </span>                :            : 
<span class="lineNum">     180 </span>                :            : The subdivisions can be used for the 3D piece-wise transformation of a plane, morphing, fast
<span class="lineNum">     181 </span>                :            : location of points on the plane, building special graphs (such as NNG,RNG), and so forth.
<span class="lineNum">     182 </span>                :            : 
<span class="lineNum">     183 </span>                :            :     @defgroup imgproc_hist Histograms
<span class="lineNum">     184 </span>                :            :     @defgroup imgproc_shape Structural Analysis and Shape Descriptors
<span class="lineNum">     185 </span>                :            :     @defgroup imgproc_motion Motion Analysis and Object Tracking
<span class="lineNum">     186 </span>                :            :     @defgroup imgproc_feature Feature Detection
<span class="lineNum">     187 </span>                :            :     @defgroup imgproc_object Object Detection
<span class="lineNum">     188 </span>                :            :     @defgroup imgproc_c C API
<span class="lineNum">     189 </span>                :            :     @defgroup imgproc_hal Hardware Acceleration Layer
<span class="lineNum">     190 </span>                :            :     @{
<span class="lineNum">     191 </span>                :            :         @defgroup imgproc_hal_functions Functions
<span class="lineNum">     192 </span>                :            :         @defgroup imgproc_hal_interface Interface
<span class="lineNum">     193 </span>                :            :     @}
<span class="lineNum">     194 </span>                :            :   @}
<span class="lineNum">     195 </span>                :            : */
<span class="lineNum">     196 </span>                :            : 
<span class="lineNum">     197 </span>                :            : namespace cv
<span class="lineNum">     198 </span>                :            : {
<span class="lineNum">     199 </span>                :            : 
<span class="lineNum">     200 </span>                :            : /** @addtogroup imgproc
<span class="lineNum">     201 </span>                :            : @{
<span class="lineNum">     202 </span>                :            : */
<span class="lineNum">     203 </span>                :            : 
<span class="lineNum">     204 </span>                :            : //! @addtogroup imgproc_filter
<span class="lineNum">     205 </span>                :            : //! @{
<span class="lineNum">     206 </span>                :            : 
<span class="lineNum">     207 </span>                :            : enum SpecialFilter {
<span class="lineNum">     208 </span>                :            :     FILTER_SCHARR = -1
<span class="lineNum">     209 </span>                :            : };
<span class="lineNum">     210 </span>                :            : 
<span class="lineNum">     211 </span>                :            : //! type of morphological operation
<span class="lineNum">     212 </span>                :            : enum MorphTypes{
<span class="lineNum">     213 </span>                :            :     MORPH_ERODE    = 0, //!&lt; see #erode
<span class="lineNum">     214 </span>                :            :     MORPH_DILATE   = 1, //!&lt; see #dilate
<span class="lineNum">     215 </span>                :            :     MORPH_OPEN     = 2, //!&lt; an opening operation
<span class="lineNum">     216 </span>                :            :                         //!&lt; \f[\texttt{dst} = \mathrm{open} ( \texttt{src} , \texttt{element} )= \mathrm{dilate} ( \mathrm{erode} ( \texttt{src} , \texttt{element} ))\f]
<span class="lineNum">     217 </span>                :            :     MORPH_CLOSE    = 3, //!&lt; a closing operation
<span class="lineNum">     218 </span>                :            :                         //!&lt; \f[\texttt{dst} = \mathrm{close} ( \texttt{src} , \texttt{element} )= \mathrm{erode} ( \mathrm{dilate} ( \texttt{src} , \texttt{element} ))\f]
<span class="lineNum">     219 </span>                :            :     MORPH_GRADIENT = 4, //!&lt; a morphological gradient
<span class="lineNum">     220 </span>                :            :                         //!&lt; \f[\texttt{dst} = \mathrm{morph\_grad} ( \texttt{src} , \texttt{element} )= \mathrm{dilate} ( \texttt{src} , \texttt{element} )- \mathrm{erode} ( \texttt{src} , \texttt{element} )\f]
<span class="lineNum">     221 </span>                :            :     MORPH_TOPHAT   = 5, //!&lt; &quot;top hat&quot;
<span class="lineNum">     222 </span>                :            :                         //!&lt; \f[\texttt{dst} = \mathrm{tophat} ( \texttt{src} , \texttt{element} )= \texttt{src} - \mathrm{open} ( \texttt{src} , \texttt{element} )\f]
<span class="lineNum">     223 </span>                :            :     MORPH_BLACKHAT = 6, //!&lt; &quot;black hat&quot;
<span class="lineNum">     224 </span>                :            :                         //!&lt; \f[\texttt{dst} = \mathrm{blackhat} ( \texttt{src} , \texttt{element} )= \mathrm{close} ( \texttt{src} , \texttt{element} )- \texttt{src}\f]
<span class="lineNum">     225 </span>                :            :     MORPH_HITMISS  = 7  //!&lt; &quot;hit or miss&quot;
<span class="lineNum">     226 </span>                :            :                         //!&lt;   .- Only supported for CV_8UC1 binary images. A tutorial can be found in the documentation
<span class="lineNum">     227 </span>                :            : };
<span class="lineNum">     228 </span>                :            : 
<span class="lineNum">     229 </span>                :            : //! shape of the structuring element
<span class="lineNum">     230 </span>                :            : enum MorphShapes {
<span class="lineNum">     231 </span>                :            :     MORPH_RECT    = 0, //!&lt; a rectangular structuring element:  \f[E_{ij}=1\f]
<span class="lineNum">     232 </span>                :            :     MORPH_CROSS   = 1, //!&lt; a cross-shaped structuring element:
<span class="lineNum">     233 </span>                :            :                        //!&lt; \f[E_{ij} =  \fork{1}{if i=\texttt{anchor.y} or j=\texttt{anchor.x}}{0}{otherwise}\f]
<span class="lineNum">     234 </span>                :            :     MORPH_ELLIPSE = 2 //!&lt; an elliptic structuring element, that is, a filled ellipse inscribed
<span class="lineNum">     235 </span>                :            :                       //!&lt; into the rectangle Rect(0, 0, esize.width, 0.esize.height)
<span class="lineNum">     236 </span>                :            : };
<span class="lineNum">     237 </span>                :            : 
<span class="lineNum">     238 </span>                :            : //! @} imgproc_filter
<span class="lineNum">     239 </span>                :            : 
<span class="lineNum">     240 </span>                :            : //! @addtogroup imgproc_transform
<span class="lineNum">     241 </span>                :            : //! @{
<span class="lineNum">     242 </span>                :            : 
<span class="lineNum">     243 </span>                :            : //! interpolation algorithm
<span class="lineNum">     244 </span>                :            : enum InterpolationFlags{
<span class="lineNum">     245 </span>                :            :     /** nearest neighbor interpolation */
<span class="lineNum">     246 </span>                :            :     INTER_NEAREST        = 0,
<span class="lineNum">     247 </span>                :            :     /** bilinear interpolation */
<span class="lineNum">     248 </span>                :            :     INTER_LINEAR         = 1,
<span class="lineNum">     249 </span>                :            :     /** bicubic interpolation */
<span class="lineNum">     250 </span>                :            :     INTER_CUBIC          = 2,
<span class="lineNum">     251 </span>                :            :     /** resampling using pixel area relation. It may be a preferred method for image decimation, as
<span class="lineNum">     252 </span>                :            :     it gives moire'-free results. But when the image is zoomed, it is similar to the INTER_NEAREST
<span class="lineNum">     253 </span>                :            :     method. */
<span class="lineNum">     254 </span>                :            :     INTER_AREA           = 3,
<span class="lineNum">     255 </span>                :            :     /** Lanczos interpolation over 8x8 neighborhood */
<span class="lineNum">     256 </span>                :            :     INTER_LANCZOS4       = 4,
<span class="lineNum">     257 </span>                :            :     /** Bit exact bilinear interpolation */
<span class="lineNum">     258 </span>                :            :     INTER_LINEAR_EXACT = 5,
<span class="lineNum">     259 </span>                :            :     /** mask for interpolation codes */
<span class="lineNum">     260 </span>                :            :     INTER_MAX            = 7,
<span class="lineNum">     261 </span>                :            :     /** flag, fills all of the destination image pixels. If some of them correspond to outliers in the
<span class="lineNum">     262 </span>                :            :     source image, they are set to zero */
<span class="lineNum">     263 </span>                :            :     WARP_FILL_OUTLIERS   = 8,
<span class="lineNum">     264 </span>                :            :     /** flag, inverse transformation
<span class="lineNum">     265 </span>                :            : 
<span class="lineNum">     266 </span>                :            :     For example, #linearPolar or #logPolar transforms:
<span class="lineNum">     267 </span>                :            :     - flag is __not__ set: \f$dst( \rho , \phi ) = src(x,y)\f$
<span class="lineNum">     268 </span>                :            :     - flag is set: \f$dst(x,y) = src( \rho , \phi )\f$
<span class="lineNum">     269 </span>                :            :     */
<span class="lineNum">     270 </span>                :            :     WARP_INVERSE_MAP     = 16
<span class="lineNum">     271 </span>                :            : };
<span class="lineNum">     272 </span>                :            : 
<span class="lineNum">     273 </span>                :            : /** \brief Specify the polar mapping mode
<span class="lineNum">     274 </span>                :            : @sa warpPolar
<span class="lineNum">     275 </span>                :            : */
<span class="lineNum">     276 </span>                :            : enum WarpPolarMode
<span class="lineNum">     277 </span>                :            : {
<span class="lineNum">     278 </span>                :            :     WARP_POLAR_LINEAR = 0, ///&lt; Remaps an image to/from polar space.
<span class="lineNum">     279 </span>                :            :     WARP_POLAR_LOG = 256   ///&lt; Remaps an image to/from semilog-polar space.
<span class="lineNum">     280 </span>                :            : };
<span class="lineNum">     281 </span>                :            : 
<span class="lineNum">     282 </span>                :            : enum InterpolationMasks {
<span class="lineNum">     283 </span>                :            :        INTER_BITS      = 5,
<span class="lineNum">     284 </span>                :            :        INTER_BITS2     = INTER_BITS * 2,
<span class="lineNum">     285 </span>                :            :        INTER_TAB_SIZE  = 1 &lt;&lt; INTER_BITS,
<span class="lineNum">     286 </span>                :            :        INTER_TAB_SIZE2 = INTER_TAB_SIZE * INTER_TAB_SIZE
<span class="lineNum">     287 </span>                :            :      };
<span class="lineNum">     288 </span>                :            : 
<span class="lineNum">     289 </span>                :            : //! @} imgproc_transform
<span class="lineNum">     290 </span>                :            : 
<span class="lineNum">     291 </span>                :            : //! @addtogroup imgproc_misc
<span class="lineNum">     292 </span>                :            : //! @{
<span class="lineNum">     293 </span>                :            : 
<span class="lineNum">     294 </span>                :            : //! Distance types for Distance Transform and M-estimators
<span class="lineNum">     295 </span>                :            : //! @see distanceTransform, fitLine
<span class="lineNum">     296 </span>                :            : enum DistanceTypes {
<span class="lineNum">     297 </span>                :            :     DIST_USER    = -1,  //!&lt; User defined distance
<span class="lineNum">     298 </span>                :            :     DIST_L1      = 1,   //!&lt; distance = |x1-x2| + |y1-y2|
<span class="lineNum">     299 </span>                :            :     DIST_L2      = 2,   //!&lt; the simple euclidean distance
<span class="lineNum">     300 </span>                :            :     DIST_C       = 3,   //!&lt; distance = max(|x1-x2|,|y1-y2|)
<span class="lineNum">     301 </span>                :            :     DIST_L12     = 4,   //!&lt; L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1))
<span class="lineNum">     302 </span>                :            :     DIST_FAIR    = 5,   //!&lt; distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998
<span class="lineNum">     303 </span>                :            :     DIST_WELSCH  = 6,   //!&lt; distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846
<span class="lineNum">     304 </span>                :            :     DIST_HUBER   = 7    //!&lt; distance = |x|&lt;c ? x^2/2 : c(|x|-c/2), c=1.345
<span class="lineNum">     305 </span>                :            : };
<span class="lineNum">     306 </span>                :            : 
<span class="lineNum">     307 </span>                :            : //! Mask size for distance transform
<span class="lineNum">     308 </span>                :            : enum DistanceTransformMasks {
<span class="lineNum">     309 </span>                :            :     DIST_MASK_3       = 3, //!&lt; mask=3
<span class="lineNum">     310 </span>                :            :     DIST_MASK_5       = 5, //!&lt; mask=5
<span class="lineNum">     311 </span>                :            :     DIST_MASK_PRECISE = 0  //!&lt;
<span class="lineNum">     312 </span>                :            : };
<span class="lineNum">     313 </span>                :            : 
<span class="lineNum">     314 </span>                :            : //! type of the threshold operation
<span class="lineNum">     315 </span>                :            : //! ![threshold types](pics/threshold.png)
<span class="lineNum">     316 </span>                :            : enum ThresholdTypes {
<span class="lineNum">     317 </span>                :            :     THRESH_BINARY     = 0, //!&lt; \f[\texttt{dst} (x,y) =  \fork{\texttt{maxval}}{if \(\texttt{src}(x,y) &gt; \texttt{thresh}\)}{0}{otherwise}\f]
<span class="lineNum">     318 </span>                :            :     THRESH_BINARY_INV = 1, //!&lt; \f[\texttt{dst} (x,y) =  \fork{0}{if \(\texttt{src}(x,y) &gt; \texttt{thresh}\)}{\texttt{maxval}}{otherwise}\f]
<span class="lineNum">     319 </span>                :            :     THRESH_TRUNC      = 2, //!&lt; \f[\texttt{dst} (x,y) =  \fork{\texttt{threshold}}{if \(\texttt{src}(x,y) &gt; \texttt{thresh}\)}{\texttt{src}(x,y)}{otherwise}\f]
<span class="lineNum">     320 </span>                :            :     THRESH_TOZERO     = 3, //!&lt; \f[\texttt{dst} (x,y) =  \fork{\texttt{src}(x,y)}{if \(\texttt{src}(x,y) &gt; \texttt{thresh}\)}{0}{otherwise}\f]
<span class="lineNum">     321 </span>                :            :     THRESH_TOZERO_INV = 4, //!&lt; \f[\texttt{dst} (x,y) =  \fork{0}{if \(\texttt{src}(x,y) &gt; \texttt{thresh}\)}{\texttt{src}(x,y)}{otherwise}\f]
<span class="lineNum">     322 </span>                :            :     THRESH_MASK       = 7,
<span class="lineNum">     323 </span>                :            :     THRESH_OTSU       = 8, //!&lt; flag, use Otsu algorithm to choose the optimal threshold value
<span class="lineNum">     324 </span>                :            :     THRESH_TRIANGLE   = 16 //!&lt; flag, use Triangle algorithm to choose the optimal threshold value
<span class="lineNum">     325 </span>                :            : };
<span class="lineNum">     326 </span>                :            : 
<span class="lineNum">     327 </span>                :            : //! adaptive threshold algorithm
<span class="lineNum">     328 </span>                :            : //! @see adaptiveThreshold
<span class="lineNum">     329 </span>                :            : enum AdaptiveThresholdTypes {
<span class="lineNum">     330 </span>                :            :     /** the threshold value \f$T(x,y)\f$ is a mean of the \f$\texttt{blockSize} \times
<span class="lineNum">     331 </span>                :            :     \texttt{blockSize}\f$ neighborhood of \f$(x, y)\f$ minus C */
<span class="lineNum">     332 </span>                :            :     ADAPTIVE_THRESH_MEAN_C     = 0,
<span class="lineNum">     333 </span>                :            :     /** the threshold value \f$T(x, y)\f$ is a weighted sum (cross-correlation with a Gaussian
<span class="lineNum">     334 </span>                :            :     window) of the \f$\texttt{blockSize} \times \texttt{blockSize}\f$ neighborhood of \f$(x, y)\f$
<span class="lineNum">     335 </span>                :            :     minus C . The default sigma (standard deviation) is used for the specified blockSize . See
<span class="lineNum">     336 </span>                :            :     #getGaussianKernel*/
<span class="lineNum">     337 </span>                :            :     ADAPTIVE_THRESH_GAUSSIAN_C = 1
<span class="lineNum">     338 </span>                :            : };
<span class="lineNum">     339 </span>                :            : 
<span class="lineNum">     340 </span>                :            : //! class of the pixel in GrabCut algorithm
<span class="lineNum">     341 </span>                :            : enum GrabCutClasses {
<span class="lineNum">     342 </span>                :            :     GC_BGD    = 0,  //!&lt; an obvious background pixels
<span class="lineNum">     343 </span>                :            :     GC_FGD    = 1,  //!&lt; an obvious foreground (object) pixel
<span class="lineNum">     344 </span>                :            :     GC_PR_BGD = 2,  //!&lt; a possible background pixel
<span class="lineNum">     345 </span>                :            :     GC_PR_FGD = 3   //!&lt; a possible foreground pixel
<span class="lineNum">     346 </span>                :            : };
<span class="lineNum">     347 </span>                :            : 
<span class="lineNum">     348 </span>                :            : //! GrabCut algorithm flags
<span class="lineNum">     349 </span>                :            : enum GrabCutModes {
<span class="lineNum">     350 </span>                :            :     /** The function initializes the state and the mask using the provided rectangle. After that it
<span class="lineNum">     351 </span>                :            :     runs iterCount iterations of the algorithm. */
<span class="lineNum">     352 </span>                :            :     GC_INIT_WITH_RECT  = 0,
<span class="lineNum">     353 </span>                :            :     /** The function initializes the state using the provided mask. Note that GC_INIT_WITH_RECT
<span class="lineNum">     354 </span>                :            :     and GC_INIT_WITH_MASK can be combined. Then, all the pixels outside of the ROI are
<span class="lineNum">     355 </span>                :            :     automatically initialized with GC_BGD .*/
<span class="lineNum">     356 </span>                :            :     GC_INIT_WITH_MASK  = 1,
<span class="lineNum">     357 </span>                :            :     /** The value means that the algorithm should just resume. */
<span class="lineNum">     358 </span>                :            :     GC_EVAL            = 2,
<span class="lineNum">     359 </span>                :            :     /** The value means that the algorithm should just run the grabCut algorithm (a single iteration) with the fixed model */
<span class="lineNum">     360 </span>                :            :     GC_EVAL_FREEZE_MODEL = 3
<span class="lineNum">     361 </span>                :            : };
<span class="lineNum">     362 </span>                :            : 
<span class="lineNum">     363 </span>                :            : //! distanceTransform algorithm flags
<span class="lineNum">     364 </span>                :            : enum DistanceTransformLabelTypes {
<span class="lineNum">     365 </span>                :            :     /** each connected component of zeros in src (as well as all the non-zero pixels closest to the
<span class="lineNum">     366 </span>                :            :     connected component) will be assigned the same label */
<span class="lineNum">     367 </span>                :            :     DIST_LABEL_CCOMP = 0,
<span class="lineNum">     368 </span>                :            :     /** each zero pixel (and all the non-zero pixels closest to it) gets its own label. */
<span class="lineNum">     369 </span>                :            :     DIST_LABEL_PIXEL = 1
<span class="lineNum">     370 </span>                :            : };
<span class="lineNum">     371 </span>                :            : 
<span class="lineNum">     372 </span>                :            : //! floodfill algorithm flags
<span class="lineNum">     373 </span>                :            : enum FloodFillFlags {
<span class="lineNum">     374 </span>                :            :     /** If set, the difference between the current pixel and seed pixel is considered. Otherwise,
<span class="lineNum">     375 </span>                :            :     the difference between neighbor pixels is considered (that is, the range is floating). */
<span class="lineNum">     376 </span>                :            :     FLOODFILL_FIXED_RANGE = 1 &lt;&lt; 16,
<span class="lineNum">     377 </span>                :            :     /** If set, the function does not change the image ( newVal is ignored), and only fills the
<span class="lineNum">     378 </span>                :            :     mask with the value specified in bits 8-16 of flags as described above. This option only make
<span class="lineNum">     379 </span>                :            :     sense in function variants that have the mask parameter. */
<span class="lineNum">     380 </span>                :            :     FLOODFILL_MASK_ONLY   = 1 &lt;&lt; 17
<span class="lineNum">     381 </span>                :            : };
<span class="lineNum">     382 </span>                :            : 
<span class="lineNum">     383 </span>                :            : //! @} imgproc_misc
<span class="lineNum">     384 </span>                :            : 
<span class="lineNum">     385 </span>                :            : //! @addtogroup imgproc_shape
<span class="lineNum">     386 </span>                :            : //! @{
<span class="lineNum">     387 </span>                :            : 
<span class="lineNum">     388 </span>                :            : //! connected components algorithm output formats
<span class="lineNum">     389 </span>                :            : enum ConnectedComponentsTypes {
<span class="lineNum">     390 </span>                :            :     CC_STAT_LEFT   = 0, //!&lt; The leftmost (x) coordinate which is the inclusive start of the bounding
<span class="lineNum">     391 </span>                :            :                         //!&lt; box in the horizontal direction.
<span class="lineNum">     392 </span>                :            :     CC_STAT_TOP    = 1, //!&lt; The topmost (y) coordinate which is the inclusive start of the bounding
<span class="lineNum">     393 </span>                :            :                         //!&lt; box in the vertical direction.
<span class="lineNum">     394 </span>                :            :     CC_STAT_WIDTH  = 2, //!&lt; The horizontal size of the bounding box
<span class="lineNum">     395 </span>                :            :     CC_STAT_HEIGHT = 3, //!&lt; The vertical size of the bounding box
<span class="lineNum">     396 </span>                :            :     CC_STAT_AREA   = 4, //!&lt; The total area (in pixels) of the connected component
<span class="lineNum">     397 </span>                :            :     CC_STAT_MAX    = 5
<span class="lineNum">     398 </span>                :            : };
<span class="lineNum">     399 </span>                :            : 
<span class="lineNum">     400 </span>                :            : //! connected components algorithm
<span class="lineNum">     401 </span>                :            : enum ConnectedComponentsAlgorithmsTypes {
<span class="lineNum">     402 </span>                :            :     CCL_WU      = 0,  //!&lt; SAUF algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity
<span class="lineNum">     403 </span>                :            :     CCL_DEFAULT = -1, //!&lt; BBDT algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity
<span class="lineNum">     404 </span>                :            :     CCL_GRANA   = 1   //!&lt; BBDT algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity
<span class="lineNum">     405 </span>                :            : };
<span class="lineNum">     406 </span>                :            : 
<span class="lineNum">     407 </span>                :            : //! mode of the contour retrieval algorithm
<span class="lineNum">     408 </span>                :            : enum RetrievalModes {
<span class="lineNum">     409 </span>                :            :     /** retrieves only the extreme outer contours. It sets `hierarchy[i][2]=hierarchy[i][3]=-1` for
<span class="lineNum">     410 </span>                :            :     all the contours. */
<span class="lineNum">     411 </span>                :            :     RETR_EXTERNAL  = 0,
<span class="lineNum">     412 </span>                :            :     /** retrieves all of the contours without establishing any hierarchical relationships. */
<span class="lineNum">     413 </span>                :            :     RETR_LIST      = 1,
<span class="lineNum">     414 </span>                :            :     /** retrieves all of the contours and organizes them into a two-level hierarchy. At the top
<span class="lineNum">     415 </span>                :            :     level, there are external boundaries of the components. At the second level, there are
<span class="lineNum">     416 </span>                :            :     boundaries of the holes. If there is another contour inside a hole of a connected component, it
<span class="lineNum">     417 </span>                :            :     is still put at the top level. */
<span class="lineNum">     418 </span>                :            :     RETR_CCOMP     = 2,
<span class="lineNum">     419 </span>                :            :     /** retrieves all of the contours and reconstructs a full hierarchy of nested contours.*/
<span class="lineNum">     420 </span>                :            :     RETR_TREE      = 3,
<span class="lineNum">     421 </span>                :            :     RETR_FLOODFILL = 4 //!&lt;
<span class="lineNum">     422 </span>                :            : };
<span class="lineNum">     423 </span>                :            : 
<span class="lineNum">     424 </span>                :            : //! the contour approximation algorithm
<span class="lineNum">     425 </span>                :            : enum ContourApproximationModes {
<span class="lineNum">     426 </span>                :            :     /** stores absolutely all the contour points. That is, any 2 subsequent points (x1,y1) and
<span class="lineNum">     427 </span>                :            :     (x2,y2) of the contour will be either horizontal, vertical or diagonal neighbors, that is,
<span class="lineNum">     428 </span>                :            :     max(abs(x1-x2),abs(y2-y1))==1. */
<span class="lineNum">     429 </span>                :            :     CHAIN_APPROX_NONE      = 1,
<span class="lineNum">     430 </span>                :            :     /** compresses horizontal, vertical, and diagonal segments and leaves only their end points.
<span class="lineNum">     431 </span>                :            :     For example, an up-right rectangular contour is encoded with 4 points. */
<span class="lineNum">     432 </span>                :            :     CHAIN_APPROX_SIMPLE    = 2,
<span class="lineNum">     433 </span>                :            :     /** applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89 */
<span class="lineNum">     434 </span>                :            :     CHAIN_APPROX_TC89_L1   = 3,
<span class="lineNum">     435 </span>                :            :     /** applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89 */
<span class="lineNum">     436 </span>                :            :     CHAIN_APPROX_TC89_KCOS = 4
<span class="lineNum">     437 </span>                :            : };
<span class="lineNum">     438 </span>                :            : 
<span class="lineNum">     439 </span>                :            : /** @brief Shape matching methods
<span class="lineNum">     440 </span>                :            : 
<span class="lineNum">     441 </span>                :            : \f$A\f$ denotes object1,\f$B\f$ denotes object2
<span class="lineNum">     442 </span>                :            : 
<span class="lineNum">     443 </span>                :            : \f$\begin{array}{l} m^A_i =  \mathrm{sign} (h^A_i)  \cdot \log{h^A_i} \\ m^B_i =  \mathrm{sign} (h^B_i)  \cdot \log{h^B_i} \end{array}\f$
<span class="lineNum">     444 </span>                :            : 
<span class="lineNum">     445 </span>                :            : and \f$h^A_i, h^B_i\f$ are the Hu moments of \f$A\f$ and \f$B\f$ , respectively.
<span class="lineNum">     446 </span>                :            : */
<span class="lineNum">     447 </span>                :            : enum ShapeMatchModes {
<span class="lineNum">     448 </span>                :            :     CONTOURS_MATCH_I1  =1, //!&lt; \f[I_1(A,B) =  \sum _{i=1...7}  \left |  \frac{1}{m^A_i} -  \frac{1}{m^B_i} \right |\f]
<span class="lineNum">     449 </span>                :            :     CONTOURS_MATCH_I2  =2, //!&lt; \f[I_2(A,B) =  \sum _{i=1...7}  \left | m^A_i - m^B_i  \right |\f]
<span class="lineNum">     450 </span>                :            :     CONTOURS_MATCH_I3  =3  //!&lt; \f[I_3(A,B) =  \max _{i=1...7}  \frac{ \left| m^A_i - m^B_i \right| }{ \left| m^A_i \right| }\f]
<span class="lineNum">     451 </span>                :            : };
<span class="lineNum">     452 </span>                :            : 
<span class="lineNum">     453 </span>                :            : //! @} imgproc_shape
<span class="lineNum">     454 </span>                :            : 
<span class="lineNum">     455 </span>                :            : //! @addtogroup imgproc_feature
<span class="lineNum">     456 </span>                :            : //! @{
<span class="lineNum">     457 </span>                :            : 
<span class="lineNum">     458 </span>                :            : //! Variants of a Hough transform
<span class="lineNum">     459 </span>                :            : enum HoughModes {
<span class="lineNum">     460 </span>                :            : 
<span class="lineNum">     461 </span>                :            :     /** classical or standard Hough transform. Every line is represented by two floating-point
<span class="lineNum">     462 </span>                :            :     numbers \f$(\rho, \theta)\f$ , where \f$\rho\f$ is a distance between (0,0) point and the line,
<span class="lineNum">     463 </span>                :            :     and \f$\theta\f$ is the angle between x-axis and the normal to the line. Thus, the matrix must
<span class="lineNum">     464 </span>                :            :     be (the created sequence will be) of CV_32FC2 type */
<span class="lineNum">     465 </span>                :            :     HOUGH_STANDARD      = 0,
<span class="lineNum">     466 </span>                :            :     /** probabilistic Hough transform (more efficient in case if the picture contains a few long
<span class="lineNum">     467 </span>                :            :     linear segments). It returns line segments rather than the whole line. Each segment is
<span class="lineNum">     468 </span>                :            :     represented by starting and ending points, and the matrix must be (the created sequence will
<span class="lineNum">     469 </span>                :            :     be) of the CV_32SC4 type. */
<span class="lineNum">     470 </span>                :            :     HOUGH_PROBABILISTIC = 1,
<span class="lineNum">     471 </span>                :            :     /** multi-scale variant of the classical Hough transform. The lines are encoded the same way as
<span class="lineNum">     472 </span>                :            :     HOUGH_STANDARD. */
<span class="lineNum">     473 </span>                :            :     HOUGH_MULTI_SCALE   = 2,
<span class="lineNum">     474 </span>                :            :     HOUGH_GRADIENT      = 3 //!&lt; basically *21HT*, described in @cite Yuen90
<span class="lineNum">     475 </span>                :            : };
<span class="lineNum">     476 </span>                :            : 
<span class="lineNum">     477 </span>                :            : //! Variants of Line Segment %Detector
<span class="lineNum">     478 </span>                :            : enum LineSegmentDetectorModes {
<span class="lineNum">     479 </span>                :            :     LSD_REFINE_NONE = 0, //!&lt; No refinement applied
<span class="lineNum">     480 </span>                :            :     LSD_REFINE_STD  = 1, //!&lt; Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations.
<span class="lineNum">     481 </span>                :            :     LSD_REFINE_ADV  = 2  //!&lt; Advanced refinement. Number of false alarms is calculated, lines are
<span class="lineNum">     482 </span>                :            :                          //!&lt; refined through increase of precision, decrement in size, etc.
<span class="lineNum">     483 </span>                :            : };
<span class="lineNum">     484 </span>                :            : 
<span class="lineNum">     485 </span>                :            : //! @} imgproc_feature
<span class="lineNum">     486 </span>                :            : 
<span class="lineNum">     487 </span>                :            : /** Histogram comparison methods
<span class="lineNum">     488 </span>                :            :   @ingroup imgproc_hist
<span class="lineNum">     489 </span>                :            : */
<span class="lineNum">     490 </span>                :            : enum HistCompMethods {
<span class="lineNum">     491 </span>                :            :     /** Correlation
<span class="lineNum">     492 </span>                :            :     \f[d(H_1,H_2) =  \frac{\sum_I (H_1(I) - \bar{H_1}) (H_2(I) - \bar{H_2})}{\sqrt{\sum_I(H_1(I) - \bar{H_1})^2 \sum_I(H_2(I) - \bar{H_2})^2}}\f]
<span class="lineNum">     493 </span>                :            :     where
<span class="lineNum">     494 </span>                :            :     \f[\bar{H_k} =  \frac{1}{N} \sum _J H_k(J)\f]
<span class="lineNum">     495 </span>                :            :     and \f$N\f$ is a total number of histogram bins. */
<span class="lineNum">     496 </span>                :            :     HISTCMP_CORREL        = 0,
<span class="lineNum">     497 </span>                :            :     /** Chi-Square
<span class="lineNum">     498 </span>                :            :     \f[d(H_1,H_2) =  \sum _I  \frac{\left(H_1(I)-H_2(I)\right)^2}{H_1(I)}\f] */
<span class="lineNum">     499 </span>                :            :     HISTCMP_CHISQR        = 1,
<span class="lineNum">     500 </span>                :            :     /** Intersection
<span class="lineNum">     501 </span>                :            :     \f[d(H_1,H_2) =  \sum _I  \min (H_1(I), H_2(I))\f] */
<span class="lineNum">     502 </span>                :            :     HISTCMP_INTERSECT     = 2,
<span class="lineNum">     503 </span>                :            :     /** Bhattacharyya distance
<span class="lineNum">     504 </span>                :            :     (In fact, OpenCV computes Hellinger distance, which is related to Bhattacharyya coefficient.)
<span class="lineNum">     505 </span>                :            :     \f[d(H_1,H_2) =  \sqrt{1 - \frac{1}{\sqrt{\bar{H_1} \bar{H_2} N^2}} \sum_I \sqrt{H_1(I) \cdot H_2(I)}}\f] */
<span class="lineNum">     506 </span>                :            :     HISTCMP_BHATTACHARYYA = 3,
<span class="lineNum">     507 </span>                :            :     HISTCMP_HELLINGER     = HISTCMP_BHATTACHARYYA, //!&lt; Synonym for HISTCMP_BHATTACHARYYA
<span class="lineNum">     508 </span>                :            :     /** Alternative Chi-Square
<span class="lineNum">     509 </span>                :            :     \f[d(H_1,H_2) =  2 * \sum _I  \frac{\left(H_1(I)-H_2(I)\right)^2}{H_1(I)+H_2(I)}\f]
<span class="lineNum">     510 </span>                :            :     This alternative formula is regularly used for texture comparison. See e.g. @cite Puzicha1997 */
<span class="lineNum">     511 </span>                :            :     HISTCMP_CHISQR_ALT    = 4,
<span class="lineNum">     512 </span>                :            :     /** Kullback-Leibler divergence
<span class="lineNum">     513 </span>                :            :     \f[d(H_1,H_2) = \sum _I H_1(I) \log \left(\frac{H_1(I)}{H_2(I)}\right)\f] */
<span class="lineNum">     514 </span>                :            :     HISTCMP_KL_DIV        = 5
<span class="lineNum">     515 </span>                :            : };
<span class="lineNum">     516 </span>                :            : 
<span class="lineNum">     517 </span>                :            : /** the color conversion codes
<span class="lineNum">     518 </span>                :            : @see @ref imgproc_color_conversions
<span class="lineNum">     519 </span>                :            : @ingroup imgproc_color_conversions
<span class="lineNum">     520 </span>                :            :  */
<span class="lineNum">     521 </span>                :            : enum ColorConversionCodes {
<span class="lineNum">     522 </span>                :            :     COLOR_BGR2BGRA     = 0, //!&lt; add alpha channel to RGB or BGR image
<span class="lineNum">     523 </span>                :            :     COLOR_RGB2RGBA     = COLOR_BGR2BGRA,
<span class="lineNum">     524 </span>                :            : 
<span class="lineNum">     525 </span>                :            :     COLOR_BGRA2BGR     = 1, //!&lt; remove alpha channel from RGB or BGR image
<span class="lineNum">     526 </span>                :            :     COLOR_RGBA2RGB     = COLOR_BGRA2BGR,
<span class="lineNum">     527 </span>                :            : 
<span class="lineNum">     528 </span>                :            :     COLOR_BGR2RGBA     = 2, //!&lt; convert between RGB and BGR color spaces (with or without alpha channel)
<span class="lineNum">     529 </span>                :            :     COLOR_RGB2BGRA     = COLOR_BGR2RGBA,
<span class="lineNum">     530 </span>                :            : 
<span class="lineNum">     531 </span>                :            :     COLOR_RGBA2BGR     = 3,
<span class="lineNum">     532 </span>                :            :     COLOR_BGRA2RGB     = COLOR_RGBA2BGR,
<span class="lineNum">     533 </span>                :            : 
<span class="lineNum">     534 </span>                :            :     COLOR_BGR2RGB      = 4,
<span class="lineNum">     535 </span>                :            :     COLOR_RGB2BGR      = COLOR_BGR2RGB,
<span class="lineNum">     536 </span>                :            : 
<span class="lineNum">     537 </span>                :            :     COLOR_BGRA2RGBA    = 5,
<span class="lineNum">     538 </span>                :            :     COLOR_RGBA2BGRA    = COLOR_BGRA2RGBA,
<span class="lineNum">     539 </span>                :            : 
<span class="lineNum">     540 </span>                :            :     COLOR_BGR2GRAY     = 6, //!&lt; convert between RGB/BGR and grayscale, @ref color_convert_rgb_gray &quot;color conversions&quot;
<span class="lineNum">     541 </span>                :            :     COLOR_RGB2GRAY     = 7,
<span class="lineNum">     542 </span>                :            :     COLOR_GRAY2BGR     = 8,
<span class="lineNum">     543 </span>                :            :     COLOR_GRAY2RGB     = COLOR_GRAY2BGR,
<span class="lineNum">     544 </span>                :            :     COLOR_GRAY2BGRA    = 9,
<span class="lineNum">     545 </span>                :            :     COLOR_GRAY2RGBA    = COLOR_GRAY2BGRA,
<span class="lineNum">     546 </span>                :            :     COLOR_BGRA2GRAY    = 10,
<span class="lineNum">     547 </span>                :            :     COLOR_RGBA2GRAY    = 11,
<span class="lineNum">     548 </span>                :            : 
<span class="lineNum">     549 </span>                :            :     COLOR_BGR2BGR565   = 12, //!&lt; convert between RGB/BGR and BGR565 (16-bit images)
<span class="lineNum">     550 </span>                :            :     COLOR_RGB2BGR565   = 13,
<span class="lineNum">     551 </span>                :            :     COLOR_BGR5652BGR   = 14,
<span class="lineNum">     552 </span>                :            :     COLOR_BGR5652RGB   = 15,
<span class="lineNum">     553 </span>                :            :     COLOR_BGRA2BGR565  = 16,
<span class="lineNum">     554 </span>                :            :     COLOR_RGBA2BGR565  = 17,
<span class="lineNum">     555 </span>                :            :     COLOR_BGR5652BGRA  = 18,
<span class="lineNum">     556 </span>                :            :     COLOR_BGR5652RGBA  = 19,
<span class="lineNum">     557 </span>                :            : 
<span class="lineNum">     558 </span>                :            :     COLOR_GRAY2BGR565  = 20, //!&lt; convert between grayscale to BGR565 (16-bit images)
<span class="lineNum">     559 </span>                :            :     COLOR_BGR5652GRAY  = 21,
<span class="lineNum">     560 </span>                :            : 
<span class="lineNum">     561 </span>                :            :     COLOR_BGR2BGR555   = 22,  //!&lt; convert between RGB/BGR and BGR555 (16-bit images)
<span class="lineNum">     562 </span>                :            :     COLOR_RGB2BGR555   = 23,
<span class="lineNum">     563 </span>                :            :     COLOR_BGR5552BGR   = 24,
<span class="lineNum">     564 </span>                :            :     COLOR_BGR5552RGB   = 25,
<span class="lineNum">     565 </span>                :            :     COLOR_BGRA2BGR555  = 26,
<span class="lineNum">     566 </span>                :            :     COLOR_RGBA2BGR555  = 27,
<span class="lineNum">     567 </span>                :            :     COLOR_BGR5552BGRA  = 28,
<span class="lineNum">     568 </span>                :            :     COLOR_BGR5552RGBA  = 29,
<span class="lineNum">     569 </span>                :            : 
<span class="lineNum">     570 </span>                :            :     COLOR_GRAY2BGR555  = 30, //!&lt; convert between grayscale and BGR555 (16-bit images)
<span class="lineNum">     571 </span>                :            :     COLOR_BGR5552GRAY  = 31,
<span class="lineNum">     572 </span>                :            : 
<span class="lineNum">     573 </span>                :            :     COLOR_BGR2XYZ      = 32, //!&lt; convert RGB/BGR to CIE XYZ, @ref color_convert_rgb_xyz &quot;color conversions&quot;
<span class="lineNum">     574 </span>                :            :     COLOR_RGB2XYZ      = 33,
<span class="lineNum">     575 </span>                :            :     COLOR_XYZ2BGR      = 34,
<span class="lineNum">     576 </span>                :            :     COLOR_XYZ2RGB      = 35,
<span class="lineNum">     577 </span>                :            : 
<span class="lineNum">     578 </span>                :            :     COLOR_BGR2YCrCb    = 36, //!&lt; convert RGB/BGR to luma-chroma (aka YCC), @ref color_convert_rgb_ycrcb &quot;color conversions&quot;
<span class="lineNum">     579 </span>                :            :     COLOR_RGB2YCrCb    = 37,
<span class="lineNum">     580 </span>                :            :     COLOR_YCrCb2BGR    = 38,
<span class="lineNum">     581 </span>                :            :     COLOR_YCrCb2RGB    = 39,
<span class="lineNum">     582 </span>                :            : 
<span class="lineNum">     583 </span>                :            :     COLOR_BGR2HSV      = 40, //!&lt; convert RGB/BGR to HSV (hue saturation value), @ref color_convert_rgb_hsv &quot;color conversions&quot;
<span class="lineNum">     584 </span>                :            :     COLOR_RGB2HSV      = 41,
<span class="lineNum">     585 </span>                :            : 
<span class="lineNum">     586 </span>                :            :     COLOR_BGR2Lab      = 44, //!&lt; convert RGB/BGR to CIE Lab, @ref color_convert_rgb_lab &quot;color conversions&quot;
<span class="lineNum">     587 </span>                :            :     COLOR_RGB2Lab      = 45,
<span class="lineNum">     588 </span>                :            : 
<span class="lineNum">     589 </span>                :            :     COLOR_BGR2Luv      = 50, //!&lt; convert RGB/BGR to CIE Luv, @ref color_convert_rgb_luv &quot;color conversions&quot;
<span class="lineNum">     590 </span>                :            :     COLOR_RGB2Luv      = 51,
<span class="lineNum">     591 </span>                :            :     COLOR_BGR2HLS      = 52, //!&lt; convert RGB/BGR to HLS (hue lightness saturation), @ref color_convert_rgb_hls &quot;color conversions&quot;
<span class="lineNum">     592 </span>                :            :     COLOR_RGB2HLS      = 53,
<span class="lineNum">     593 </span>                :            : 
<span class="lineNum">     594 </span>                :            :     COLOR_HSV2BGR      = 54, //!&lt; backward conversions to RGB/BGR
<span class="lineNum">     595 </span>                :            :     COLOR_HSV2RGB      = 55,
<span class="lineNum">     596 </span>                :            : 
<span class="lineNum">     597 </span>                :            :     COLOR_Lab2BGR      = 56,
<span class="lineNum">     598 </span>                :            :     COLOR_Lab2RGB      = 57,
<span class="lineNum">     599 </span>                :            :     COLOR_Luv2BGR      = 58,
<span class="lineNum">     600 </span>                :            :     COLOR_Luv2RGB      = 59,
<span class="lineNum">     601 </span>                :            :     COLOR_HLS2BGR      = 60,
<span class="lineNum">     602 </span>                :            :     COLOR_HLS2RGB      = 61,
<span class="lineNum">     603 </span>                :            : 
<span class="lineNum">     604 </span>                :            :     COLOR_BGR2HSV_FULL = 66,
<span class="lineNum">     605 </span>                :            :     COLOR_RGB2HSV_FULL = 67,
<span class="lineNum">     606 </span>                :            :     COLOR_BGR2HLS_FULL = 68,
<span class="lineNum">     607 </span>                :            :     COLOR_RGB2HLS_FULL = 69,
<span class="lineNum">     608 </span>                :            : 
<span class="lineNum">     609 </span>                :            :     COLOR_HSV2BGR_FULL = 70,
<span class="lineNum">     610 </span>                :            :     COLOR_HSV2RGB_FULL = 71,
<span class="lineNum">     611 </span>                :            :     COLOR_HLS2BGR_FULL = 72,
<span class="lineNum">     612 </span>                :            :     COLOR_HLS2RGB_FULL = 73,
<span class="lineNum">     613 </span>                :            : 
<span class="lineNum">     614 </span>                :            :     COLOR_LBGR2Lab     = 74,
<span class="lineNum">     615 </span>                :            :     COLOR_LRGB2Lab     = 75,
<span class="lineNum">     616 </span>                :            :     COLOR_LBGR2Luv     = 76,
<span class="lineNum">     617 </span>                :            :     COLOR_LRGB2Luv     = 77,
<span class="lineNum">     618 </span>                :            : 
<span class="lineNum">     619 </span>                :            :     COLOR_Lab2LBGR     = 78,
<span class="lineNum">     620 </span>                :            :     COLOR_Lab2LRGB     = 79,
<span class="lineNum">     621 </span>                :            :     COLOR_Luv2LBGR     = 80,
<span class="lineNum">     622 </span>                :            :     COLOR_Luv2LRGB     = 81,
<span class="lineNum">     623 </span>                :            : 
<span class="lineNum">     624 </span>                :            :     COLOR_BGR2YUV      = 82, //!&lt; convert between RGB/BGR and YUV
<span class="lineNum">     625 </span>                :            :     COLOR_RGB2YUV      = 83,
<span class="lineNum">     626 </span>                :            :     COLOR_YUV2BGR      = 84,
<span class="lineNum">     627 </span>                :            :     COLOR_YUV2RGB      = 85,
<span class="lineNum">     628 </span>                :            : 
<span class="lineNum">     629 </span>                :            :     //! YUV 4:2:0 family to RGB
<span class="lineNum">     630 </span>                :            :     COLOR_YUV2RGB_NV12  = 90,
<span class="lineNum">     631 </span>                :            :     COLOR_YUV2BGR_NV12  = 91,
<span class="lineNum">     632 </span>                :            :     COLOR_YUV2RGB_NV21  = 92,
<span class="lineNum">     633 </span>                :            :     COLOR_YUV2BGR_NV21  = 93,
<span class="lineNum">     634 </span>                :            :     COLOR_YUV420sp2RGB  = COLOR_YUV2RGB_NV21,
<span class="lineNum">     635 </span>                :            :     COLOR_YUV420sp2BGR  = COLOR_YUV2BGR_NV21,
<span class="lineNum">     636 </span>                :            : 
<span class="lineNum">     637 </span>                :            :     COLOR_YUV2RGBA_NV12 = 94,
<span class="lineNum">     638 </span>                :            :     COLOR_YUV2BGRA_NV12 = 95,
<span class="lineNum">     639 </span>                :            :     COLOR_YUV2RGBA_NV21 = 96,
<span class="lineNum">     640 </span>                :            :     COLOR_YUV2BGRA_NV21 = 97,
<span class="lineNum">     641 </span>                :            :     COLOR_YUV420sp2RGBA = COLOR_YUV2RGBA_NV21,
<span class="lineNum">     642 </span>                :            :     COLOR_YUV420sp2BGRA = COLOR_YUV2BGRA_NV21,
<span class="lineNum">     643 </span>                :            : 
<span class="lineNum">     644 </span>                :            :     COLOR_YUV2RGB_YV12  = 98,
<span class="lineNum">     645 </span>                :            :     COLOR_YUV2BGR_YV12  = 99,
<span class="lineNum">     646 </span>                :            :     COLOR_YUV2RGB_IYUV  = 100,
<span class="lineNum">     647 </span>                :            :     COLOR_YUV2BGR_IYUV  = 101,
<span class="lineNum">     648 </span>                :            :     COLOR_YUV2RGB_I420  = COLOR_YUV2RGB_IYUV,
<span class="lineNum">     649 </span>                :            :     COLOR_YUV2BGR_I420  = COLOR_YUV2BGR_IYUV,
<span class="lineNum">     650 </span>                :            :     COLOR_YUV420p2RGB   = COLOR_YUV2RGB_YV12,
<span class="lineNum">     651 </span>                :            :     COLOR_YUV420p2BGR   = COLOR_YUV2BGR_YV12,
<span class="lineNum">     652 </span>                :            : 
<span class="lineNum">     653 </span>                :            :     COLOR_YUV2RGBA_YV12 = 102,
<span class="lineNum">     654 </span>                :            :     COLOR_YUV2BGRA_YV12 = 103,
<span class="lineNum">     655 </span>                :            :     COLOR_YUV2RGBA_IYUV = 104,
<span class="lineNum">     656 </span>                :            :     COLOR_YUV2BGRA_IYUV = 105,
<span class="lineNum">     657 </span>                :            :     COLOR_YUV2RGBA_I420 = COLOR_YUV2RGBA_IYUV,
<span class="lineNum">     658 </span>                :            :     COLOR_YUV2BGRA_I420 = COLOR_YUV2BGRA_IYUV,
<span class="lineNum">     659 </span>                :            :     COLOR_YUV420p2RGBA  = COLOR_YUV2RGBA_YV12,
<span class="lineNum">     660 </span>                :            :     COLOR_YUV420p2BGRA  = COLOR_YUV2BGRA_YV12,
<span class="lineNum">     661 </span>                :            : 
<span class="lineNum">     662 </span>                :            :     COLOR_YUV2GRAY_420  = 106,
<span class="lineNum">     663 </span>                :            :     COLOR_YUV2GRAY_NV21 = COLOR_YUV2GRAY_420,
<span class="lineNum">     664 </span>                :            :     COLOR_YUV2GRAY_NV12 = COLOR_YUV2GRAY_420,
<span class="lineNum">     665 </span>                :            :     COLOR_YUV2GRAY_YV12 = COLOR_YUV2GRAY_420,
<span class="lineNum">     666 </span>                :            :     COLOR_YUV2GRAY_IYUV = COLOR_YUV2GRAY_420,
<span class="lineNum">     667 </span>                :            :     COLOR_YUV2GRAY_I420 = COLOR_YUV2GRAY_420,
<span class="lineNum">     668 </span>                :            :     COLOR_YUV420sp2GRAY = COLOR_YUV2GRAY_420,
<span class="lineNum">     669 </span>                :            :     COLOR_YUV420p2GRAY  = COLOR_YUV2GRAY_420,
<span class="lineNum">     670 </span>                :            : 
<span class="lineNum">     671 </span>                :            :     //! YUV 4:2:2 family to RGB
<span class="lineNum">     672 </span>                :            :     COLOR_YUV2RGB_UYVY = 107,
<span class="lineNum">     673 </span>                :            :     COLOR_YUV2BGR_UYVY = 108,
<span class="lineNum">     674 </span>                :            :     //COLOR_YUV2RGB_VYUY = 109,
<span class="lineNum">     675 </span>                :            :     //COLOR_YUV2BGR_VYUY = 110,
<span class="lineNum">     676 </span>                :            :     COLOR_YUV2RGB_Y422 = COLOR_YUV2RGB_UYVY,
<span class="lineNum">     677 </span>                :            :     COLOR_YUV2BGR_Y422 = COLOR_YUV2BGR_UYVY,
<span class="lineNum">     678 </span>                :            :     COLOR_YUV2RGB_UYNV = COLOR_YUV2RGB_UYVY,
<span class="lineNum">     679 </span>                :            :     COLOR_YUV2BGR_UYNV = COLOR_YUV2BGR_UYVY,
<span class="lineNum">     680 </span>                :            : 
<span class="lineNum">     681 </span>                :            :     COLOR_YUV2RGBA_UYVY = 111,
<span class="lineNum">     682 </span>                :            :     COLOR_YUV2BGRA_UYVY = 112,
<span class="lineNum">     683 </span>                :            :     //COLOR_YUV2RGBA_VYUY = 113,
<span class="lineNum">     684 </span>                :            :     //COLOR_YUV2BGRA_VYUY = 114,
<span class="lineNum">     685 </span>                :            :     COLOR_YUV2RGBA_Y422 = COLOR_YUV2RGBA_UYVY,
<span class="lineNum">     686 </span>                :            :     COLOR_YUV2BGRA_Y422 = COLOR_YUV2BGRA_UYVY,
<span class="lineNum">     687 </span>                :            :     COLOR_YUV2RGBA_UYNV = COLOR_YUV2RGBA_UYVY,
<span class="lineNum">     688 </span>                :            :     COLOR_YUV2BGRA_UYNV = COLOR_YUV2BGRA_UYVY,
<span class="lineNum">     689 </span>                :            : 
<span class="lineNum">     690 </span>                :            :     COLOR_YUV2RGB_YUY2 = 115,
<span class="lineNum">     691 </span>                :            :     COLOR_YUV2BGR_YUY2 = 116,
<span class="lineNum">     692 </span>                :            :     COLOR_YUV2RGB_YVYU = 117,
<span class="lineNum">     693 </span>                :            :     COLOR_YUV2BGR_YVYU = 118,
<span class="lineNum">     694 </span>                :            :     COLOR_YUV2RGB_YUYV = COLOR_YUV2RGB_YUY2,
<span class="lineNum">     695 </span>                :            :     COLOR_YUV2BGR_YUYV = COLOR_YUV2BGR_YUY2,
<span class="lineNum">     696 </span>                :            :     COLOR_YUV2RGB_YUNV = COLOR_YUV2RGB_YUY2,
<span class="lineNum">     697 </span>                :            :     COLOR_YUV2BGR_YUNV = COLOR_YUV2BGR_YUY2,
<span class="lineNum">     698 </span>                :            : 
<span class="lineNum">     699 </span>                :            :     COLOR_YUV2RGBA_YUY2 = 119,
<span class="lineNum">     700 </span>                :            :     COLOR_YUV2BGRA_YUY2 = 120,
<span class="lineNum">     701 </span>                :            :     COLOR_YUV2RGBA_YVYU = 121,
<span class="lineNum">     702 </span>                :            :     COLOR_YUV2BGRA_YVYU = 122,
<span class="lineNum">     703 </span>                :            :     COLOR_YUV2RGBA_YUYV = COLOR_YUV2RGBA_YUY2,
<span class="lineNum">     704 </span>                :            :     COLOR_YUV2BGRA_YUYV = COLOR_YUV2BGRA_YUY2,
<span class="lineNum">     705 </span>                :            :     COLOR_YUV2RGBA_YUNV = COLOR_YUV2RGBA_YUY2,
<span class="lineNum">     706 </span>                :            :     COLOR_YUV2BGRA_YUNV = COLOR_YUV2BGRA_YUY2,
<span class="lineNum">     707 </span>                :            : 
<span class="lineNum">     708 </span>                :            :     COLOR_YUV2GRAY_UYVY = 123,
<span class="lineNum">     709 </span>                :            :     COLOR_YUV2GRAY_YUY2 = 124,
<span class="lineNum">     710 </span>                :            :     //CV_YUV2GRAY_VYUY    = CV_YUV2GRAY_UYVY,
<span class="lineNum">     711 </span>                :            :     COLOR_YUV2GRAY_Y422 = COLOR_YUV2GRAY_UYVY,
<span class="lineNum">     712 </span>                :            :     COLOR_YUV2GRAY_UYNV = COLOR_YUV2GRAY_UYVY,
<span class="lineNum">     713 </span>                :            :     COLOR_YUV2GRAY_YVYU = COLOR_YUV2GRAY_YUY2,
<span class="lineNum">     714 </span>                :            :     COLOR_YUV2GRAY_YUYV = COLOR_YUV2GRAY_YUY2,
<span class="lineNum">     715 </span>                :            :     COLOR_YUV2GRAY_YUNV = COLOR_YUV2GRAY_YUY2,
<span class="lineNum">     716 </span>                :            : 
<span class="lineNum">     717 </span>                :            :     //! alpha premultiplication
<span class="lineNum">     718 </span>                :            :     COLOR_RGBA2mRGBA    = 125,
<span class="lineNum">     719 </span>                :            :     COLOR_mRGBA2RGBA    = 126,
<span class="lineNum">     720 </span>                :            : 
<span class="lineNum">     721 </span>                :            :     //! RGB to YUV 4:2:0 family
<span class="lineNum">     722 </span>                :            :     COLOR_RGB2YUV_I420  = 127,
<span class="lineNum">     723 </span>                :            :     COLOR_BGR2YUV_I420  = 128,
<span class="lineNum">     724 </span>                :            :     COLOR_RGB2YUV_IYUV  = COLOR_RGB2YUV_I420,
<span class="lineNum">     725 </span>                :            :     COLOR_BGR2YUV_IYUV  = COLOR_BGR2YUV_I420,
<span class="lineNum">     726 </span>                :            : 
<span class="lineNum">     727 </span>                :            :     COLOR_RGBA2YUV_I420 = 129,
<span class="lineNum">     728 </span>                :            :     COLOR_BGRA2YUV_I420 = 130,
<span class="lineNum">     729 </span>                :            :     COLOR_RGBA2YUV_IYUV = COLOR_RGBA2YUV_I420,
<span class="lineNum">     730 </span>                :            :     COLOR_BGRA2YUV_IYUV = COLOR_BGRA2YUV_I420,
<span class="lineNum">     731 </span>                :            :     COLOR_RGB2YUV_YV12  = 131,
<span class="lineNum">     732 </span>                :            :     COLOR_BGR2YUV_YV12  = 132,
<span class="lineNum">     733 </span>                :            :     COLOR_RGBA2YUV_YV12 = 133,
<span class="lineNum">     734 </span>                :            :     COLOR_BGRA2YUV_YV12 = 134,
<span class="lineNum">     735 </span>                :            : 
<span class="lineNum">     736 </span>                :            :     //! Demosaicing
<span class="lineNum">     737 </span>                :            :     COLOR_BayerBG2BGR = 46,
<span class="lineNum">     738 </span>                :            :     COLOR_BayerGB2BGR = 47,
<span class="lineNum">     739 </span>                :            :     COLOR_BayerRG2BGR = 48,
<span class="lineNum">     740 </span>                :            :     COLOR_BayerGR2BGR = 49,
<span class="lineNum">     741 </span>                :            : 
<span class="lineNum">     742 </span>                :            :     COLOR_BayerBG2RGB = COLOR_BayerRG2BGR,
<span class="lineNum">     743 </span>                :            :     COLOR_BayerGB2RGB = COLOR_BayerGR2BGR,
<span class="lineNum">     744 </span>                :            :     COLOR_BayerRG2RGB = COLOR_BayerBG2BGR,
<span class="lineNum">     745 </span>                :            :     COLOR_BayerGR2RGB = COLOR_BayerGB2BGR,
<span class="lineNum">     746 </span>                :            : 
<span class="lineNum">     747 </span>                :            :     COLOR_BayerBG2GRAY = 86,
<span class="lineNum">     748 </span>                :            :     COLOR_BayerGB2GRAY = 87,
<span class="lineNum">     749 </span>                :            :     COLOR_BayerRG2GRAY = 88,
<span class="lineNum">     750 </span>                :            :     COLOR_BayerGR2GRAY = 89,
<span class="lineNum">     751 </span>                :            : 
<span class="lineNum">     752 </span>                :            :     //! Demosaicing using Variable Number of Gradients
<span class="lineNum">     753 </span>                :            :     COLOR_BayerBG2BGR_VNG = 62,
<span class="lineNum">     754 </span>                :            :     COLOR_BayerGB2BGR_VNG = 63,
<span class="lineNum">     755 </span>                :            :     COLOR_BayerRG2BGR_VNG = 64,
<span class="lineNum">     756 </span>                :            :     COLOR_BayerGR2BGR_VNG = 65,
<span class="lineNum">     757 </span>                :            : 
<span class="lineNum">     758 </span>                :            :     COLOR_BayerBG2RGB_VNG = COLOR_BayerRG2BGR_VNG,
<span class="lineNum">     759 </span>                :            :     COLOR_BayerGB2RGB_VNG = COLOR_BayerGR2BGR_VNG,
<span class="lineNum">     760 </span>                :            :     COLOR_BayerRG2RGB_VNG = COLOR_BayerBG2BGR_VNG,
<span class="lineNum">     761 </span>                :            :     COLOR_BayerGR2RGB_VNG = COLOR_BayerGB2BGR_VNG,
<span class="lineNum">     762 </span>                :            : 
<span class="lineNum">     763 </span>                :            :     //! Edge-Aware Demosaicing
<span class="lineNum">     764 </span>                :            :     COLOR_BayerBG2BGR_EA  = 135,
<span class="lineNum">     765 </span>                :            :     COLOR_BayerGB2BGR_EA  = 136,
<span class="lineNum">     766 </span>                :            :     COLOR_BayerRG2BGR_EA  = 137,
<span class="lineNum">     767 </span>                :            :     COLOR_BayerGR2BGR_EA  = 138,
<span class="lineNum">     768 </span>                :            : 
<span class="lineNum">     769 </span>                :            :     COLOR_BayerBG2RGB_EA  = COLOR_BayerRG2BGR_EA,
<span class="lineNum">     770 </span>                :            :     COLOR_BayerGB2RGB_EA  = COLOR_BayerGR2BGR_EA,
<span class="lineNum">     771 </span>                :            :     COLOR_BayerRG2RGB_EA  = COLOR_BayerBG2BGR_EA,
<span class="lineNum">     772 </span>                :            :     COLOR_BayerGR2RGB_EA  = COLOR_BayerGB2BGR_EA,
<span class="lineNum">     773 </span>                :            : 
<span class="lineNum">     774 </span>                :            :     //! Demosaicing with alpha channel
<span class="lineNum">     775 </span>                :            :     COLOR_BayerBG2BGRA = 139,
<span class="lineNum">     776 </span>                :            :     COLOR_BayerGB2BGRA = 140,
<span class="lineNum">     777 </span>                :            :     COLOR_BayerRG2BGRA = 141,
<span class="lineNum">     778 </span>                :            :     COLOR_BayerGR2BGRA = 142,
<span class="lineNum">     779 </span>                :            : 
<span class="lineNum">     780 </span>                :            :     COLOR_BayerBG2RGBA = COLOR_BayerRG2BGRA,
<span class="lineNum">     781 </span>                :            :     COLOR_BayerGB2RGBA = COLOR_BayerGR2BGRA,
<span class="lineNum">     782 </span>                :            :     COLOR_BayerRG2RGBA = COLOR_BayerBG2BGRA,
<span class="lineNum">     783 </span>                :            :     COLOR_BayerGR2RGBA = COLOR_BayerGB2BGRA,
<span class="lineNum">     784 </span>                :            : 
<span class="lineNum">     785 </span>                :            :     COLOR_COLORCVT_MAX  = 143
<span class="lineNum">     786 </span>                :            : };
<span class="lineNum">     787 </span>                :            : 
<span class="lineNum">     788 </span>                :            : //! @addtogroup imgproc_shape
<span class="lineNum">     789 </span>                :            : //! @{
<span class="lineNum">     790 </span>                :            : 
<span class="lineNum">     791 </span>                :            : //! types of intersection between rectangles
<span class="lineNum">     792 </span>                :            : enum RectanglesIntersectTypes {
<span class="lineNum">     793 </span>                :            :     INTERSECT_NONE = 0, //!&lt; No intersection
<span class="lineNum">     794 </span>                :            :     INTERSECT_PARTIAL  = 1, //!&lt; There is a partial intersection
<span class="lineNum">     795 </span>                :            :     INTERSECT_FULL  = 2 //!&lt; One of the rectangle is fully enclosed in the other
<span class="lineNum">     796 </span>                :            : };
<span class="lineNum">     797 </span>                :            : 
<span class="lineNum">     798 </span>                :            : /** types of line
<span class="lineNum">     799 </span>                :            : @ingroup imgproc_draw
<span class="lineNum">     800 </span>                :            : */
<span class="lineNum">     801 </span>                :            : enum LineTypes {
<span class="lineNum">     802 </span>                :            :     FILLED  = -1,
<span class="lineNum">     803 </span>                :            :     LINE_4  = 4, //!&lt; 4-connected line
<span class="lineNum">     804 </span>                :            :     LINE_8  = 8, //!&lt; 8-connected line
<span class="lineNum">     805 </span>                :            :     LINE_AA = 16 //!&lt; antialiased line
<span class="lineNum">     806 </span>                :            : };
<span class="lineNum">     807 </span>                :            : 
<span class="lineNum">     808 </span>                :            : /** Only a subset of Hershey fonts &lt;https://en.wikipedia.org/wiki/Hershey_fonts&gt; are supported
<span class="lineNum">     809 </span>                :            : @ingroup imgproc_draw
<span class="lineNum">     810 </span>                :            : */
<span class="lineNum">     811 </span>                :            : enum HersheyFonts {
<span class="lineNum">     812 </span>                :            :     FONT_HERSHEY_SIMPLEX        = 0, //!&lt; normal size sans-serif font
<span class="lineNum">     813 </span>                :            :     FONT_HERSHEY_PLAIN          = 1, //!&lt; small size sans-serif font
<span class="lineNum">     814 </span>                :            :     FONT_HERSHEY_DUPLEX         = 2, //!&lt; normal size sans-serif font (more complex than FONT_HERSHEY_SIMPLEX)
<span class="lineNum">     815 </span>                :            :     FONT_HERSHEY_COMPLEX        = 3, //!&lt; normal size serif font
<span class="lineNum">     816 </span>                :            :     FONT_HERSHEY_TRIPLEX        = 4, //!&lt; normal size serif font (more complex than FONT_HERSHEY_COMPLEX)
<span class="lineNum">     817 </span>                :            :     FONT_HERSHEY_COMPLEX_SMALL  = 5, //!&lt; smaller version of FONT_HERSHEY_COMPLEX
<span class="lineNum">     818 </span>                :            :     FONT_HERSHEY_SCRIPT_SIMPLEX = 6, //!&lt; hand-writing style font
<span class="lineNum">     819 </span>                :            :     FONT_HERSHEY_SCRIPT_COMPLEX = 7, //!&lt; more complex variant of FONT_HERSHEY_SCRIPT_SIMPLEX
<span class="lineNum">     820 </span>                :            :     FONT_ITALIC                 = 16 //!&lt; flag for italic font
<span class="lineNum">     821 </span>                :            : };
<span class="lineNum">     822 </span>                :            : 
<span class="lineNum">     823 </span>                :            : /** Possible set of marker types used for the cv::drawMarker function
<span class="lineNum">     824 </span>                :            : @ingroup imgproc_draw
<span class="lineNum">     825 </span>                :            : */
<span class="lineNum">     826 </span>                :            : enum MarkerTypes
<span class="lineNum">     827 </span>                :            : {
<span class="lineNum">     828 </span>                :            :     MARKER_CROSS = 0,           //!&lt; A crosshair marker shape
<span class="lineNum">     829 </span>                :            :     MARKER_TILTED_CROSS = 1,    //!&lt; A 45 degree tilted crosshair marker shape
<span class="lineNum">     830 </span>                :            :     MARKER_STAR = 2,            //!&lt; A star marker shape, combination of cross and tilted cross
<span class="lineNum">     831 </span>                :            :     MARKER_DIAMOND = 3,         //!&lt; A diamond marker shape
<span class="lineNum">     832 </span>                :            :     MARKER_SQUARE = 4,          //!&lt; A square marker shape
<span class="lineNum">     833 </span>                :            :     MARKER_TRIANGLE_UP = 5,     //!&lt; An upwards pointing triangle marker shape
<span class="lineNum">     834 </span>                :            :     MARKER_TRIANGLE_DOWN = 6    //!&lt; A downwards pointing triangle marker shape
<span class="lineNum">     835 </span>                :            : };
<span class="lineNum">     836 </span>                :            : 
<span class="lineNum">     837 </span>                :            : /** @brief finds arbitrary template in the grayscale image using Generalized Hough Transform
<span class="lineNum">     838 </span>                :            : */
<span class="lineNum">     839 </span>                :            : class CV_EXPORTS_W GeneralizedHough : public Algorithm
<span class="lineNum">     840 </span>                :            : {
<span class="lineNum">     841 </span>                :            : public:
<span class="lineNum">     842 </span>                :            :     //! set template to search
<span class="lineNum">     843 </span>                :            :     CV_WRAP virtual void setTemplate(InputArray templ, Point templCenter = Point(-1, -1)) = 0;
<span class="lineNum">     844 </span>                :            :     CV_WRAP virtual void setTemplate(InputArray edges, InputArray dx, InputArray dy, Point templCenter = Point(-1, -1)) = 0;
<span class="lineNum">     845 </span>                :            : 
<span class="lineNum">     846 </span>                :            :     //! find template on image
<span class="lineNum">     847 </span>                :            :     CV_WRAP virtual void detect(InputArray image, OutputArray positions, OutputArray votes = noArray()) = 0;
<span class="lineNum">     848 </span>                :            :     CV_WRAP virtual void detect(InputArray edges, InputArray dx, InputArray dy, OutputArray positions, OutputArray votes = noArray()) = 0;
<span class="lineNum">     849 </span>                :            : 
<span class="lineNum">     850 </span>                :            :     //! Canny low threshold.
<span class="lineNum">     851 </span>                :            :     CV_WRAP virtual void setCannyLowThresh(int cannyLowThresh) = 0;
<span class="lineNum">     852 </span>                :            :     CV_WRAP virtual int getCannyLowThresh() const = 0;
<span class="lineNum">     853 </span>                :            : 
<span class="lineNum">     854 </span>                :            :     //! Canny high threshold.
<span class="lineNum">     855 </span>                :            :     CV_WRAP virtual void setCannyHighThresh(int cannyHighThresh) = 0;
<span class="lineNum">     856 </span>                :            :     CV_WRAP virtual int getCannyHighThresh() const = 0;
<span class="lineNum">     857 </span>                :            : 
<span class="lineNum">     858 </span>                :            :     //! Minimum distance between the centers of the detected objects.
<span class="lineNum">     859 </span>                :            :     CV_WRAP virtual void setMinDist(double minDist) = 0;
<span class="lineNum">     860 </span>                :            :     CV_WRAP virtual double getMinDist() const = 0;
<span class="lineNum">     861 </span>                :            : 
<span class="lineNum">     862 </span>                :            :     //! Inverse ratio of the accumulator resolution to the image resolution.
<span class="lineNum">     863 </span>                :            :     CV_WRAP virtual void setDp(double dp) = 0;
<span class="lineNum">     864 </span>                :            :     CV_WRAP virtual double getDp() const = 0;
<span class="lineNum">     865 </span>                :            : 
<span class="lineNum">     866 </span>                :            :     //! Maximal size of inner buffers.
<span class="lineNum">     867 </span>                :            :     CV_WRAP virtual void setMaxBufferSize(int maxBufferSize) = 0;
<span class="lineNum">     868 </span>                :            :     CV_WRAP virtual int getMaxBufferSize() const = 0;
<span class="lineNum">     869 </span>                :            : };
<span class="lineNum">     870 </span>                :            : 
<span class="lineNum">     871 </span>                :            : /** @brief finds arbitrary template in the grayscale image using Generalized Hough Transform
<span class="lineNum">     872 </span>                :            : 
<span class="lineNum">     873 </span>                :            : Detects position only without translation and rotation @cite Ballard1981 .
<span class="lineNum">     874 </span>                :            : */
<span class="lineNum">     875 </span>                :            : class CV_EXPORTS_W GeneralizedHoughBallard : public GeneralizedHough
<span class="lineNum">     876 </span>                :            : {
<span class="lineNum">     877 </span>                :            : public:
<span class="lineNum">     878 </span>                :            :     //! R-Table levels.
<span class="lineNum">     879 </span>                :            :     CV_WRAP virtual void setLevels(int levels) = 0;
<span class="lineNum">     880 </span>                :            :     CV_WRAP virtual int getLevels() const = 0;
<span class="lineNum">     881 </span>                :            : 
<span class="lineNum">     882 </span>                :            :     //! The accumulator threshold for the template centers at the detection stage. The smaller it is, the more false positions may be detected.
<span class="lineNum">     883 </span>                :            :     CV_WRAP virtual void setVotesThreshold(int votesThreshold) = 0;
<span class="lineNum">     884 </span>                :            :     CV_WRAP virtual int getVotesThreshold() const = 0;
<span class="lineNum">     885 </span>                :            : };
<span class="lineNum">     886 </span>                :            : 
<span class="lineNum">     887 </span>                :            : /** @brief finds arbitrary template in the grayscale image using Generalized Hough Transform
<span class="lineNum">     888 </span>                :            : 
<span class="lineNum">     889 </span>                :            : Detects position, translation and rotation @cite Guil1999 .
<span class="lineNum">     890 </span>                :            : */
<span class="lineNum">     891 </span>                :            : class CV_EXPORTS_W GeneralizedHoughGuil : public GeneralizedHough
<span class="lineNum">     892 </span>                :            : {
<span class="lineNum">     893 </span>                :            : public:
<span class="lineNum">     894 </span>                :            :     //! Angle difference in degrees between two points in feature.
<span class="lineNum">     895 </span>                :            :     virtual void setXi(double xi) = 0;
<span class="lineNum">     896 </span>                :            :     virtual double getXi() const = 0;
<span class="lineNum">     897 </span>                :            : 
<span class="lineNum">     898 </span>                :            :     //! Feature table levels.
<span class="lineNum">     899 </span>                :            :     virtual void setLevels(int levels) = 0;
<span class="lineNum">     900 </span>                :            :     virtual int getLevels() const = 0;
<span class="lineNum">     901 </span>                :            : 
<span class="lineNum">     902 </span>                :            :     //! Maximal difference between angles that treated as equal.
<span class="lineNum">     903 </span>                :            :     virtual void setAngleEpsilon(double angleEpsilon) = 0;
<span class="lineNum">     904 </span>                :            :     virtual double getAngleEpsilon() const = 0;
<span class="lineNum">     905 </span>                :            : 
<span class="lineNum">     906 </span>                :            :     //! Minimal rotation angle to detect in degrees.
<span class="lineNum">     907 </span>                :            :     virtual void setMinAngle(double minAngle) = 0;
<span class="lineNum">     908 </span>                :            :     virtual double getMinAngle() const = 0;
<span class="lineNum">     909 </span>                :            : 
<span class="lineNum">     910 </span>                :            :     //! Maximal rotation angle to detect in degrees.
<span class="lineNum">     911 </span>                :            :     virtual void setMaxAngle(double maxAngle) = 0;
<span class="lineNum">     912 </span>                :            :     virtual double getMaxAngle() const = 0;
<span class="lineNum">     913 </span>                :            : 
<span class="lineNum">     914 </span>                :            :     //! Angle step in degrees.
<span class="lineNum">     915 </span>                :            :     virtual void setAngleStep(double angleStep) = 0;
<span class="lineNum">     916 </span>                :            :     virtual double getAngleStep() const = 0;
<span class="lineNum">     917 </span>                :            : 
<span class="lineNum">     918 </span>                :            :     //! Angle votes threshold.
<span class="lineNum">     919 </span>                :            :     virtual void setAngleThresh(int angleThresh) = 0;
<span class="lineNum">     920 </span>                :            :     virtual int getAngleThresh() const = 0;
<span class="lineNum">     921 </span>                :            : 
<span class="lineNum">     922 </span>                :            :     //! Minimal scale to detect.
<span class="lineNum">     923 </span>                :            :     virtual void setMinScale(double minScale) = 0;
<span class="lineNum">     924 </span>                :            :     virtual double getMinScale() const = 0;
<span class="lineNum">     925 </span>                :            : 
<span class="lineNum">     926 </span>                :            :     //! Maximal scale to detect.
<span class="lineNum">     927 </span>                :            :     virtual void setMaxScale(double maxScale) = 0;
<span class="lineNum">     928 </span>                :            :     virtual double getMaxScale() const = 0;
<span class="lineNum">     929 </span>                :            : 
<span class="lineNum">     930 </span>                :            :     //! Scale step.
<span class="lineNum">     931 </span>                :            :     virtual void setScaleStep(double scaleStep) = 0;
<span class="lineNum">     932 </span>                :            :     virtual double getScaleStep() const = 0;
<span class="lineNum">     933 </span>                :            : 
<span class="lineNum">     934 </span>                :            :     //! Scale votes threshold.
<span class="lineNum">     935 </span>                :            :     virtual void setScaleThresh(int scaleThresh) = 0;
<span class="lineNum">     936 </span>                :            :     virtual int getScaleThresh() const = 0;
<span class="lineNum">     937 </span>                :            : 
<span class="lineNum">     938 </span>                :            :     //! Position votes threshold.
<span class="lineNum">     939 </span>                :            :     virtual void setPosThresh(int posThresh) = 0;
<span class="lineNum">     940 </span>                :            :     virtual int getPosThresh() const = 0;
<span class="lineNum">     941 </span>                :            : };
<span class="lineNum">     942 </span>                :            : 
<span class="lineNum">     943 </span>                :            : //! @} imgproc_shape
<span class="lineNum">     944 </span>                :            : 
<span class="lineNum">     945 </span>                :            : //! @addtogroup imgproc_hist
<span class="lineNum">     946 </span>                :            : //! @{
<span class="lineNum">     947 </span>                :            : 
<span class="lineNum">     948 </span>                :            : /** @brief Base class for Contrast Limited Adaptive Histogram Equalization.
<span class="lineNum">     949 </span>                :            : */
<span class="lineNum">     950 </span>                :            : class CV_EXPORTS_W CLAHE : public Algorithm
<span class="lineNum">     951 </span>                :            : {
<span class="lineNum">     952 </span>                :            : public:
<span class="lineNum">     953 </span>                :            :     /** @brief Equalizes the histogram of a grayscale image using Contrast Limited Adaptive Histogram Equalization.
<span class="lineNum">     954 </span>                :            : 
<span class="lineNum">     955 </span>                :            :     @param src Source image of type CV_8UC1 or CV_16UC1.
<span class="lineNum">     956 </span>                :            :     @param dst Destination image.
<span class="lineNum">     957 </span>                :            :      */
<span class="lineNum">     958 </span>                :            :     CV_WRAP virtual void apply(InputArray src, OutputArray dst) = 0;
<span class="lineNum">     959 </span>                :            : 
<span class="lineNum">     960 </span>                :            :     /** @brief Sets threshold for contrast limiting.
<span class="lineNum">     961 </span>                :            : 
<span class="lineNum">     962 </span>                :            :     @param clipLimit threshold value.
<span class="lineNum">     963 </span>                :            :     */
<span class="lineNum">     964 </span>                :            :     CV_WRAP virtual void setClipLimit(double clipLimit) = 0;
<span class="lineNum">     965 </span>                :            : 
<span class="lineNum">     966 </span>                :            :     //! Returns threshold value for contrast limiting.
<span class="lineNum">     967 </span>                :            :     CV_WRAP virtual double getClipLimit() const = 0;
<span class="lineNum">     968 </span>                :            : 
<span class="lineNum">     969 </span>                :            :     /** @brief Sets size of grid for histogram equalization. Input image will be divided into
<span class="lineNum">     970 </span>                :            :     equally sized rectangular tiles.
<span class="lineNum">     971 </span>                :            : 
<span class="lineNum">     972 </span>                :            :     @param tileGridSize defines the number of tiles in row and column.
<span class="lineNum">     973 </span>                :            :     */
<span class="lineNum">     974 </span>                :            :     CV_WRAP virtual void setTilesGridSize(Size tileGridSize) = 0;
<span class="lineNum">     975 </span>                :            : 
<span class="lineNum">     976 </span>                :            :     //!@brief Returns Size defines the number of tiles in row and column.
<span class="lineNum">     977 </span>                :            :     CV_WRAP virtual Size getTilesGridSize() const = 0;
<span class="lineNum">     978 </span>                :            : 
<span class="lineNum">     979 </span>                :            :     CV_WRAP virtual void collectGarbage() = 0;
<span class="lineNum">     980 </span>                :            : };
<span class="lineNum">     981 </span>                :            : 
<span class="lineNum">     982 </span>                :            : //! @} imgproc_hist
<span class="lineNum">     983 </span>                :            : 
<span class="lineNum">     984 </span>                :            : //! @addtogroup imgproc_subdiv2d
<span class="lineNum">     985 </span>                :            : //! @{
<span class="lineNum">     986 </span>                :            : 
<span class="lineNum">     987 </span>                :            : class CV_EXPORTS_W Subdiv2D
<span class="lineNum">     988 </span>                :            : {
<span class="lineNum">     989 </span>                :            : public:
<span class="lineNum">     990 </span>                :            :     /** Subdiv2D point location cases */
<span class="lineNum">     991 </span>                :            :     enum { PTLOC_ERROR        = -2, //!&lt; Point location error
<span class="lineNum">     992 </span>                :            :            PTLOC_OUTSIDE_RECT = -1, //!&lt; Point outside the subdivision bounding rect
<span class="lineNum">     993 </span>                :            :            PTLOC_INSIDE       = 0, //!&lt; Point inside some facet
<span class="lineNum">     994 </span>                :            :            PTLOC_VERTEX       = 1, //!&lt; Point coincides with one of the subdivision vertices
<span class="lineNum">     995 </span>                :            :            PTLOC_ON_EDGE      = 2  //!&lt; Point on some edge
<span class="lineNum">     996 </span>                :            :          };
<span class="lineNum">     997 </span>                :            : 
<span class="lineNum">     998 </span>                :            :     /** Subdiv2D edge type navigation (see: getEdge()) */
<span class="lineNum">     999 </span>                :            :     enum { NEXT_AROUND_ORG   = 0x00,
<span class="lineNum">    1000 </span>                :            :            NEXT_AROUND_DST   = 0x22,
<span class="lineNum">    1001 </span>                :            :            PREV_AROUND_ORG   = 0x11,
<span class="lineNum">    1002 </span>                :            :            PREV_AROUND_DST   = 0x33,
<span class="lineNum">    1003 </span>                :            :            NEXT_AROUND_LEFT  = 0x13,
<span class="lineNum">    1004 </span>                :            :            NEXT_AROUND_RIGHT = 0x31,
<span class="lineNum">    1005 </span>                :            :            PREV_AROUND_LEFT  = 0x20,
<span class="lineNum">    1006 </span>                :            :            PREV_AROUND_RIGHT = 0x02
<span class="lineNum">    1007 </span>                :            :          };
<span class="lineNum">    1008 </span>                :            : 
<span class="lineNum">    1009 </span>                :            :     /** creates an empty Subdiv2D object.
<span class="lineNum">    1010 </span>                :            :     To create a new empty Delaunay subdivision you need to use the #initDelaunay function.
<span class="lineNum">    1011 </span>                :            :      */
<span class="lineNum">    1012 </span>                :            :     CV_WRAP Subdiv2D();
<span class="lineNum">    1013 </span>                :            : 
<span class="lineNum">    1014 </span>                :            :     /** @overload
<span class="lineNum">    1015 </span>                :            : 
<span class="lineNum">    1016 </span>                :            :     @param rect Rectangle that includes all of the 2D points that are to be added to the subdivision.
<span class="lineNum">    1017 </span>                :            : 
<span class="lineNum">    1018 </span>                :            :     The function creates an empty Delaunay subdivision where 2D points can be added using the function
<span class="lineNum">    1019 </span>                :            :     insert() . All of the points to be added must be within the specified rectangle, otherwise a runtime
<span class="lineNum">    1020 </span>                :            :     error is raised.
<span class="lineNum">    1021 </span>                :            :      */
<span class="lineNum">    1022 </span>                :            :     CV_WRAP Subdiv2D(Rect rect);
<span class="lineNum">    1023 </span>                :            : 
<span class="lineNum">    1024 </span>                :            :     /** @brief Creates a new empty Delaunay subdivision
<span class="lineNum">    1025 </span>                :            : 
<span class="lineNum">    1026 </span>                :            :     @param rect Rectangle that includes all of the 2D points that are to be added to the subdivision.
<span class="lineNum">    1027 </span>                :            : 
<span class="lineNum">    1028 </span>                :            :      */
<span class="lineNum">    1029 </span>                :            :     CV_WRAP void initDelaunay(Rect rect);
<span class="lineNum">    1030 </span>                :            : 
<span class="lineNum">    1031 </span>                :            :     /** @brief Insert a single point into a Delaunay triangulation.
<span class="lineNum">    1032 </span>                :            : 
<span class="lineNum">    1033 </span>                :            :     @param pt Point to insert.
<span class="lineNum">    1034 </span>                :            : 
<span class="lineNum">    1035 </span>                :            :     The function inserts a single point into a subdivision and modifies the subdivision topology
<span class="lineNum">    1036 </span>                :            :     appropriately. If a point with the same coordinates exists already, no new point is added.
<span class="lineNum">    1037 </span>                :            :     @returns the ID of the point.
<span class="lineNum">    1038 </span>                :            : 
<span class="lineNum">    1039 </span>                :            :     @note If the point is outside of the triangulation specified rect a runtime error is raised.
<span class="lineNum">    1040 </span>                :            :      */
<span class="lineNum">    1041 </span>                :            :     CV_WRAP int insert(Point2f pt);
<span class="lineNum">    1042 </span>                :            : 
<span class="lineNum">    1043 </span>                :            :     /** @brief Insert multiple points into a Delaunay triangulation.
<span class="lineNum">    1044 </span>                :            : 
<span class="lineNum">    1045 </span>                :            :     @param ptvec Points to insert.
<span class="lineNum">    1046 </span>                :            : 
<span class="lineNum">    1047 </span>                :            :     The function inserts a vector of points into a subdivision and modifies the subdivision topology
<span class="lineNum">    1048 </span>                :            :     appropriately.
<span class="lineNum">    1049 </span>                :            :      */
<span class="lineNum">    1050 </span>                :            :     CV_WRAP void insert(const std::vector&lt;Point2f&gt;&amp; ptvec);
<span class="lineNum">    1051 </span>                :            : 
<span class="lineNum">    1052 </span>                :            :     /** @brief Returns the location of a point within a Delaunay triangulation.
<span class="lineNum">    1053 </span>                :            : 
<span class="lineNum">    1054 </span>                :            :     @param pt Point to locate.
<span class="lineNum">    1055 </span>                :            :     @param edge Output edge that the point belongs to or is located to the right of it.
<span class="lineNum">    1056 </span>                :            :     @param vertex Optional output vertex the input point coincides with.
<span class="lineNum">    1057 </span>                :            : 
<span class="lineNum">    1058 </span>                :            :     The function locates the input point within the subdivision and gives one of the triangle edges
<span class="lineNum">    1059 </span>                :            :     or vertices.
<span class="lineNum">    1060 </span>                :            : 
<span class="lineNum">    1061 </span>                :            :     @returns an integer which specify one of the following five cases for point location:
<span class="lineNum">    1062 </span>                :            :     -  The point falls into some facet. The function returns #PTLOC_INSIDE and edge will contain one of
<span class="lineNum">    1063 </span>                :            :        edges of the facet.
<span class="lineNum">    1064 </span>                :            :     -  The point falls onto the edge. The function returns #PTLOC_ON_EDGE and edge will contain this edge.
<span class="lineNum">    1065 </span>                :            :     -  The point coincides with one of the subdivision vertices. The function returns #PTLOC_VERTEX and
<span class="lineNum">    1066 </span>                :            :        vertex will contain a pointer to the vertex.
<span class="lineNum">    1067 </span>                :            :     -  The point is outside the subdivision reference rectangle. The function returns #PTLOC_OUTSIDE_RECT
<span class="lineNum">    1068 </span>                :            :        and no pointers are filled.
<span class="lineNum">    1069 </span>                :            :     -  One of input arguments is invalid. A runtime error is raised or, if silent or &quot;parent&quot; error
<span class="lineNum">    1070 </span>                :            :        processing mode is selected, #PTLOC_ERROR is returned.
<span class="lineNum">    1071 </span>                :            :      */
<span class="lineNum">    1072 </span>                :            :     CV_WRAP int locate(Point2f pt, CV_OUT int&amp; edge, CV_OUT int&amp; vertex);
<span class="lineNum">    1073 </span>                :            : 
<span class="lineNum">    1074 </span>                :            :     /** @brief Finds the subdivision vertex closest to the given point.
<span class="lineNum">    1075 </span>                :            : 
<span class="lineNum">    1076 </span>                :            :     @param pt Input point.
<span class="lineNum">    1077 </span>                :            :     @param nearestPt Output subdivision vertex point.
<span class="lineNum">    1078 </span>                :            : 
<span class="lineNum">    1079 </span>                :            :     The function is another function that locates the input point within the subdivision. It finds the
<span class="lineNum">    1080 </span>                :            :     subdivision vertex that is the closest to the input point. It is not necessarily one of vertices
<span class="lineNum">    1081 </span>                :            :     of the facet containing the input point, though the facet (located using locate() ) is used as a
<span class="lineNum">    1082 </span>                :            :     starting point.
<span class="lineNum">    1083 </span>                :            : 
<span class="lineNum">    1084 </span>                :            :     @returns vertex ID.
<span class="lineNum">    1085 </span>                :            :      */
<span class="lineNum">    1086 </span>                :            :     CV_WRAP int findNearest(Point2f pt, CV_OUT Point2f* nearestPt = 0);
<span class="lineNum">    1087 </span>                :            : 
<span class="lineNum">    1088 </span>                :            :     /** @brief Returns a list of all edges.
<span class="lineNum">    1089 </span>                :            : 
<span class="lineNum">    1090 </span>                :            :     @param edgeList Output vector.
<span class="lineNum">    1091 </span>                :            : 
<span class="lineNum">    1092 </span>                :            :     The function gives each edge as a 4 numbers vector, where each two are one of the edge
<span class="lineNum">    1093 </span>                :            :     vertices. i.e. org_x = v[0], org_y = v[1], dst_x = v[2], dst_y = v[3].
<span class="lineNum">    1094 </span>                :            :      */
<span class="lineNum">    1095 </span>                :            :     CV_WRAP void getEdgeList(CV_OUT std::vector&lt;Vec4f&gt;&amp; edgeList) const;
<span class="lineNum">    1096 </span>                :            : 
<span class="lineNum">    1097 </span>                :            :     /** @brief Returns a list of the leading edge ID connected to each triangle.
<span class="lineNum">    1098 </span>                :            : 
<span class="lineNum">    1099 </span>                :            :     @param leadingEdgeList Output vector.
<span class="lineNum">    1100 </span>                :            : 
<span class="lineNum">    1101 </span>                :            :     The function gives one edge ID for each triangle.
<span class="lineNum">    1102 </span>                :            :      */
<span class="lineNum">    1103 </span>                :            :     CV_WRAP void getLeadingEdgeList(CV_OUT std::vector&lt;int&gt;&amp; leadingEdgeList) const;
<span class="lineNum">    1104 </span>                :            : 
<span class="lineNum">    1105 </span>                :            :     /** @brief Returns a list of all triangles.
<span class="lineNum">    1106 </span>                :            : 
<span class="lineNum">    1107 </span>                :            :     @param triangleList Output vector.
<span class="lineNum">    1108 </span>                :            : 
<span class="lineNum">    1109 </span>                :            :     The function gives each triangle as a 6 numbers vector, where each two are one of the triangle
<span class="lineNum">    1110 </span>                :            :     vertices. i.e. p1_x = v[0], p1_y = v[1], p2_x = v[2], p2_y = v[3], p3_x = v[4], p3_y = v[5].
<span class="lineNum">    1111 </span>                :            :      */
<span class="lineNum">    1112 </span>                :            :     CV_WRAP void getTriangleList(CV_OUT std::vector&lt;Vec6f&gt;&amp; triangleList) const;
<span class="lineNum">    1113 </span>                :            : 
<span class="lineNum">    1114 </span>                :            :     /** @brief Returns a list of all Voroni facets.
<span class="lineNum">    1115 </span>                :            : 
<span class="lineNum">    1116 </span>                :            :     @param idx Vector of vertices IDs to consider. For all vertices you can pass empty vector.
<span class="lineNum">    1117 </span>                :            :     @param facetList Output vector of the Voroni facets.
<span class="lineNum">    1118 </span>                :            :     @param facetCenters Output vector of the Voroni facets center points.
<span class="lineNum">    1119 </span>                :            : 
<span class="lineNum">    1120 </span>                :            :      */
<span class="lineNum">    1121 </span>                :            :     CV_WRAP void getVoronoiFacetList(const std::vector&lt;int&gt;&amp; idx, CV_OUT std::vector&lt;std::vector&lt;Point2f&gt; &gt;&amp; facetList,
<span class="lineNum">    1122 </span>                :            :                                      CV_OUT std::vector&lt;Point2f&gt;&amp; facetCenters);
<span class="lineNum">    1123 </span>                :            : 
<span class="lineNum">    1124 </span>                :            :     /** @brief Returns vertex location from vertex ID.
<span class="lineNum">    1125 </span>                :            : 
<span class="lineNum">    1126 </span>                :            :     @param vertex vertex ID.
<span class="lineNum">    1127 </span>                :            :     @param firstEdge Optional. The first edge ID which is connected to the vertex.
<span class="lineNum">    1128 </span>                :            :     @returns vertex (x,y)
<span class="lineNum">    1129 </span>                :            : 
<span class="lineNum">    1130 </span>                :            :      */
<span class="lineNum">    1131 </span>                :            :     CV_WRAP Point2f getVertex(int vertex, CV_OUT int* firstEdge = 0) const;
<span class="lineNum">    1132 </span>                :            : 
<span class="lineNum">    1133 </span>                :            :     /** @brief Returns one of the edges related to the given edge.
<span class="lineNum">    1134 </span>                :            : 
<span class="lineNum">    1135 </span>                :            :     @param edge Subdivision edge ID.
<span class="lineNum">    1136 </span>                :            :     @param nextEdgeType Parameter specifying which of the related edges to return.
<span class="lineNum">    1137 </span>                :            :     The following values are possible:
<span class="lineNum">    1138 </span>                :            :     -   NEXT_AROUND_ORG next around the edge origin ( eOnext on the picture below if e is the input edge)
<span class="lineNum">    1139 </span>                :            :     -   NEXT_AROUND_DST next around the edge vertex ( eDnext )
<span class="lineNum">    1140 </span>                :            :     -   PREV_AROUND_ORG previous around the edge origin (reversed eRnext )
<span class="lineNum">    1141 </span>                :            :     -   PREV_AROUND_DST previous around the edge destination (reversed eLnext )
<span class="lineNum">    1142 </span>                :            :     -   NEXT_AROUND_LEFT next around the left facet ( eLnext )
<span class="lineNum">    1143 </span>                :            :     -   NEXT_AROUND_RIGHT next around the right facet ( eRnext )
<span class="lineNum">    1144 </span>                :            :     -   PREV_AROUND_LEFT previous around the left facet (reversed eOnext )
<span class="lineNum">    1145 </span>                :            :     -   PREV_AROUND_RIGHT previous around the right facet (reversed eDnext )
<span class="lineNum">    1146 </span>                :            : 
<span class="lineNum">    1147 </span>                :            :     ![sample output](pics/quadedge.png)
<span class="lineNum">    1148 </span>                :            : 
<span class="lineNum">    1149 </span>                :            :     @returns edge ID related to the input edge.
<span class="lineNum">    1150 </span>                :            :      */
<span class="lineNum">    1151 </span>                :            :     CV_WRAP int getEdge( int edge, int nextEdgeType ) const;
<span class="lineNum">    1152 </span>                :            : 
<span class="lineNum">    1153 </span>                :            :     /** @brief Returns next edge around the edge origin.
<span class="lineNum">    1154 </span>                :            : 
<span class="lineNum">    1155 </span>                :            :     @param edge Subdivision edge ID.
<span class="lineNum">    1156 </span>                :            : 
<span class="lineNum">    1157 </span>                :            :     @returns an integer which is next edge ID around the edge origin: eOnext on the
<span class="lineNum">    1158 </span>                :            :     picture above if e is the input edge).
<span class="lineNum">    1159 </span>                :            :      */
<span class="lineNum">    1160 </span>                :            :     CV_WRAP int nextEdge(int edge) const;
<span class="lineNum">    1161 </span>                :            : 
<span class="lineNum">    1162 </span>                :            :     /** @brief Returns another edge of the same quad-edge.
<span class="lineNum">    1163 </span>                :            : 
<span class="lineNum">    1164 </span>                :            :     @param edge Subdivision edge ID.
<span class="lineNum">    1165 </span>                :            :     @param rotate Parameter specifying which of the edges of the same quad-edge as the input
<span class="lineNum">    1166 </span>                :            :     one to return. The following values are possible:
<span class="lineNum">    1167 </span>                :            :     -   0 - the input edge ( e on the picture below if e is the input edge)
<span class="lineNum">    1168 </span>                :            :     -   1 - the rotated edge ( eRot )
<span class="lineNum">    1169 </span>                :            :     -   2 - the reversed edge (reversed e (in green))
<span class="lineNum">    1170 </span>                :            :     -   3 - the reversed rotated edge (reversed eRot (in green))
<span class="lineNum">    1171 </span>                :            : 
<span class="lineNum">    1172 </span>                :            :     @returns one of the edges ID of the same quad-edge as the input edge.
<span class="lineNum">    1173 </span>                :            :      */
<span class="lineNum">    1174 </span>                :            :     CV_WRAP int rotateEdge(int edge, int rotate) const;
<span class="lineNum">    1175 </span>                :            :     CV_WRAP int symEdge(int edge) const;
<span class="lineNum">    1176 </span>                :            : 
<span class="lineNum">    1177 </span>                :            :     /** @brief Returns the edge origin.
<span class="lineNum">    1178 </span>                :            : 
<span class="lineNum">    1179 </span>                :            :     @param edge Subdivision edge ID.
<span class="lineNum">    1180 </span>                :            :     @param orgpt Output vertex location.
<span class="lineNum">    1181 </span>                :            : 
<span class="lineNum">    1182 </span>                :            :     @returns vertex ID.
<span class="lineNum">    1183 </span>                :            :      */
<span class="lineNum">    1184 </span>                :            :     CV_WRAP int edgeOrg(int edge, CV_OUT Point2f* orgpt = 0) const;
<span class="lineNum">    1185 </span>                :            : 
<span class="lineNum">    1186 </span>                :            :     /** @brief Returns the edge destination.
<span class="lineNum">    1187 </span>                :            : 
<span class="lineNum">    1188 </span>                :            :     @param edge Subdivision edge ID.
<span class="lineNum">    1189 </span>                :            :     @param dstpt Output vertex location.
<span class="lineNum">    1190 </span>                :            : 
<span class="lineNum">    1191 </span>                :            :     @returns vertex ID.
<span class="lineNum">    1192 </span>                :            :      */
<span class="lineNum">    1193 </span>                :            :     CV_WRAP int edgeDst(int edge, CV_OUT Point2f* dstpt = 0) const;
<span class="lineNum">    1194 </span>                :            : 
<span class="lineNum">    1195 </span>                :            : protected:
<span class="lineNum">    1196 </span>                :            :     int newEdge();
<span class="lineNum">    1197 </span>                :            :     void deleteEdge(int edge);
<span class="lineNum">    1198 </span>                :            :     int newPoint(Point2f pt, bool isvirtual, int firstEdge = 0);
<span class="lineNum">    1199 </span>                :            :     void deletePoint(int vtx);
<span class="lineNum">    1200 </span>                :            :     void setEdgePoints( int edge, int orgPt, int dstPt );
<span class="lineNum">    1201 </span>                :            :     void splice( int edgeA, int edgeB );
<span class="lineNum">    1202 </span>                :            :     int connectEdges( int edgeA, int edgeB );
<span class="lineNum">    1203 </span>                :            :     void swapEdges( int edge );
<span class="lineNum">    1204 </span>                :            :     int isRightOf(Point2f pt, int edge) const;
<span class="lineNum">    1205 </span>                :            :     void calcVoronoi();
<span class="lineNum">    1206 </span>                :            :     void clearVoronoi();
<span class="lineNum">    1207 </span>                :            :     void checkSubdiv() const;
<span class="lineNum">    1208 </span>                :            : 
<span class="lineNum">    1209 </span>                :            :     struct CV_EXPORTS Vertex
<span class="lineNum">    1210 </span>                :            :     {
<span class="lineNum">    1211 </span>                :            :         Vertex();
<span class="lineNum">    1212 </span>                :            :         Vertex(Point2f pt, bool _isvirtual, int _firstEdge=0);
<span class="lineNum">    1213 </span>                :            :         bool isvirtual() const;
<span class="lineNum">    1214 </span>                :            :         bool isfree() const;
<span class="lineNum">    1215 </span>                :            : 
<span class="lineNum">    1216 </span>                :            :         int firstEdge;
<span class="lineNum">    1217 </span>                :            :         int type;
<span class="lineNum">    1218 </span>                :            :         Point2f pt;
<span class="lineNum">    1219 </span>                :            :     };
<span class="lineNum">    1220 </span>                :            : 
<span class="lineNum">    1221 </span>                :            :     struct CV_EXPORTS QuadEdge
<span class="lineNum">    1222 </span>                :            :     {
<span class="lineNum">    1223 </span>                :            :         QuadEdge();
<span class="lineNum">    1224 </span>                :            :         QuadEdge(int edgeidx);
<span class="lineNum">    1225 </span>                :            :         bool isfree() const;
<span class="lineNum">    1226 </span>                :            : 
<span class="lineNum">    1227 </span>                :            :         int next[4];
<span class="lineNum">    1228 </span>                :            :         int pt[4];
<span class="lineNum">    1229 </span>                :            :     };
<span class="lineNum">    1230 </span>                :            : 
<span class="lineNum">    1231 </span>                :            :     //! All of the vertices
<span class="lineNum">    1232 </span>                :            :     std::vector&lt;Vertex&gt; vtx;
<span class="lineNum">    1233 </span>                :            :     //! All of the edges
<span class="lineNum">    1234 </span>                :            :     std::vector&lt;QuadEdge&gt; qedges;
<span class="lineNum">    1235 </span>                :            :     int freeQEdge;
<span class="lineNum">    1236 </span>                :            :     int freePoint;
<span class="lineNum">    1237 </span>                :            :     bool validGeometry;
<span class="lineNum">    1238 </span>                :            : 
<span class="lineNum">    1239 </span>                :            :     int recentEdge;
<span class="lineNum">    1240 </span>                :            :     //! Top left corner of the bounding rect
<span class="lineNum">    1241 </span>                :            :     Point2f topLeft;
<span class="lineNum">    1242 </span>                :            :     //! Bottom right corner of the bounding rect
<span class="lineNum">    1243 </span>                :            :     Point2f bottomRight;
<span class="lineNum">    1244 </span>                :            : };
<span class="lineNum">    1245 </span>                :            : 
<span class="lineNum">    1246 </span>                :            : //! @} imgproc_subdiv2d
<span class="lineNum">    1247 </span>                :            : 
<span class="lineNum">    1248 </span>                :            : //! @addtogroup imgproc_feature
<span class="lineNum">    1249 </span>                :            : //! @{
<span class="lineNum">    1250 </span>                :            : 
<span class="lineNum">    1251 </span>                :            : /** @example samples/cpp/lsd_lines.cpp
<span class="lineNum">    1252 </span>                :            : An example using the LineSegmentDetector
<span class="lineNum">    1253 </span>                :            : \image html building_lsd.png &quot;Sample output image&quot; width=434 height=300
<span class="lineNum">    1254 </span>                :            : */
<span class="lineNum">    1255 </span>                :            : 
<span class="lineNum">    1256 </span>                :            : /** @brief Line segment detector class
<span class="lineNum">    1257 </span>                :            : 
<span class="lineNum">    1258 </span>                :            : following the algorithm described at @cite Rafael12 .
<span class="lineNum">    1259 </span>                :            : */
<span class="lineNum">    1260 </span>                :            : class CV_EXPORTS_W LineSegmentDetector : public Algorithm
<span class="lineNum">    1261 </span>                :            : {
<span class="lineNum">    1262 </span>                :            : public:
<span class="lineNum">    1263 </span>                :            : 
<span class="lineNum">    1264 </span>                :            :     /** @brief Finds lines in the input image.
<span class="lineNum">    1265 </span>                :            : 
<span class="lineNum">    1266 </span>                :            :     This is the output of the default parameters of the algorithm on the above shown image.
<span class="lineNum">    1267 </span>                :            : 
<span class="lineNum">    1268 </span>                :            :     ![image](pics/building_lsd.png)
<span class="lineNum">    1269 </span>                :            : 
<span class="lineNum">    1270 </span>                :            :     @param _image A grayscale (CV_8UC1) input image. If only a roi needs to be selected, use:
<span class="lineNum">    1271 </span>                :            :     `lsd_ptr-\&gt;detect(image(roi), lines, ...); lines += Scalar(roi.x, roi.y, roi.x, roi.y);`
<span class="lineNum">    1272 </span>                :            :     @param _lines A vector of Vec4i or Vec4f elements specifying the beginning and ending point of a line. Where
<span class="lineNum">    1273 </span>                :            :     Vec4i/Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end. Returned lines are strictly
<span class="lineNum">    1274 </span>                :            :     oriented depending on the gradient.
<span class="lineNum">    1275 </span>                :            :     @param width Vector of widths of the regions, where the lines are found. E.g. Width of line.
<span class="lineNum">    1276 </span>                :            :     @param prec Vector of precisions with which the lines are found.
<span class="lineNum">    1277 </span>                :            :     @param nfa Vector containing number of false alarms in the line region, with precision of 10%. The
<span class="lineNum">    1278 </span>                :            :     bigger the value, logarithmically better the detection.
<span class="lineNum">    1279 </span>                :            :     - -1 corresponds to 10 mean false alarms
<span class="lineNum">    1280 </span>                :            :     - 0 corresponds to 1 mean false alarm
<span class="lineNum">    1281 </span>                :            :     - 1 corresponds to 0.1 mean false alarms
<span class="lineNum">    1282 </span>                :            :     This vector will be calculated only when the objects type is #LSD_REFINE_ADV.
<span class="lineNum">    1283 </span>                :            :     */
<span class="lineNum">    1284 </span>                :            :     CV_WRAP virtual void detect(InputArray _image, OutputArray _lines,
<span class="lineNum">    1285 </span>                :            :                         OutputArray width = noArray(), OutputArray prec = noArray(),
<span class="lineNum">    1286 </span>                :            :                         OutputArray nfa = noArray()) = 0;
<span class="lineNum">    1287 </span>                :            : 
<span class="lineNum">    1288 </span>                :            :     /** @brief Draws the line segments on a given image.
<span class="lineNum">    1289 </span>                :            :     @param _image The image, where the lines will be drawn. Should be bigger or equal to the image,
<span class="lineNum">    1290 </span>                :            :     where the lines were found.
<span class="lineNum">    1291 </span>                :            :     @param lines A vector of the lines that needed to be drawn.
<span class="lineNum">    1292 </span>                :            :      */
<span class="lineNum">    1293 </span>                :            :     CV_WRAP virtual void drawSegments(InputOutputArray _image, InputArray lines) = 0;
<span class="lineNum">    1294 </span>                :            : 
<span class="lineNum">    1295 </span>                :            :     /** @brief Draws two groups of lines in blue and red, counting the non overlapping (mismatching) pixels.
<span class="lineNum">    1296 </span>                :            : 
<span class="lineNum">    1297 </span>                :            :     @param size The size of the image, where lines1 and lines2 were found.
<span class="lineNum">    1298 </span>                :            :     @param lines1 The first group of lines that needs to be drawn. It is visualized in blue color.
<span class="lineNum">    1299 </span>                :            :     @param lines2 The second group of lines. They visualized in red color.
<span class="lineNum">    1300 </span>                :            :     @param _image Optional image, where the lines will be drawn. The image should be color(3-channel)
<span class="lineNum">    1301 </span>                :            :     in order for lines1 and lines2 to be drawn in the above mentioned colors.
<span class="lineNum">    1302 </span>                :            :      */
<a name="1303"><span class="lineNum">    1303 </span>                :            :     CV_WRAP virtual int compareSegments(const Size&amp; size, InputArray lines1, InputArray lines2, InputOutputArray _image = noArray()) = 0;</a>
<span class="lineNum">    1304 </span>                :            : 
<span class="lineNum">    1305 </span>                :<span class="lineNoCov">          0 :     virtual ~LineSegmentDetector() { }</span>
<span class="lineNum">    1306 </span>                :            : };
<span class="lineNum">    1307 </span>                :            : 
<span class="lineNum">    1308 </span>                :            : /** @brief Creates a smart pointer to a LineSegmentDetector object and initializes it.
<span class="lineNum">    1309 </span>                :            : 
<span class="lineNum">    1310 </span>                :            : The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
<span class="lineNum">    1311 </span>                :            : to edit those, as to tailor it for their own application.
<span class="lineNum">    1312 </span>                :            : 
<span class="lineNum">    1313 </span>                :            : @param _refine The way found lines will be refined, see #LineSegmentDetectorModes
<span class="lineNum">    1314 </span>                :            : @param _scale The scale of the image that will be used to find the lines. Range (0..1].
<span class="lineNum">    1315 </span>                :            : @param _sigma_scale Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale.
<span class="lineNum">    1316 </span>                :            : @param _quant Bound to the quantization error on the gradient norm.
<span class="lineNum">    1317 </span>                :            : @param _ang_th Gradient angle tolerance in degrees.
<span class="lineNum">    1318 </span>                :            : @param _log_eps Detection threshold: -log10(NFA) \&gt; log_eps. Used only when advance refinement
<span class="lineNum">    1319 </span>                :            : is chosen.
<span class="lineNum">    1320 </span>                :            : @param _density_th Minimal density of aligned region points in the enclosing rectangle.
<span class="lineNum">    1321 </span>                :            : @param _n_bins Number of bins in pseudo-ordering of gradient modulus.
<span class="lineNum">    1322 </span>                :            :  */
<span class="lineNum">    1323 </span>                :            : CV_EXPORTS_W Ptr&lt;LineSegmentDetector&gt; createLineSegmentDetector(
<span class="lineNum">    1324 </span>                :            :     int _refine = LSD_REFINE_STD, double _scale = 0.8,
<span class="lineNum">    1325 </span>                :            :     double _sigma_scale = 0.6, double _quant = 2.0, double _ang_th = 22.5,
<span class="lineNum">    1326 </span>                :            :     double _log_eps = 0, double _density_th = 0.7, int _n_bins = 1024);
<span class="lineNum">    1327 </span>                :            : 
<span class="lineNum">    1328 </span>                :            : //! @} imgproc_feature
<span class="lineNum">    1329 </span>                :            : 
<span class="lineNum">    1330 </span>                :            : //! @addtogroup imgproc_filter
<span class="lineNum">    1331 </span>                :            : //! @{
<span class="lineNum">    1332 </span>                :            : 
<span class="lineNum">    1333 </span>                :            : /** @brief Returns Gaussian filter coefficients.
<span class="lineNum">    1334 </span>                :            : 
<span class="lineNum">    1335 </span>                :            : The function computes and returns the \f$\texttt{ksize} \times 1\f$ matrix of Gaussian filter
<span class="lineNum">    1336 </span>                :            : coefficients:
<span class="lineNum">    1337 </span>                :            : 
<span class="lineNum">    1338 </span>                :            : \f[G_i= \alpha *e^{-(i-( \texttt{ksize} -1)/2)^2/(2* \texttt{sigma}^2)},\f]
<span class="lineNum">    1339 </span>                :            : 
<span class="lineNum">    1340 </span>                :            : where \f$i=0..\texttt{ksize}-1\f$ and \f$\alpha\f$ is the scale factor chosen so that \f$\sum_i G_i=1\f$.
<span class="lineNum">    1341 </span>                :            : 
<span class="lineNum">    1342 </span>                :            : Two of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize
<span class="lineNum">    1343 </span>                :            : smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly.
<span class="lineNum">    1344 </span>                :            : You may also use the higher-level GaussianBlur.
<span class="lineNum">    1345 </span>                :            : @param ksize Aperture size. It should be odd ( \f$\texttt{ksize} \mod 2 = 1\f$ ) and positive.
<span class="lineNum">    1346 </span>                :            : @param sigma Gaussian standard deviation. If it is non-positive, it is computed from ksize as
<span class="lineNum">    1347 </span>                :            : `sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`.
<span class="lineNum">    1348 </span>                :            : @param ktype Type of filter coefficients. It can be CV_32F or CV_64F .
<span class="lineNum">    1349 </span>                :            : @sa  sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur
<span class="lineNum">    1350 </span>                :            :  */
<span class="lineNum">    1351 </span>                :            : CV_EXPORTS_W Mat getGaussianKernel( int ksize, double sigma, int ktype = CV_64F );
<span class="lineNum">    1352 </span>                :            : 
<span class="lineNum">    1353 </span>                :            : /** @brief Returns filter coefficients for computing spatial image derivatives.
<span class="lineNum">    1354 </span>                :            : 
<span class="lineNum">    1355 </span>                :            : The function computes and returns the filter coefficients for spatial image derivatives. When
<span class="lineNum">    1356 </span>                :            : `ksize=FILTER_SCHARR`, the Scharr \f$3 \times 3\f$ kernels are generated (see #Scharr). Otherwise, Sobel
<span class="lineNum">    1357 </span>                :            : kernels are generated (see #Sobel). The filters are normally passed to #sepFilter2D or to
<span class="lineNum">    1358 </span>                :            : 
<span class="lineNum">    1359 </span>                :            : @param kx Output matrix of row filter coefficients. It has the type ktype .
<span class="lineNum">    1360 </span>                :            : @param ky Output matrix of column filter coefficients. It has the type ktype .
<span class="lineNum">    1361 </span>                :            : @param dx Derivative order in respect of x.
<span class="lineNum">    1362 </span>                :            : @param dy Derivative order in respect of y.
<span class="lineNum">    1363 </span>                :            : @param ksize Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7.
<span class="lineNum">    1364 </span>                :            : @param normalize Flag indicating whether to normalize (scale down) the filter coefficients or not.
<span class="lineNum">    1365 </span>                :            : Theoretically, the coefficients should have the denominator \f$=2^{ksize*2-dx-dy-2}\f$. If you are
<span class="lineNum">    1366 </span>                :            : going to filter floating-point images, you are likely to use the normalized kernels. But if you
<span class="lineNum">    1367 </span>                :            : compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve
<span class="lineNum">    1368 </span>                :            : all the fractional bits, you may want to set normalize=false .
<span class="lineNum">    1369 </span>                :            : @param ktype Type of filter coefficients. It can be CV_32f or CV_64F .
<span class="lineNum">    1370 </span>                :            :  */
<span class="lineNum">    1371 </span>                :            : CV_EXPORTS_W void getDerivKernels( OutputArray kx, OutputArray ky,
<span class="lineNum">    1372 </span>                :            :                                    int dx, int dy, int ksize,
<span class="lineNum">    1373 </span>                :            :                                    bool normalize = false, int ktype = CV_32F );
<span class="lineNum">    1374 </span>                :            : 
<span class="lineNum">    1375 </span>                :            : /** @brief Returns Gabor filter coefficients.
<span class="lineNum">    1376 </span>                :            : 
<span class="lineNum">    1377 </span>                :            : For more details about gabor filter equations and parameters, see: [Gabor
<span class="lineNum">    1378 </span>                :            : Filter](http://en.wikipedia.org/wiki/Gabor_filter).
<span class="lineNum">    1379 </span>                :            : 
<span class="lineNum">    1380 </span>                :            : @param ksize Size of the filter returned.
<span class="lineNum">    1381 </span>                :            : @param sigma Standard deviation of the gaussian envelope.
<span class="lineNum">    1382 </span>                :            : @param theta Orientation of the normal to the parallel stripes of a Gabor function.
<span class="lineNum">    1383 </span>                :            : @param lambd Wavelength of the sinusoidal factor.
<span class="lineNum">    1384 </span>                :            : @param gamma Spatial aspect ratio.
<span class="lineNum">    1385 </span>                :            : @param psi Phase offset.
<span class="lineNum">    1386 </span>                :            : @param ktype Type of filter coefficients. It can be CV_32F or CV_64F .
<span class="lineNum">    1387 </span>                :            :  */
<span class="lineNum">    1388 </span>                :            : CV_EXPORTS_W Mat getGaborKernel( Size ksize, double sigma, double theta, double lambd,
<span class="lineNum">    1389 </span>                :            :                                  double gamma, double psi = CV_PI*0.5, int ktype = CV_64F );
<span class="lineNum">    1390 </span>                :            : 
<span class="lineNum">    1391 </span>                :            : //! returns &quot;magic&quot; border value for erosion and dilation. It is automatically transformed to Scalar::all(-DBL_MAX) for dilation.
<span class="lineNum">    1392 </span>                :            : static inline Scalar morphologyDefaultBorderValue() { return Scalar::all(DBL_MAX); }
<span class="lineNum">    1393 </span>                :            : 
<span class="lineNum">    1394 </span>                :            : /** @brief Returns a structuring element of the specified size and shape for morphological operations.
<span class="lineNum">    1395 </span>                :            : 
<span class="lineNum">    1396 </span>                :            : The function constructs and returns the structuring element that can be further passed to #erode,
<span class="lineNum">    1397 </span>                :            : #dilate or #morphologyEx. But you can also construct an arbitrary binary mask yourself and use it as
<span class="lineNum">    1398 </span>                :            : the structuring element.
<span class="lineNum">    1399 </span>                :            : 
<span class="lineNum">    1400 </span>                :            : @param shape Element shape that could be one of #MorphShapes
<span class="lineNum">    1401 </span>                :            : @param ksize Size of the structuring element.
<span class="lineNum">    1402 </span>                :            : @param anchor Anchor position within the element. The default value \f$(-1, -1)\f$ means that the
<span class="lineNum">    1403 </span>                :            : anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor
<span class="lineNum">    1404 </span>                :            : position. In other cases the anchor just regulates how much the result of the morphological
<span class="lineNum">    1405 </span>                :            : operation is shifted.
<span class="lineNum">    1406 </span>                :            :  */
<span class="lineNum">    1407 </span>                :            : CV_EXPORTS_W Mat getStructuringElement(int shape, Size ksize, Point anchor = Point(-1,-1));
<span class="lineNum">    1408 </span>                :            : 
<span class="lineNum">    1409 </span>                :            : /** @example samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp
<span class="lineNum">    1410 </span>                :            : Sample code for simple filters
<span class="lineNum">    1411 </span>                :            : ![Sample screenshot](Smoothing_Tutorial_Result_Median_Filter.jpg)
<span class="lineNum">    1412 </span>                :            : Check @ref tutorial_gausian_median_blur_bilateral_filter &quot;the corresponding tutorial&quot; for more details
<span class="lineNum">    1413 </span>                :            :  */
<span class="lineNum">    1414 </span>                :            : 
<span class="lineNum">    1415 </span>                :            : /** @brief Blurs an image using the median filter.
<span class="lineNum">    1416 </span>                :            : 
<span class="lineNum">    1417 </span>                :            : The function smoothes an image using the median filter with the \f$\texttt{ksize} \times
<span class="lineNum">    1418 </span>                :            : \texttt{ksize}\f$ aperture. Each channel of a multi-channel image is processed independently.
<span class="lineNum">    1419 </span>                :            : In-place operation is supported.
<span class="lineNum">    1420 </span>                :            : 
<span class="lineNum">    1421 </span>                :            : @note The median filter uses #BORDER_REPLICATE internally to cope with border pixels, see #BorderTypes
<span class="lineNum">    1422 </span>                :            : 
<span class="lineNum">    1423 </span>                :            : @param src input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be
<span class="lineNum">    1424 </span>                :            : CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U.
<span class="lineNum">    1425 </span>                :            : @param dst destination array of the same size and type as src.
<span class="lineNum">    1426 </span>                :            : @param ksize aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...
<span class="lineNum">    1427 </span>                :            : @sa  bilateralFilter, blur, boxFilter, GaussianBlur
<span class="lineNum">    1428 </span>                :            :  */
<span class="lineNum">    1429 </span>                :            : CV_EXPORTS_W void medianBlur( InputArray src, OutputArray dst, int ksize );
<span class="lineNum">    1430 </span>                :            : 
<span class="lineNum">    1431 </span>                :            : /** @brief Blurs an image using a Gaussian filter.
<span class="lineNum">    1432 </span>                :            : 
<span class="lineNum">    1433 </span>                :            : The function convolves the source image with the specified Gaussian kernel. In-place filtering is
<span class="lineNum">    1434 </span>                :            : supported.
<span class="lineNum">    1435 </span>                :            : 
<span class="lineNum">    1436 </span>                :            : @param src input image; the image can have any number of channels, which are processed
<span class="lineNum">    1437 </span>                :            : independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
<span class="lineNum">    1438 </span>                :            : @param dst output image of the same size and type as src.
<span class="lineNum">    1439 </span>                :            : @param ksize Gaussian kernel size. ksize.width and ksize.height can differ but they both must be
<span class="lineNum">    1440 </span>                :            : positive and odd. Or, they can be zero's and then they are computed from sigma.
<span class="lineNum">    1441 </span>                :            : @param sigmaX Gaussian kernel standard deviation in X direction.
<span class="lineNum">    1442 </span>                :            : @param sigmaY Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be
<span class="lineNum">    1443 </span>                :            : equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height,
<span class="lineNum">    1444 </span>                :            : respectively (see #getGaussianKernel for details); to fully control the result regardless of
<span class="lineNum">    1445 </span>                :            : possible future modifications of all this semantics, it is recommended to specify all of ksize,
<span class="lineNum">    1446 </span>                :            : sigmaX, and sigmaY.
<span class="lineNum">    1447 </span>                :            : @param borderType pixel extrapolation method, see #BorderTypes
<span class="lineNum">    1448 </span>                :            : 
<span class="lineNum">    1449 </span>                :            : @sa  sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur
<span class="lineNum">    1450 </span>                :            :  */
<span class="lineNum">    1451 </span>                :            : CV_EXPORTS_W void GaussianBlur( InputArray src, OutputArray dst, Size ksize,
<span class="lineNum">    1452 </span>                :            :                                 double sigmaX, double sigmaY = 0,
<span class="lineNum">    1453 </span>                :            :                                 int borderType = BORDER_DEFAULT );
<span class="lineNum">    1454 </span>                :            : 
<span class="lineNum">    1455 </span>                :            : /** @brief Applies the bilateral filter to an image.
<span class="lineNum">    1456 </span>                :            : 
<span class="lineNum">    1457 </span>                :            : The function applies bilateral filtering to the input image, as described in
<span class="lineNum">    1458 </span>                :            : http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html
<span class="lineNum">    1459 </span>                :            : bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is
<span class="lineNum">    1460 </span>                :            : very slow compared to most filters.
<span class="lineNum">    1461 </span>                :            : 
<span class="lineNum">    1462 </span>                :            : _Sigma values_: For simplicity, you can set the 2 sigma values to be the same. If they are small (\&lt;
<span class="lineNum">    1463 </span>                :            : 10), the filter will not have much effect, whereas if they are large (\&gt; 150), they will have a very
<span class="lineNum">    1464 </span>                :            : strong effect, making the image look &quot;cartoonish&quot;.
<span class="lineNum">    1465 </span>                :            : 
<span class="lineNum">    1466 </span>                :            : _Filter size_: Large filters (d \&gt; 5) are very slow, so it is recommended to use d=5 for real-time
<span class="lineNum">    1467 </span>                :            : applications, and perhaps d=9 for offline applications that need heavy noise filtering.
<span class="lineNum">    1468 </span>                :            : 
<span class="lineNum">    1469 </span>                :            : This filter does not work inplace.
<span class="lineNum">    1470 </span>                :            : @param src Source 8-bit or floating-point, 1-channel or 3-channel image.
<span class="lineNum">    1471 </span>                :            : @param dst Destination image of the same size and type as src .
<span class="lineNum">    1472 </span>                :            : @param d Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,
<span class="lineNum">    1473 </span>                :            : it is computed from sigmaSpace.
<span class="lineNum">    1474 </span>                :            : @param sigmaColor Filter sigma in the color space. A larger value of the parameter means that
<span class="lineNum">    1475 </span>                :            : farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting
<span class="lineNum">    1476 </span>                :            : in larger areas of semi-equal color.
<span class="lineNum">    1477 </span>                :            : @param sigmaSpace Filter sigma in the coordinate space. A larger value of the parameter means that
<span class="lineNum">    1478 </span>                :            : farther pixels will influence each other as long as their colors are close enough (see sigmaColor
<span class="lineNum">    1479 </span>                :            : ). When d\&gt;0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is
<span class="lineNum">    1480 </span>                :            : proportional to sigmaSpace.
<span class="lineNum">    1481 </span>                :            : @param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes
<span class="lineNum">    1482 </span>                :            :  */
<span class="lineNum">    1483 </span>                :            : CV_EXPORTS_W void bilateralFilter( InputArray src, OutputArray dst, int d,
<span class="lineNum">    1484 </span>                :            :                                    double sigmaColor, double sigmaSpace,
<span class="lineNum">    1485 </span>                :            :                                    int borderType = BORDER_DEFAULT );
<span class="lineNum">    1486 </span>                :            : 
<span class="lineNum">    1487 </span>                :            : /** @brief Blurs an image using the box filter.
<span class="lineNum">    1488 </span>                :            : 
<span class="lineNum">    1489 </span>                :            : The function smooths an image using the kernel:
<span class="lineNum">    1490 </span>                :            : 
<span class="lineNum">    1491 </span>                :            : \f[\texttt{K} =  \alpha \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1 \end{bmatrix}\f]
<span class="lineNum">    1492 </span>                :            : 
<span class="lineNum">    1493 </span>                :            : where
<span class="lineNum">    1494 </span>                :            : 
<span class="lineNum">    1495 </span>                :            : \f[\alpha = \fork{\frac{1}{\texttt{ksize.width*ksize.height}}}{when \texttt{normalize=true}}{1}{otherwise}\f]
<span class="lineNum">    1496 </span>                :            : 
<span class="lineNum">    1497 </span>                :            : Unnormalized box filter is useful for computing various integral characteristics over each pixel
<span class="lineNum">    1498 </span>                :            : neighborhood, such as covariance matrices of image derivatives (used in dense optical flow
<span class="lineNum">    1499 </span>                :            : algorithms, and so on). If you need to compute pixel sums over variable-size windows, use #integral.
<span class="lineNum">    1500 </span>                :            : 
<span class="lineNum">    1501 </span>                :            : @param src input image.
<span class="lineNum">    1502 </span>                :            : @param dst output image of the same size and type as src.
<span class="lineNum">    1503 </span>                :            : @param ddepth the output image depth (-1 to use src.depth()).
<span class="lineNum">    1504 </span>                :            : @param ksize blurring kernel size.
<span class="lineNum">    1505 </span>                :            : @param anchor anchor point; default value Point(-1,-1) means that the anchor is at the kernel
<span class="lineNum">    1506 </span>                :            : center.
<span class="lineNum">    1507 </span>                :            : @param normalize flag, specifying whether the kernel is normalized by its area or not.
<span class="lineNum">    1508 </span>                :            : @param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes
<span class="lineNum">    1509 </span>                :            : @sa  blur, bilateralFilter, GaussianBlur, medianBlur, integral
<span class="lineNum">    1510 </span>                :            :  */
<span class="lineNum">    1511 </span>                :            : CV_EXPORTS_W void boxFilter( InputArray src, OutputArray dst, int ddepth,
<span class="lineNum">    1512 </span>                :            :                              Size ksize, Point anchor = Point(-1,-1),
<span class="lineNum">    1513 </span>                :            :                              bool normalize = true,
<span class="lineNum">    1514 </span>                :            :                              int borderType = BORDER_DEFAULT );
<span class="lineNum">    1515 </span>                :            : 
<span class="lineNum">    1516 </span>                :            : /** @brief Calculates the normalized sum of squares of the pixel values overlapping the filter.
<span class="lineNum">    1517 </span>                :            : 
<span class="lineNum">    1518 </span>                :            : For every pixel \f$ (x, y) \f$ in the source image, the function calculates the sum of squares of those neighboring
<span class="lineNum">    1519 </span>                :            : pixel values which overlap the filter placed over the pixel \f$ (x, y) \f$.
<span class="lineNum">    1520 </span>                :            : 
<span class="lineNum">    1521 </span>                :            : The unnormalized square box filter can be useful in computing local image statistics such as the the local
<span class="lineNum">    1522 </span>                :            : variance and standard deviation around the neighborhood of a pixel.
<span class="lineNum">    1523 </span>                :            : 
<span class="lineNum">    1524 </span>                :            : @param src input image
<span class="lineNum">    1525 </span>                :            : @param dst output image of the same size and type as _src
<span class="lineNum">    1526 </span>                :            : @param ddepth the output image depth (-1 to use src.depth())
<span class="lineNum">    1527 </span>                :            : @param ksize kernel size
<span class="lineNum">    1528 </span>                :            : @param anchor kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel
<span class="lineNum">    1529 </span>                :            : center.
<span class="lineNum">    1530 </span>                :            : @param normalize flag, specifying whether the kernel is to be normalized by it's area or not.
<span class="lineNum">    1531 </span>                :            : @param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes
<span class="lineNum">    1532 </span>                :            : @sa boxFilter
<span class="lineNum">    1533 </span>                :            : */
<span class="lineNum">    1534 </span>                :            : CV_EXPORTS_W void sqrBoxFilter( InputArray src, OutputArray dst, int ddepth,
<span class="lineNum">    1535 </span>                :            :                                 Size ksize, Point anchor = Point(-1, -1),
<span class="lineNum">    1536 </span>                :            :                                 bool normalize = true,
<span class="lineNum">    1537 </span>                :            :                                 int borderType = BORDER_DEFAULT );
<span class="lineNum">    1538 </span>                :            : 
<span class="lineNum">    1539 </span>                :            : /** @brief Blurs an image using the normalized box filter.
<span class="lineNum">    1540 </span>                :            : 
<span class="lineNum">    1541 </span>                :            : The function smooths an image using the kernel:
<span class="lineNum">    1542 </span>                :            : 
<span class="lineNum">    1543 </span>                :            : \f[\texttt{K} =  \frac{1}{\texttt{ksize.width*ksize.height}} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \end{bmatrix}\f]
<span class="lineNum">    1544 </span>                :            : 
<span class="lineNum">    1545 </span>                :            : The call `blur(src, dst, ksize, anchor, borderType)` is equivalent to `boxFilter(src, dst, src.type(),
<span class="lineNum">    1546 </span>                :            : anchor, true, borderType)`.
<span class="lineNum">    1547 </span>                :            : 
<span class="lineNum">    1548 </span>                :            : @param src input image; it can have any number of channels, which are processed independently, but
<span class="lineNum">    1549 </span>                :            : the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
<span class="lineNum">    1550 </span>                :            : @param dst output image of the same size and type as src.
<span class="lineNum">    1551 </span>                :            : @param ksize blurring kernel size.
<span class="lineNum">    1552 </span>                :            : @param anchor anchor point; default value Point(-1,-1) means that the anchor is at the kernel
<span class="lineNum">    1553 </span>                :            : center.
<span class="lineNum">    1554 </span>                :            : @param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes
<span class="lineNum">    1555 </span>                :            : @sa  boxFilter, bilateralFilter, GaussianBlur, medianBlur
<span class="lineNum">    1556 </span>                :            :  */
<span class="lineNum">    1557 </span>                :            : CV_EXPORTS_W void blur( InputArray src, OutputArray dst,
<span class="lineNum">    1558 </span>                :            :                         Size ksize, Point anchor = Point(-1,-1),
<span class="lineNum">    1559 </span>                :            :                         int borderType = BORDER_DEFAULT );
<span class="lineNum">    1560 </span>                :            : 
<span class="lineNum">    1561 </span>                :            : /** @brief Convolves an image with the kernel.
<span class="lineNum">    1562 </span>                :            : 
<span class="lineNum">    1563 </span>                :            : The function applies an arbitrary linear filter to an image. In-place operation is supported. When
<span class="lineNum">    1564 </span>                :            : the aperture is partially outside the image, the function interpolates outlier pixel values
<span class="lineNum">    1565 </span>                :            : according to the specified border mode.
<span class="lineNum">    1566 </span>                :            : 
<span class="lineNum">    1567 </span>                :            : The function does actually compute correlation, not the convolution:
<span class="lineNum">    1568 </span>                :            : 
<span class="lineNum">    1569 </span>                :            : \f[\texttt{dst} (x,y) =  \sum _{ \stackrel{0\leq x' &lt; \texttt{kernel.cols},}{0\leq y' &lt; \texttt{kernel.rows}} }  \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} )\f]
<span class="lineNum">    1570 </span>                :            : 
<span class="lineNum">    1571 </span>                :            : That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip
<span class="lineNum">    1572 </span>                :            : the kernel using #flip and set the new anchor to `(kernel.cols - anchor.x - 1, kernel.rows -
<span class="lineNum">    1573 </span>                :            : anchor.y - 1)`.
<span class="lineNum">    1574 </span>                :            : 
<span class="lineNum">    1575 </span>                :            : The function uses the DFT-based algorithm in case of sufficiently large kernels (~`11 x 11` or
<span class="lineNum">    1576 </span>                :            : larger) and the direct algorithm for small kernels.
<span class="lineNum">    1577 </span>                :            : 
<span class="lineNum">    1578 </span>                :            : @param src input image.
<span class="lineNum">    1579 </span>                :            : @param dst output image of the same size and the same number of channels as src.
<span class="lineNum">    1580 </span>                :            : @param ddepth desired depth of the destination image, see @ref filter_depths &quot;combinations&quot;
<span class="lineNum">    1581 </span>                :            : @param kernel convolution kernel (or rather a correlation kernel), a single-channel floating point
<span class="lineNum">    1582 </span>                :            : matrix; if you want to apply different kernels to different channels, split the image into
<span class="lineNum">    1583 </span>                :            : separate color planes using split and process them individually.
<span class="lineNum">    1584 </span>                :            : @param anchor anchor of the kernel that indicates the relative position of a filtered point within
<span class="lineNum">    1585 </span>                :            : the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor
<span class="lineNum">    1586 </span>                :            : is at the kernel center.
<span class="lineNum">    1587 </span>                :            : @param delta optional value added to the filtered pixels before storing them in dst.
<span class="lineNum">    1588 </span>                :            : @param borderType pixel extrapolation method, see #BorderTypes
<span class="lineNum">    1589 </span>                :            : @sa  sepFilter2D, dft, matchTemplate
<span class="lineNum">    1590 </span>                :            :  */
<span class="lineNum">    1591 </span>                :            : CV_EXPORTS_W void filter2D( InputArray src, OutputArray dst, int ddepth,
<span class="lineNum">    1592 </span>                :            :                             InputArray kernel, Point anchor = Point(-1,-1),
<span class="lineNum">    1593 </span>                :            :                             double delta = 0, int borderType = BORDER_DEFAULT );
<span class="lineNum">    1594 </span>                :            : 
<span class="lineNum">    1595 </span>                :            : /** @brief Applies a separable linear filter to an image.
<span class="lineNum">    1596 </span>                :            : 
<span class="lineNum">    1597 </span>                :            : The function applies a separable linear filter to the image. That is, first, every row of src is
<span class="lineNum">    1598 </span>                :            : filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D
<span class="lineNum">    1599 </span>                :            : kernel kernelY. The final result shifted by delta is stored in dst .
<span class="lineNum">    1600 </span>                :            : 
<span class="lineNum">    1601 </span>                :            : @param src Source image.
<span class="lineNum">    1602 </span>                :            : @param dst Destination image of the same size and the same number of channels as src .
<span class="lineNum">    1603 </span>                :            : @param ddepth Destination image depth, see @ref filter_depths &quot;combinations&quot;
<span class="lineNum">    1604 </span>                :            : @param kernelX Coefficients for filtering each row.
<span class="lineNum">    1605 </span>                :            : @param kernelY Coefficients for filtering each column.
<span class="lineNum">    1606 </span>                :            : @param anchor Anchor position within the kernel. The default value \f$(-1,-1)\f$ means that the anchor
<span class="lineNum">    1607 </span>                :            : is at the kernel center.
<span class="lineNum">    1608 </span>                :            : @param delta Value added to the filtered results before storing them.
<span class="lineNum">    1609 </span>                :            : @param borderType Pixel extrapolation method, see #BorderTypes
<span class="lineNum">    1610 </span>                :            : @sa  filter2D, Sobel, GaussianBlur, boxFilter, blur
<span class="lineNum">    1611 </span>                :            :  */
<span class="lineNum">    1612 </span>                :            : CV_EXPORTS_W void sepFilter2D( InputArray src, OutputArray dst, int ddepth,
<span class="lineNum">    1613 </span>                :            :                                InputArray kernelX, InputArray kernelY,
<span class="lineNum">    1614 </span>                :            :                                Point anchor = Point(-1,-1),
<span class="lineNum">    1615 </span>                :            :                                double delta = 0, int borderType = BORDER_DEFAULT );
<span class="lineNum">    1616 </span>                :            : 
<span class="lineNum">    1617 </span>                :            : /** @example samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp
<span class="lineNum">    1618 </span>                :            : Sample code using Sobel and/or Scharr OpenCV functions to make a simple Edge Detector
<span class="lineNum">    1619 </span>                :            : ![Sample screenshot](Sobel_Derivatives_Tutorial_Result.jpg)
<span class="lineNum">    1620 </span>                :            : Check @ref tutorial_sobel_derivatives &quot;the corresponding tutorial&quot; for more details
<span class="lineNum">    1621 </span>                :            : */
<span class="lineNum">    1622 </span>                :            : 
<span class="lineNum">    1623 </span>                :            : /** @brief Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.
<span class="lineNum">    1624 </span>                :            : 
<span class="lineNum">    1625 </span>                :            : In all cases except one, the \f$\texttt{ksize} \times \texttt{ksize}\f$ separable kernel is used to
<span class="lineNum">    1626 </span>                :            : calculate the derivative. When \f$\texttt{ksize = 1}\f$, the \f$3 \times 1\f$ or \f$1 \times 3\f$
<span class="lineNum">    1627 </span>                :            : kernel is used (that is, no Gaussian smoothing is done). `ksize = 1` can only be used for the first
<span class="lineNum">    1628 </span>                :            : or the second x- or y- derivatives.
<span class="lineNum">    1629 </span>                :            : 
<span class="lineNum">    1630 </span>                :            : There is also the special value `ksize = #FILTER_SCHARR (-1)` that corresponds to the \f$3\times3\f$ Scharr
<span class="lineNum">    1631 </span>                :            : filter that may give more accurate results than the \f$3\times3\f$ Sobel. The Scharr aperture is
<span class="lineNum">    1632 </span>                :            : 
<span class="lineNum">    1633 </span>                :            : \f[\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\f]
<span class="lineNum">    1634 </span>                :            : 
<span class="lineNum">    1635 </span>                :            : for the x-derivative, or transposed for the y-derivative.
<span class="lineNum">    1636 </span>                :            : 
<span class="lineNum">    1637 </span>                :            : The function calculates an image derivative by convolving the image with the appropriate kernel:
<span class="lineNum">    1638 </span>                :            : 
<span class="lineNum">    1639 </span>                :            : \f[\texttt{dst} =  \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}}\f]
<span class="lineNum">    1640 </span>                :            : 
<span class="lineNum">    1641 </span>                :            : The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less
<span class="lineNum">    1642 </span>                :            : resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3)
<span class="lineNum">    1643 </span>                :            : or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first
<span class="lineNum">    1644 </span>                :            : case corresponds to a kernel of:
<span class="lineNum">    1645 </span>                :            : 
<span class="lineNum">    1646 </span>                :            : \f[\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\f]
<span class="lineNum">    1647 </span>                :            : 
<span class="lineNum">    1648 </span>                :            : The second case corresponds to a kernel of:
<span class="lineNum">    1649 </span>                :            : 
<span class="lineNum">    1650 </span>                :            : \f[\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\f]
<span class="lineNum">    1651 </span>                :            : 
<span class="lineNum">    1652 </span>                :            : @param src input image.
<span class="lineNum">    1653 </span>                :            : @param dst output image of the same size and the same number of channels as src .
<span class="lineNum">    1654 </span>                :            : @param ddepth output image depth, see @ref filter_depths &quot;combinations&quot;; in the case of
<span class="lineNum">    1655 </span>                :            :     8-bit input images it will result in truncated derivatives.
<span class="lineNum">    1656 </span>                :            : @param dx order of the derivative x.
<span class="lineNum">    1657 </span>                :            : @param dy order of the derivative y.
<span class="lineNum">    1658 </span>                :            : @param ksize size of the extended Sobel kernel; it must be 1, 3, 5, or 7.
<span class="lineNum">    1659 </span>                :            : @param scale optional scale factor for the computed derivative values; by default, no scaling is
<span class="lineNum">    1660 </span>                :            : applied (see #getDerivKernels for details).
<span class="lineNum">    1661 </span>                :            : @param delta optional delta value that is added to the results prior to storing them in dst.
<span class="lineNum">    1662 </span>                :            : @param borderType pixel extrapolation method, see #BorderTypes
<span class="lineNum">    1663 </span>                :            : @sa  Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar
<span class="lineNum">    1664 </span>                :            :  */
<span class="lineNum">    1665 </span>                :            : CV_EXPORTS_W void Sobel( InputArray src, OutputArray dst, int ddepth,
<span class="lineNum">    1666 </span>                :            :                          int dx, int dy, int ksize = 3,
<span class="lineNum">    1667 </span>                :            :                          double scale = 1, double delta = 0,
<span class="lineNum">    1668 </span>                :            :                          int borderType = BORDER_DEFAULT );
<span class="lineNum">    1669 </span>                :            : 
<span class="lineNum">    1670 </span>                :            : /** @brief Calculates the first order image derivative in both x and y using a Sobel operator
<span class="lineNum">    1671 </span>                :            : 
<span class="lineNum">    1672 </span>                :            : Equivalent to calling:
<span class="lineNum">    1673 </span>                :            : 
<span class="lineNum">    1674 </span>                :            : @code
<span class="lineNum">    1675 </span>                :            : Sobel( src, dx, CV_16SC1, 1, 0, 3 );
<span class="lineNum">    1676 </span>                :            : Sobel( src, dy, CV_16SC1, 0, 1, 3 );
<span class="lineNum">    1677 </span>                :            : @endcode
<span class="lineNum">    1678 </span>                :            : 
<span class="lineNum">    1679 </span>                :            : @param src input image.
<span class="lineNum">    1680 </span>                :            : @param dx output image with first-order derivative in x.
<span class="lineNum">    1681 </span>                :            : @param dy output image with first-order derivative in y.
<span class="lineNum">    1682 </span>                :            : @param ksize size of Sobel kernel. It must be 3.
<span class="lineNum">    1683 </span>                :            : @param borderType pixel extrapolation method, see #BorderTypes
<span class="lineNum">    1684 </span>                :            : 
<span class="lineNum">    1685 </span>                :            : @sa Sobel
<span class="lineNum">    1686 </span>                :            :  */
<span class="lineNum">    1687 </span>                :            : 
<span class="lineNum">    1688 </span>                :            : CV_EXPORTS_W void spatialGradient( InputArray src, OutputArray dx,
<span class="lineNum">    1689 </span>                :            :                                    OutputArray dy, int ksize = 3,
<span class="lineNum">    1690 </span>                :            :                                    int borderType = BORDER_DEFAULT );
<span class="lineNum">    1691 </span>                :            : 
<span class="lineNum">    1692 </span>                :            : /** @brief Calculates the first x- or y- image derivative using Scharr operator.
<span class="lineNum">    1693 </span>                :            : 
<span class="lineNum">    1694 </span>                :            : The function computes the first x- or y- spatial image derivative using the Scharr operator. The
<span class="lineNum">    1695 </span>                :            : call
<span class="lineNum">    1696 </span>                :            : 
<span class="lineNum">    1697 </span>                :            : \f[\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\f]
<span class="lineNum">    1698 </span>                :            : 
<span class="lineNum">    1699 </span>                :            : is equivalent to
<span class="lineNum">    1700 </span>                :            : 
<span class="lineNum">    1701 </span>                :            : \f[\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} .\f]
<span class="lineNum">    1702 </span>                :            : 
<span class="lineNum">    1703 </span>                :            : @param src input image.
<span class="lineNum">    1704 </span>                :            : @param dst output image of the same size and the same number of channels as src.
<span class="lineNum">    1705 </span>                :            : @param ddepth output image depth, see @ref filter_depths &quot;combinations&quot;
<span class="lineNum">    1706 </span>                :            : @param dx order of the derivative x.
<span class="lineNum">    1707 </span>                :            : @param dy order of the derivative y.
<span class="lineNum">    1708 </span>                :            : @param scale optional scale factor for the computed derivative values; by default, no scaling is
<span class="lineNum">    1709 </span>                :            : applied (see #getDerivKernels for details).
<span class="lineNum">    1710 </span>                :            : @param delta optional delta value that is added to the results prior to storing them in dst.
<span class="lineNum">    1711 </span>                :            : @param borderType pixel extrapolation method, see #BorderTypes
<span class="lineNum">    1712 </span>                :            : @sa  cartToPolar
<span class="lineNum">    1713 </span>                :            :  */
<span class="lineNum">    1714 </span>                :            : CV_EXPORTS_W void Scharr( InputArray src, OutputArray dst, int ddepth,
<span class="lineNum">    1715 </span>                :            :                           int dx, int dy, double scale = 1, double delta = 0,
<span class="lineNum">    1716 </span>                :            :                           int borderType = BORDER_DEFAULT );
<span class="lineNum">    1717 </span>                :            : 
<span class="lineNum">    1718 </span>                :            : /** @example samples/cpp/laplace.cpp
<span class="lineNum">    1719 </span>                :            : An example using Laplace transformations for edge detection
<span class="lineNum">    1720 </span>                :            : */
<span class="lineNum">    1721 </span>                :            : 
<span class="lineNum">    1722 </span>                :            : /** @brief Calculates the Laplacian of an image.
<span class="lineNum">    1723 </span>                :            : 
<span class="lineNum">    1724 </span>                :            : The function calculates the Laplacian of the source image by adding up the second x and y
<span class="lineNum">    1725 </span>                :            : derivatives calculated using the Sobel operator:
<span class="lineNum">    1726 </span>                :            : 
<span class="lineNum">    1727 </span>                :            : \f[\texttt{dst} =  \Delta \texttt{src} =  \frac{\partial^2 \texttt{src}}{\partial x^2} +  \frac{\partial^2 \texttt{src}}{\partial y^2}\f]
<span class="lineNum">    1728 </span>                :            : 
<span class="lineNum">    1729 </span>                :            : This is done when `ksize &gt; 1`. When `ksize == 1`, the Laplacian is computed by filtering the image
<span class="lineNum">    1730 </span>                :            : with the following \f$3 \times 3\f$ aperture:
<span class="lineNum">    1731 </span>                :            : 
<span class="lineNum">    1732 </span>                :            : \f[\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\f]
<span class="lineNum">    1733 </span>                :            : 
<span class="lineNum">    1734 </span>                :            : @param src Source image.
<span class="lineNum">    1735 </span>                :            : @param dst Destination image of the same size and the same number of channels as src .
<span class="lineNum">    1736 </span>                :            : @param ddepth Desired depth of the destination image.
<span class="lineNum">    1737 </span>                :            : @param ksize Aperture size used to compute the second-derivative filters. See #getDerivKernels for
<span class="lineNum">    1738 </span>                :            : details. The size must be positive and odd.
<span class="lineNum">    1739 </span>                :            : @param scale Optional scale factor for the computed Laplacian values. By default, no scaling is
<span class="lineNum">    1740 </span>                :            : applied. See #getDerivKernels for details.
<span class="lineNum">    1741 </span>                :            : @param delta Optional delta value that is added to the results prior to storing them in dst .
<span class="lineNum">    1742 </span>                :            : @param borderType Pixel extrapolation method, see #BorderTypes
<span class="lineNum">    1743 </span>                :            : @sa  Sobel, Scharr
<span class="lineNum">    1744 </span>                :            :  */
<span class="lineNum">    1745 </span>                :            : CV_EXPORTS_W void Laplacian( InputArray src, OutputArray dst, int ddepth,
<span class="lineNum">    1746 </span>                :            :                              int ksize = 1, double scale = 1, double delta = 0,
<span class="lineNum">    1747 </span>                :            :                              int borderType = BORDER_DEFAULT );
<span class="lineNum">    1748 </span>                :            : 
<span class="lineNum">    1749 </span>                :            : //! @} imgproc_filter
<span class="lineNum">    1750 </span>                :            : 
<span class="lineNum">    1751 </span>                :            : //! @addtogroup imgproc_feature
<span class="lineNum">    1752 </span>                :            : //! @{
<span class="lineNum">    1753 </span>                :            : 
<span class="lineNum">    1754 </span>                :            : /** @example samples/cpp/edge.cpp
<span class="lineNum">    1755 </span>                :            : This program demonstrates usage of the Canny edge detector
<span class="lineNum">    1756 </span>                :            : 
<span class="lineNum">    1757 </span>                :            : Check @ref tutorial_canny_detector &quot;the corresponding tutorial&quot; for more details
<span class="lineNum">    1758 </span>                :            : */
<span class="lineNum">    1759 </span>                :            : 
<span class="lineNum">    1760 </span>                :            : /** @brief Finds edges in an image using the Canny algorithm @cite Canny86 .
<span class="lineNum">    1761 </span>                :            : 
<span class="lineNum">    1762 </span>                :            : The function finds edges in the input image and marks them in the output map edges using the
<span class="lineNum">    1763 </span>                :            : Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The
<span class="lineNum">    1764 </span>                :            : largest value is used to find initial segments of strong edges. See
<span class="lineNum">    1765 </span>                :            : &lt;http://en.wikipedia.org/wiki/Canny_edge_detector&gt;
<span class="lineNum">    1766 </span>                :            : 
<span class="lineNum">    1767 </span>                :            : @param image 8-bit input image.
<span class="lineNum">    1768 </span>                :            : @param edges output edge map; single channels 8-bit image, which has the same size as image .
<span class="lineNum">    1769 </span>                :            : @param threshold1 first threshold for the hysteresis procedure.
<span class="lineNum">    1770 </span>                :            : @param threshold2 second threshold for the hysteresis procedure.
<span class="lineNum">    1771 </span>                :            : @param apertureSize aperture size for the Sobel operator.
<span class="lineNum">    1772 </span>                :            : @param L2gradient a flag, indicating whether a more accurate \f$L_2\f$ norm
<span class="lineNum">    1773 </span>                :            : \f$=\sqrt{(dI/dx)^2 + (dI/dy)^2}\f$ should be used to calculate the image gradient magnitude (
<span class="lineNum">    1774 </span>                :            : L2gradient=true ), or whether the default \f$L_1\f$ norm \f$=|dI/dx|+|dI/dy|\f$ is enough (
<span class="lineNum">    1775 </span>                :            : L2gradient=false ).
<span class="lineNum">    1776 </span>                :            :  */
<span class="lineNum">    1777 </span>                :            : CV_EXPORTS_W void Canny( InputArray image, OutputArray edges,
<span class="lineNum">    1778 </span>                :            :                          double threshold1, double threshold2,
<span class="lineNum">    1779 </span>                :            :                          int apertureSize = 3, bool L2gradient = false );
<span class="lineNum">    1780 </span>                :            : 
<span class="lineNum">    1781 </span>                :            : /** \overload
<span class="lineNum">    1782 </span>                :            : 
<span class="lineNum">    1783 </span>                :            : Finds edges in an image using the Canny algorithm with custom image gradient.
<span class="lineNum">    1784 </span>                :            : 
<span class="lineNum">    1785 </span>                :            : @param dx 16-bit x derivative of input image (CV_16SC1 or CV_16SC3).
<span class="lineNum">    1786 </span>                :            : @param dy 16-bit y derivative of input image (same type as dx).
<span class="lineNum">    1787 </span>                :            : @param edges output edge map; single channels 8-bit image, which has the same size as image .
<span class="lineNum">    1788 </span>                :            : @param threshold1 first threshold for the hysteresis procedure.
<span class="lineNum">    1789 </span>                :            : @param threshold2 second threshold for the hysteresis procedure.
<span class="lineNum">    1790 </span>                :            : @param L2gradient a flag, indicating whether a more accurate \f$L_2\f$ norm
<span class="lineNum">    1791 </span>                :            : \f$=\sqrt{(dI/dx)^2 + (dI/dy)^2}\f$ should be used to calculate the image gradient magnitude (
<span class="lineNum">    1792 </span>                :            : L2gradient=true ), or whether the default \f$L_1\f$ norm \f$=|dI/dx|+|dI/dy|\f$ is enough (
<span class="lineNum">    1793 </span>                :            : L2gradient=false ).
<span class="lineNum">    1794 </span>                :            :  */
<span class="lineNum">    1795 </span>                :            : CV_EXPORTS_W void Canny( InputArray dx, InputArray dy,
<span class="lineNum">    1796 </span>                :            :                          OutputArray edges,
<span class="lineNum">    1797 </span>                :            :                          double threshold1, double threshold2,
<span class="lineNum">    1798 </span>                :            :                          bool L2gradient = false );
<span class="lineNum">    1799 </span>                :            : 
<span class="lineNum">    1800 </span>                :            : /** @brief Calculates the minimal eigenvalue of gradient matrices for corner detection.
<span class="lineNum">    1801 </span>                :            : 
<span class="lineNum">    1802 </span>                :            : The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal
<span class="lineNum">    1803 </span>                :            : eigenvalue of the covariance matrix of derivatives, that is, \f$\min(\lambda_1, \lambda_2)\f$ in terms
<span class="lineNum">    1804 </span>                :            : of the formulae in the cornerEigenValsAndVecs description.
<span class="lineNum">    1805 </span>                :            : 
<span class="lineNum">    1806 </span>                :            : @param src Input single-channel 8-bit or floating-point image.
<span class="lineNum">    1807 </span>                :            : @param dst Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as
<span class="lineNum">    1808 </span>                :            : src .
<span class="lineNum">    1809 </span>                :            : @param blockSize Neighborhood size (see the details on #cornerEigenValsAndVecs ).
<span class="lineNum">    1810 </span>                :            : @param ksize Aperture parameter for the Sobel operator.
<span class="lineNum">    1811 </span>                :            : @param borderType Pixel extrapolation method. See #BorderTypes.
<span class="lineNum">    1812 </span>                :            :  */
<span class="lineNum">    1813 </span>                :            : CV_EXPORTS_W void cornerMinEigenVal( InputArray src, OutputArray dst,
<span class="lineNum">    1814 </span>                :            :                                      int blockSize, int ksize = 3,
<span class="lineNum">    1815 </span>                :            :                                      int borderType = BORDER_DEFAULT );
<span class="lineNum">    1816 </span>                :            : 
<span class="lineNum">    1817 </span>                :            : /** @brief Harris corner detector.
<span class="lineNum">    1818 </span>                :            : 
<span class="lineNum">    1819 </span>                :            : The function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and
<span class="lineNum">    1820 </span>                :            : cornerEigenValsAndVecs , for each pixel \f$(x, y)\f$ it calculates a \f$2\times2\f$ gradient covariance
<span class="lineNum">    1821 </span>                :            : matrix \f$M^{(x,y)}\f$ over a \f$\texttt{blockSize} \times \texttt{blockSize}\f$ neighborhood. Then, it
<span class="lineNum">    1822 </span>                :            : computes the following characteristic:
<span class="lineNum">    1823 </span>                :            : 
<span class="lineNum">    1824 </span>                :            : \f[\texttt{dst} (x,y) =  \mathrm{det} M^{(x,y)} - k  \cdot \left ( \mathrm{tr} M^{(x,y)} \right )^2\f]
<span class="lineNum">    1825 </span>                :            : 
<span class="lineNum">    1826 </span>                :            : Corners in the image can be found as the local maxima of this response map.
<span class="lineNum">    1827 </span>                :            : 
<span class="lineNum">    1828 </span>                :            : @param src Input single-channel 8-bit or floating-point image.
<span class="lineNum">    1829 </span>                :            : @param dst Image to store the Harris detector responses. It has the type CV_32FC1 and the same
<span class="lineNum">    1830 </span>                :            : size as src .
<span class="lineNum">    1831 </span>                :            : @param blockSize Neighborhood size (see the details on #cornerEigenValsAndVecs ).
<span class="lineNum">    1832 </span>                :            : @param ksize Aperture parameter for the Sobel operator.
<span class="lineNum">    1833 </span>                :            : @param k Harris detector free parameter. See the formula above.
<span class="lineNum">    1834 </span>                :            : @param borderType Pixel extrapolation method. See #BorderTypes.
<span class="lineNum">    1835 </span>                :            :  */
<span class="lineNum">    1836 </span>                :            : CV_EXPORTS_W void cornerHarris( InputArray src, OutputArray dst, int blockSize,
<span class="lineNum">    1837 </span>                :            :                                 int ksize, double k,
<span class="lineNum">    1838 </span>                :            :                                 int borderType = BORDER_DEFAULT );
<span class="lineNum">    1839 </span>                :            : 
<span class="lineNum">    1840 </span>                :            : /** @brief Calculates eigenvalues and eigenvectors of image blocks for corner detection.
<span class="lineNum">    1841 </span>                :            : 
<span class="lineNum">    1842 </span>                :            : For every pixel \f$p\f$ , the function cornerEigenValsAndVecs considers a blockSize \f$\times\f$ blockSize
<span class="lineNum">    1843 </span>                :            : neighborhood \f$S(p)\f$ . It calculates the covariation matrix of derivatives over the neighborhood as:
<span class="lineNum">    1844 </span>                :            : 
<span class="lineNum">    1845 </span>                :            : \f[M =  \begin{bmatrix} \sum _{S(p)}(dI/dx)^2 &amp;  \sum _{S(p)}dI/dx dI/dy  \\ \sum _{S(p)}dI/dx dI/dy &amp;  \sum _{S(p)}(dI/dy)^2 \end{bmatrix}\f]
<span class="lineNum">    1846 </span>                :            : 
<span class="lineNum">    1847 </span>                :            : where the derivatives are computed using the Sobel operator.
<span class="lineNum">    1848 </span>                :            : 
<span class="lineNum">    1849 </span>                :            : After that, it finds eigenvectors and eigenvalues of \f$M\f$ and stores them in the destination image as
<span class="lineNum">    1850 </span>                :            : \f$(\lambda_1, \lambda_2, x_1, y_1, x_2, y_2)\f$ where
<span class="lineNum">    1851 </span>                :            : 
<span class="lineNum">    1852 </span>                :            : -   \f$\lambda_1, \lambda_2\f$ are the non-sorted eigenvalues of \f$M\f$
<span class="lineNum">    1853 </span>                :            : -   \f$x_1, y_1\f$ are the eigenvectors corresponding to \f$\lambda_1\f$
<span class="lineNum">    1854 </span>                :            : -   \f$x_2, y_2\f$ are the eigenvectors corresponding to \f$\lambda_2\f$
<span class="lineNum">    1855 </span>                :            : 
<span class="lineNum">    1856 </span>                :            : The output of the function can be used for robust edge or corner detection.
<span class="lineNum">    1857 </span>                :            : 
<span class="lineNum">    1858 </span>                :            : @param src Input single-channel 8-bit or floating-point image.
<span class="lineNum">    1859 </span>                :            : @param dst Image to store the results. It has the same size as src and the type CV_32FC(6) .
<span class="lineNum">    1860 </span>                :            : @param blockSize Neighborhood size (see details below).
<span class="lineNum">    1861 </span>                :            : @param ksize Aperture parameter for the Sobel operator.
<span class="lineNum">    1862 </span>                :            : @param borderType Pixel extrapolation method. See #BorderTypes.
<span class="lineNum">    1863 </span>                :            : 
<span class="lineNum">    1864 </span>                :            : @sa  cornerMinEigenVal, cornerHarris, preCornerDetect
<span class="lineNum">    1865 </span>                :            :  */
<span class="lineNum">    1866 </span>                :            : CV_EXPORTS_W void cornerEigenValsAndVecs( InputArray src, OutputArray dst,
<span class="lineNum">    1867 </span>                :            :                                           int blockSize, int ksize,
<span class="lineNum">    1868 </span>                :            :                                           int borderType = BORDER_DEFAULT );
<span class="lineNum">    1869 </span>                :            : 
<span class="lineNum">    1870 </span>                :            : /** @brief Calculates a feature map for corner detection.
<span class="lineNum">    1871 </span>                :            : 
<span class="lineNum">    1872 </span>                :            : The function calculates the complex spatial derivative-based function of the source image
<span class="lineNum">    1873 </span>                :            : 
<span class="lineNum">    1874 </span>                :            : \f[\texttt{dst} = (D_x  \texttt{src} )^2  \cdot D_{yy}  \texttt{src} + (D_y  \texttt{src} )^2  \cdot D_{xx}  \texttt{src} - 2 D_x  \texttt{src} \cdot D_y  \texttt{src} \cdot D_{xy}  \texttt{src}\f]
<span class="lineNum">    1875 </span>                :            : 
<span class="lineNum">    1876 </span>                :            : where \f$D_x\f$,\f$D_y\f$ are the first image derivatives, \f$D_{xx}\f$,\f$D_{yy}\f$ are the second image
<span class="lineNum">    1877 </span>                :            : derivatives, and \f$D_{xy}\f$ is the mixed derivative.
<span class="lineNum">    1878 </span>                :            : 
<span class="lineNum">    1879 </span>                :            : The corners can be found as local maximums of the functions, as shown below:
<span class="lineNum">    1880 </span>                :            : @code
<span class="lineNum">    1881 </span>                :            :     Mat corners, dilated_corners;
<span class="lineNum">    1882 </span>                :            :     preCornerDetect(image, corners, 3);
<span class="lineNum">    1883 </span>                :            :     // dilation with 3x3 rectangular structuring element
<span class="lineNum">    1884 </span>                :            :     dilate(corners, dilated_corners, Mat(), 1);
<span class="lineNum">    1885 </span>                :            :     Mat corner_mask = corners == dilated_corners;
<span class="lineNum">    1886 </span>                :            : @endcode
<span class="lineNum">    1887 </span>                :            : 
<span class="lineNum">    1888 </span>                :            : @param src Source single-channel 8-bit of floating-point image.
<span class="lineNum">    1889 </span>                :            : @param dst Output image that has the type CV_32F and the same size as src .
<span class="lineNum">    1890 </span>                :            : @param ksize %Aperture size of the Sobel .
<span class="lineNum">    1891 </span>                :            : @param borderType Pixel extrapolation method. See #BorderTypes.
<span class="lineNum">    1892 </span>                :            :  */
<span class="lineNum">    1893 </span>                :            : CV_EXPORTS_W void preCornerDetect( InputArray src, OutputArray dst, int ksize,
<span class="lineNum">    1894 </span>                :            :                                    int borderType = BORDER_DEFAULT );
<span class="lineNum">    1895 </span>                :            : 
<span class="lineNum">    1896 </span>                :            : /** @brief Refines the corner locations.
<span class="lineNum">    1897 </span>                :            : 
<span class="lineNum">    1898 </span>                :            : The function iterates to find the sub-pixel accurate location of corners or radial saddle points, as
<span class="lineNum">    1899 </span>                :            : shown on the figure below.
<span class="lineNum">    1900 </span>                :            : 
<span class="lineNum">    1901 </span>                :            : ![image](pics/cornersubpix.png)
<span class="lineNum">    1902 </span>                :            : 
<span class="lineNum">    1903 </span>                :            : Sub-pixel accurate corner locator is based on the observation that every vector from the center \f$q\f$
<span class="lineNum">    1904 </span>                :            : to a point \f$p\f$ located within a neighborhood of \f$q\f$ is orthogonal to the image gradient at \f$p\f$
<span class="lineNum">    1905 </span>                :            : subject to image and measurement noise. Consider the expression:
<span class="lineNum">    1906 </span>                :            : 
<span class="lineNum">    1907 </span>                :            : \f[\epsilon _i = {DI_{p_i}}^T  \cdot (q - p_i)\f]
<span class="lineNum">    1908 </span>                :            : 
<span class="lineNum">    1909 </span>                :            : where \f${DI_{p_i}}\f$ is an image gradient at one of the points \f$p_i\f$ in a neighborhood of \f$q\f$ . The
<span class="lineNum">    1910 </span>                :            : value of \f$q\f$ is to be found so that \f$\epsilon_i\f$ is minimized. A system of equations may be set up
<span class="lineNum">    1911 </span>                :            : with \f$\epsilon_i\f$ set to zero:
<span class="lineNum">    1912 </span>                :            : 
<span class="lineNum">    1913 </span>                :            : \f[\sum _i(DI_{p_i}  \cdot {DI_{p_i}}^T) \cdot q -  \sum _i(DI_{p_i}  \cdot {DI_{p_i}}^T  \cdot p_i)\f]
<span class="lineNum">    1914 </span>                :            : 
<span class="lineNum">    1915 </span>                :            : where the gradients are summed within a neighborhood (&quot;search window&quot;) of \f$q\f$ . Calling the first
<span class="lineNum">    1916 </span>                :            : gradient term \f$G\f$ and the second gradient term \f$b\f$ gives:
<span class="lineNum">    1917 </span>                :            : 
<span class="lineNum">    1918 </span>                :            : \f[q = G^{-1}  \cdot b\f]
<span class="lineNum">    1919 </span>                :            : 
<span class="lineNum">    1920 </span>                :            : The algorithm sets the center of the neighborhood window at this new center \f$q\f$ and then iterates
<span class="lineNum">    1921 </span>                :            : until the center stays within a set threshold.
<span class="lineNum">    1922 </span>                :            : 
<span class="lineNum">    1923 </span>                :            : @param image Input single-channel, 8-bit or float image.
<span class="lineNum">    1924 </span>                :            : @param corners Initial coordinates of the input corners and refined coordinates provided for
<span class="lineNum">    1925 </span>                :            : output.
<span class="lineNum">    1926 </span>                :            : @param winSize Half of the side length of the search window. For example, if winSize=Size(5,5) ,
<span class="lineNum">    1927 </span>                :            : then a \f$(5*2+1) \times (5*2+1) = 11 \times 11\f$ search window is used.
<span class="lineNum">    1928 </span>                :            : @param zeroZone Half of the size of the dead region in the middle of the search zone over which
<span class="lineNum">    1929 </span>                :            : the summation in the formula below is not done. It is used sometimes to avoid possible
<span class="lineNum">    1930 </span>                :            : singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such
<span class="lineNum">    1931 </span>                :            : a size.
<span class="lineNum">    1932 </span>                :            : @param criteria Criteria for termination of the iterative process of corner refinement. That is,
<span class="lineNum">    1933 </span>                :            : the process of corner position refinement stops either after criteria.maxCount iterations or when
<span class="lineNum">    1934 </span>                :            : the corner position moves by less than criteria.epsilon on some iteration.
<span class="lineNum">    1935 </span>                :            :  */
<span class="lineNum">    1936 </span>                :            : CV_EXPORTS_W void cornerSubPix( InputArray image, InputOutputArray corners,
<span class="lineNum">    1937 </span>                :            :                                 Size winSize, Size zeroZone,
<span class="lineNum">    1938 </span>                :            :                                 TermCriteria criteria );
<span class="lineNum">    1939 </span>                :            : 
<span class="lineNum">    1940 </span>                :            : /** @brief Determines strong corners on an image.
<span class="lineNum">    1941 </span>                :            : 
<span class="lineNum">    1942 </span>                :            : The function finds the most prominent corners in the image or in the specified image region, as
<span class="lineNum">    1943 </span>                :            : described in @cite Shi94
<span class="lineNum">    1944 </span>                :            : 
<span class="lineNum">    1945 </span>                :            : -   Function calculates the corner quality measure at every source image pixel using the
<span class="lineNum">    1946 </span>                :            :     #cornerMinEigenVal or #cornerHarris .
<span class="lineNum">    1947 </span>                :            : -   Function performs a non-maximum suppression (the local maximums in *3 x 3* neighborhood are
<span class="lineNum">    1948 </span>                :            :     retained).
<span class="lineNum">    1949 </span>                :            : -   The corners with the minimal eigenvalue less than
<span class="lineNum">    1950 </span>                :            :     \f$\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)\f$ are rejected.
<span class="lineNum">    1951 </span>                :            : -   The remaining corners are sorted by the quality measure in the descending order.
<span class="lineNum">    1952 </span>                :            : -   Function throws away each corner for which there is a stronger corner at a distance less than
<span class="lineNum">    1953 </span>                :            :     maxDistance.
<span class="lineNum">    1954 </span>                :            : 
<span class="lineNum">    1955 </span>                :            : The function can be used to initialize a point-based tracker of an object.
<span class="lineNum">    1956 </span>                :            : 
<span class="lineNum">    1957 </span>                :            : @note If the function is called with different values A and B of the parameter qualityLevel , and
<span class="lineNum">    1958 </span>                :            : A \&gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector
<span class="lineNum">    1959 </span>                :            : with qualityLevel=B .
<span class="lineNum">    1960 </span>                :            : 
<span class="lineNum">    1961 </span>                :            : @param image Input 8-bit or floating-point 32-bit, single-channel image.
<span class="lineNum">    1962 </span>                :            : @param corners Output vector of detected corners.
<span class="lineNum">    1963 </span>                :            : @param maxCorners Maximum number of corners to return. If there are more corners than are found,
<span class="lineNum">    1964 </span>                :            : the strongest of them is returned. `maxCorners &lt;= 0` implies that no limit on the maximum is set
<span class="lineNum">    1965 </span>                :            : and all detected corners are returned.
<span class="lineNum">    1966 </span>                :            : @param qualityLevel Parameter characterizing the minimal accepted quality of image corners. The
<span class="lineNum">    1967 </span>                :            : parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
<span class="lineNum">    1968 </span>                :            : (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
<span class="lineNum">    1969 </span>                :            : quality measure less than the product are rejected. For example, if the best corner has the
<span class="lineNum">    1970 </span>                :            : quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
<span class="lineNum">    1971 </span>                :            : less than 15 are rejected.
<span class="lineNum">    1972 </span>                :            : @param minDistance Minimum possible Euclidean distance between the returned corners.
<span class="lineNum">    1973 </span>                :            : @param mask Optional region of interest. If the image is not empty (it needs to have the type
<span class="lineNum">    1974 </span>                :            : CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.
<span class="lineNum">    1975 </span>                :            : @param blockSize Size of an average block for computing a derivative covariation matrix over each
<span class="lineNum">    1976 </span>                :            : pixel neighborhood. See cornerEigenValsAndVecs .
<span class="lineNum">    1977 </span>                :            : @param useHarrisDetector Parameter indicating whether to use a Harris detector (see #cornerHarris)
<span class="lineNum">    1978 </span>                :            : or #cornerMinEigenVal.
<span class="lineNum">    1979 </span>                :            : @param k Free parameter of the Harris detector.
<span class="lineNum">    1980 </span>                :            : 
<span class="lineNum">    1981 </span>                :            : @sa  cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform,
<span class="lineNum">    1982 </span>                :            :  */
<span class="lineNum">    1983 </span>                :            : 
<span class="lineNum">    1984 </span>                :            : CV_EXPORTS_W void goodFeaturesToTrack( InputArray image, OutputArray corners,
<span class="lineNum">    1985 </span>                :            :                                      int maxCorners, double qualityLevel, double minDistance,
<span class="lineNum">    1986 </span>                :            :                                      InputArray mask = noArray(), int blockSize = 3,
<span class="lineNum">    1987 </span>                :            :                                      bool useHarrisDetector = false, double k = 0.04 );
<span class="lineNum">    1988 </span>                :            : 
<span class="lineNum">    1989 </span>                :            : CV_EXPORTS_W void goodFeaturesToTrack( InputArray image, OutputArray corners,
<span class="lineNum">    1990 </span>                :            :                                      int maxCorners, double qualityLevel, double minDistance,
<span class="lineNum">    1991 </span>                :            :                                      InputArray mask, int blockSize,
<span class="lineNum">    1992 </span>                :            :                                      int gradientSize, bool useHarrisDetector = false,
<span class="lineNum">    1993 </span>                :            :                                      double k = 0.04 );
<span class="lineNum">    1994 </span>                :            : /** @example samples/cpp/tutorial_code/ImgTrans/houghlines.cpp
<span class="lineNum">    1995 </span>                :            : An example using the Hough line detector
<span class="lineNum">    1996 </span>                :            : ![Sample input image](Hough_Lines_Tutorial_Original_Image.jpg) ![Output image](Hough_Lines_Tutorial_Result.jpg)
<span class="lineNum">    1997 </span>                :            : */
<span class="lineNum">    1998 </span>                :            : 
<span class="lineNum">    1999 </span>                :            : /** @brief Finds lines in a binary image using the standard Hough transform.
<span class="lineNum">    2000 </span>                :            : 
<span class="lineNum">    2001 </span>                :            : The function implements the standard or standard multi-scale Hough transform algorithm for line
<span class="lineNum">    2002 </span>                :            : detection. See &lt;http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&gt; for a good explanation of Hough
<span class="lineNum">    2003 </span>                :            : transform.
<span class="lineNum">    2004 </span>                :            : 
<span class="lineNum">    2005 </span>                :            : @param image 8-bit, single-channel binary source image. The image may be modified by the function.
<span class="lineNum">    2006 </span>                :            : @param lines Output vector of lines. Each line is represented by a 2 or 3 element vector
<span class="lineNum">    2007 </span>                :            : \f$(\rho, \theta)\f$ or \f$(\rho, \theta, \textrm{votes})\f$ . \f$\rho\f$ is the distance from the coordinate origin \f$(0,0)\f$ (top-left corner of
<span class="lineNum">    2008 </span>                :            : the image). \f$\theta\f$ is the line rotation angle in radians (
<span class="lineNum">    2009 </span>                :            : \f$0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line}\f$ ).
<span class="lineNum">    2010 </span>                :            : \f$\textrm{votes}\f$ is the value of accumulator.
<span class="lineNum">    2011 </span>                :            : @param rho Distance resolution of the accumulator in pixels.
<span class="lineNum">    2012 </span>                :            : @param theta Angle resolution of the accumulator in radians.
<span class="lineNum">    2013 </span>                :            : @param threshold Accumulator threshold parameter. Only those lines are returned that get enough
<span class="lineNum">    2014 </span>                :            : votes ( \f$&gt;\texttt{threshold}\f$ ).
<span class="lineNum">    2015 </span>                :            : @param srn For the multi-scale Hough transform, it is a divisor for the distance resolution rho .
<span class="lineNum">    2016 </span>                :            : The coarse accumulator distance resolution is rho and the accurate accumulator resolution is
<span class="lineNum">    2017 </span>                :            : rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these
<span class="lineNum">    2018 </span>                :            : parameters should be positive.
<span class="lineNum">    2019 </span>                :            : @param stn For the multi-scale Hough transform, it is a divisor for the distance resolution theta.
<span class="lineNum">    2020 </span>                :            : @param min_theta For standard and multi-scale Hough transform, minimum angle to check for lines.
<span class="lineNum">    2021 </span>                :            : Must fall between 0 and max_theta.
<span class="lineNum">    2022 </span>                :            : @param max_theta For standard and multi-scale Hough transform, maximum angle to check for lines.
<span class="lineNum">    2023 </span>                :            : Must fall between min_theta and CV_PI.
<span class="lineNum">    2024 </span>                :            :  */
<span class="lineNum">    2025 </span>                :            : CV_EXPORTS_W void HoughLines( InputArray image, OutputArray lines,
<span class="lineNum">    2026 </span>                :            :                               double rho, double theta, int threshold,
<span class="lineNum">    2027 </span>                :            :                               double srn = 0, double stn = 0,
<span class="lineNum">    2028 </span>                :            :                               double min_theta = 0, double max_theta = CV_PI );
<span class="lineNum">    2029 </span>                :            : 
<span class="lineNum">    2030 </span>                :            : /** @brief Finds line segments in a binary image using the probabilistic Hough transform.
<span class="lineNum">    2031 </span>                :            : 
<span class="lineNum">    2032 </span>                :            : The function implements the probabilistic Hough transform algorithm for line detection, described
<span class="lineNum">    2033 </span>                :            : in @cite Matas00
<span class="lineNum">    2034 </span>                :            : 
<span class="lineNum">    2035 </span>                :            : See the line detection example below:
<span class="lineNum">    2036 </span>                :            : @include snippets/imgproc_HoughLinesP.cpp
<span class="lineNum">    2037 </span>                :            : This is a sample picture the function parameters have been tuned for:
<span class="lineNum">    2038 </span>                :            : 
<span class="lineNum">    2039 </span>                :            : ![image](pics/building.jpg)
<span class="lineNum">    2040 </span>                :            : 
<span class="lineNum">    2041 </span>                :            : And this is the output of the above program in case of the probabilistic Hough transform:
<span class="lineNum">    2042 </span>                :            : 
<span class="lineNum">    2043 </span>                :            : ![image](pics/houghp.png)
<span class="lineNum">    2044 </span>                :            : 
<span class="lineNum">    2045 </span>                :            : @param image 8-bit, single-channel binary source image. The image may be modified by the function.
<span class="lineNum">    2046 </span>                :            : @param lines Output vector of lines. Each line is represented by a 4-element vector
<span class="lineNum">    2047 </span>                :            : \f$(x_1, y_1, x_2, y_2)\f$ , where \f$(x_1,y_1)\f$ and \f$(x_2, y_2)\f$ are the ending points of each detected
<span class="lineNum">    2048 </span>                :            : line segment.
<span class="lineNum">    2049 </span>                :            : @param rho Distance resolution of the accumulator in pixels.
<span class="lineNum">    2050 </span>                :            : @param theta Angle resolution of the accumulator in radians.
<span class="lineNum">    2051 </span>                :            : @param threshold Accumulator threshold parameter. Only those lines are returned that get enough
<span class="lineNum">    2052 </span>                :            : votes ( \f$&gt;\texttt{threshold}\f$ ).
<span class="lineNum">    2053 </span>                :            : @param minLineLength Minimum line length. Line segments shorter than that are rejected.
<span class="lineNum">    2054 </span>                :            : @param maxLineGap Maximum allowed gap between points on the same line to link them.
<span class="lineNum">    2055 </span>                :            : 
<span class="lineNum">    2056 </span>                :            : @sa LineSegmentDetector
<span class="lineNum">    2057 </span>                :            :  */
<span class="lineNum">    2058 </span>                :            : CV_EXPORTS_W void HoughLinesP( InputArray image, OutputArray lines,
<span class="lineNum">    2059 </span>                :            :                                double rho, double theta, int threshold,
<span class="lineNum">    2060 </span>                :            :                                double minLineLength = 0, double maxLineGap = 0 );
<span class="lineNum">    2061 </span>                :            : 
<span class="lineNum">    2062 </span>                :            : /** @brief Finds lines in a set of points using the standard Hough transform.
<span class="lineNum">    2063 </span>                :            : 
<span class="lineNum">    2064 </span>                :            : The function finds lines in a set of points using a modification of the Hough transform.
<span class="lineNum">    2065 </span>                :            : @include snippets/imgproc_HoughLinesPointSet.cpp
<span class="lineNum">    2066 </span>                :            : @param _point Input vector of points. Each vector must be encoded as a Point vector \f$(x,y)\f$. Type must be CV_32FC2 or CV_32SC2.
<span class="lineNum">    2067 </span>                :            : @param _lines Output vector of found lines. Each vector is encoded as a vector&lt;Vec3d&gt; \f$(votes, rho, theta)\f$.
<span class="lineNum">    2068 </span>                :            : The larger the value of 'votes', the higher the reliability of the Hough line.
<span class="lineNum">    2069 </span>                :            : @param lines_max Max count of hough lines.
<span class="lineNum">    2070 </span>                :            : @param threshold Accumulator threshold parameter. Only those lines are returned that get enough
<span class="lineNum">    2071 </span>                :            : votes ( \f$&gt;\texttt{threshold}\f$ )
<span class="lineNum">    2072 </span>                :            : @param min_rho Minimum Distance value of the accumulator in pixels.
<span class="lineNum">    2073 </span>                :            : @param max_rho Maximum Distance value of the accumulator in pixels.
<span class="lineNum">    2074 </span>                :            : @param rho_step Distance resolution of the accumulator in pixels.
<span class="lineNum">    2075 </span>                :            : @param min_theta Minimum angle value of the accumulator in radians.
<span class="lineNum">    2076 </span>                :            : @param max_theta Maximum angle value of the accumulator in radians.
<span class="lineNum">    2077 </span>                :            : @param theta_step Angle resolution of the accumulator in radians.
<span class="lineNum">    2078 </span>                :            :  */
<span class="lineNum">    2079 </span>                :            : CV_EXPORTS_W void HoughLinesPointSet( InputArray _point, OutputArray _lines, int lines_max, int threshold,
<span class="lineNum">    2080 </span>                :            :                                       double min_rho, double max_rho, double rho_step,
<span class="lineNum">    2081 </span>                :            :                                       double min_theta, double max_theta, double theta_step );
<span class="lineNum">    2082 </span>                :            : 
<span class="lineNum">    2083 </span>                :            : /** @example samples/cpp/tutorial_code/ImgTrans/houghcircles.cpp
<span class="lineNum">    2084 </span>                :            : An example using the Hough circle detector
<span class="lineNum">    2085 </span>                :            : */
<span class="lineNum">    2086 </span>                :            : 
<span class="lineNum">    2087 </span>                :            : /** @brief Finds circles in a grayscale image using the Hough transform.
<span class="lineNum">    2088 </span>                :            : 
<span class="lineNum">    2089 </span>                :            : The function finds circles in a grayscale image using a modification of the Hough transform.
<span class="lineNum">    2090 </span>                :            : 
<span class="lineNum">    2091 </span>                :            : Example: :
<span class="lineNum">    2092 </span>                :            : @include snippets/imgproc_HoughLinesCircles.cpp
<span class="lineNum">    2093 </span>                :            : 
<span class="lineNum">    2094 </span>                :            : @note Usually the function detects the centers of circles well. However, it may fail to find correct
<span class="lineNum">    2095 </span>                :            : radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if
<span class="lineNum">    2096 </span>                :            : you know it. Or, you may set maxRadius to a negative number to return centers only without radius
<span class="lineNum">    2097 </span>                :            : search, and find the correct radius using an additional procedure.
<span class="lineNum">    2098 </span>                :            : 
<span class="lineNum">    2099 </span>                :            : @param image 8-bit, single-channel, grayscale input image.
<span class="lineNum">    2100 </span>                :            : @param circles Output vector of found circles. Each vector is encoded as  3 or 4 element
<span class="lineNum">    2101 </span>                :            : floating-point vector \f$(x, y, radius)\f$ or \f$(x, y, radius, votes)\f$ .
<span class="lineNum">    2102 </span>                :            : @param method Detection method, see #HoughModes. Currently, the only implemented method is #HOUGH_GRADIENT
<span class="lineNum">    2103 </span>                :            : @param dp Inverse ratio of the accumulator resolution to the image resolution. For example, if
<span class="lineNum">    2104 </span>                :            : dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has
<span class="lineNum">    2105 </span>                :            : half as big width and height.
<span class="lineNum">    2106 </span>                :            : @param minDist Minimum distance between the centers of the detected circles. If the parameter is
<span class="lineNum">    2107 </span>                :            : too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is
<span class="lineNum">    2108 </span>                :            : too large, some circles may be missed.
<span class="lineNum">    2109 </span>                :            : @param param1 First method-specific parameter. In case of #HOUGH_GRADIENT , it is the higher
<span class="lineNum">    2110 </span>                :            : threshold of the two passed to the Canny edge detector (the lower one is twice smaller).
<span class="lineNum">    2111 </span>                :            : @param param2 Second method-specific parameter. In case of #HOUGH_GRADIENT , it is the
<span class="lineNum">    2112 </span>                :            : accumulator threshold for the circle centers at the detection stage. The smaller it is, the more
<span class="lineNum">    2113 </span>                :            : false circles may be detected. Circles, corresponding to the larger accumulator values, will be
<span class="lineNum">    2114 </span>                :            : returned first.
<span class="lineNum">    2115 </span>                :            : @param minRadius Minimum circle radius.
<span class="lineNum">    2116 </span>                :            : @param maxRadius Maximum circle radius. If &lt;= 0, uses the maximum image dimension. If &lt; 0, returns
<span class="lineNum">    2117 </span>                :            : centers without finding the radius.
<span class="lineNum">    2118 </span>                :            : 
<span class="lineNum">    2119 </span>                :            : @sa fitEllipse, minEnclosingCircle
<span class="lineNum">    2120 </span>                :            :  */
<span class="lineNum">    2121 </span>                :            : CV_EXPORTS_W void HoughCircles( InputArray image, OutputArray circles,
<span class="lineNum">    2122 </span>                :            :                                int method, double dp, double minDist,
<span class="lineNum">    2123 </span>                :            :                                double param1 = 100, double param2 = 100,
<span class="lineNum">    2124 </span>                :            :                                int minRadius = 0, int maxRadius = 0 );
<span class="lineNum">    2125 </span>                :            : 
<span class="lineNum">    2126 </span>                :            : //! @} imgproc_feature
<span class="lineNum">    2127 </span>                :            : 
<span class="lineNum">    2128 </span>                :            : //! @addtogroup imgproc_filter
<span class="lineNum">    2129 </span>                :            : //! @{
<span class="lineNum">    2130 </span>                :            : 
<span class="lineNum">    2131 </span>                :            : /** @example samples/cpp/tutorial_code/ImgProc/Morphology_2.cpp
<span class="lineNum">    2132 </span>                :            : Advanced morphology Transformations sample code
<span class="lineNum">    2133 </span>                :            : ![Sample screenshot](Morphology_2_Tutorial_Result.jpg)
<span class="lineNum">    2134 </span>                :            : Check @ref tutorial_opening_closing_hats &quot;the corresponding tutorial&quot; for more details
<span class="lineNum">    2135 </span>                :            : */
<span class="lineNum">    2136 </span>                :            : 
<span class="lineNum">    2137 </span>                :            : /** @brief Erodes an image by using a specific structuring element.
<span class="lineNum">    2138 </span>                :            : 
<span class="lineNum">    2139 </span>                :            : The function erodes the source image using the specified structuring element that determines the
<span class="lineNum">    2140 </span>                :            : shape of a pixel neighborhood over which the minimum is taken:
<span class="lineNum">    2141 </span>                :            : 
<span class="lineNum">    2142 </span>                :            : \f[\texttt{dst} (x,y) =  \min _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\f]
<span class="lineNum">    2143 </span>                :            : 
<span class="lineNum">    2144 </span>                :            : The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In
<span class="lineNum">    2145 </span>                :            : case of multi-channel images, each channel is processed independently.
<span class="lineNum">    2146 </span>                :            : 
<span class="lineNum">    2147 </span>                :            : @param src input image; the number of channels can be arbitrary, but the depth should be one of
<span class="lineNum">    2148 </span>                :            : CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
<span class="lineNum">    2149 </span>                :            : @param dst output image of the same size and type as src.
<span class="lineNum">    2150 </span>                :            : @param kernel structuring element used for erosion; if `element=Mat()`, a `3 x 3` rectangular
<span class="lineNum">    2151 </span>                :            : structuring element is used. Kernel can be created using #getStructuringElement.
<span class="lineNum">    2152 </span>                :            : @param anchor position of the anchor within the element; default value (-1, -1) means that the
<span class="lineNum">    2153 </span>                :            : anchor is at the element center.
<span class="lineNum">    2154 </span>                :            : @param iterations number of times erosion is applied.
<span class="lineNum">    2155 </span>                :            : @param borderType pixel extrapolation method, see #BorderTypes
<span class="lineNum">    2156 </span>                :            : @param borderValue border value in case of a constant border
<span class="lineNum">    2157 </span>                :            : @sa  dilate, morphologyEx, getStructuringElement
<span class="lineNum">    2158 </span>                :            :  */
<span class="lineNum">    2159 </span>                :            : CV_EXPORTS_W void erode( InputArray src, OutputArray dst, InputArray kernel,
<span class="lineNum">    2160 </span>                :            :                          Point anchor = Point(-1,-1), int iterations = 1,
<span class="lineNum">    2161 </span>                :            :                          int borderType = BORDER_CONSTANT,
<span class="lineNum">    2162 </span>                :            :                          const Scalar&amp; borderValue = morphologyDefaultBorderValue() );
<span class="lineNum">    2163 </span>                :            : 
<span class="lineNum">    2164 </span>                :            : /** @example samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp
<span class="lineNum">    2165 </span>                :            : Erosion and Dilation sample code
<span class="lineNum">    2166 </span>                :            : ![Sample Screenshot-Erosion](Morphology_1_Tutorial_Erosion_Result.jpg)![Sample Screenshot-Dilation](Morphology_1_Tutorial_Dilation_Result.jpg)
<span class="lineNum">    2167 </span>                :            : Check @ref tutorial_erosion_dilatation &quot;the corresponding tutorial&quot; for more details
<span class="lineNum">    2168 </span>                :            : */
<span class="lineNum">    2169 </span>                :            : 
<span class="lineNum">    2170 </span>                :            : /** @brief Dilates an image by using a specific structuring element.
<span class="lineNum">    2171 </span>                :            : 
<span class="lineNum">    2172 </span>                :            : The function dilates the source image using the specified structuring element that determines the
<span class="lineNum">    2173 </span>                :            : shape of a pixel neighborhood over which the maximum is taken:
<span class="lineNum">    2174 </span>                :            : \f[\texttt{dst} (x,y) =  \max _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\f]
<span class="lineNum">    2175 </span>                :            : 
<span class="lineNum">    2176 </span>                :            : The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In
<span class="lineNum">    2177 </span>                :            : case of multi-channel images, each channel is processed independently.
<span class="lineNum">    2178 </span>                :            : 
<span class="lineNum">    2179 </span>                :            : @param src input image; the number of channels can be arbitrary, but the depth should be one of
<span class="lineNum">    2180 </span>                :            : CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
<span class="lineNum">    2181 </span>                :            : @param dst output image of the same size and type as src.
<span class="lineNum">    2182 </span>                :            : @param kernel structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular
<span class="lineNum">    2183 </span>                :            : structuring element is used. Kernel can be created using #getStructuringElement
<span class="lineNum">    2184 </span>                :            : @param anchor position of the anchor within the element; default value (-1, -1) means that the
<span class="lineNum">    2185 </span>                :            : anchor is at the element center.
<span class="lineNum">    2186 </span>                :            : @param iterations number of times dilation is applied.
<span class="lineNum">    2187 </span>                :            : @param borderType pixel extrapolation method, see #BorderTypes
<span class="lineNum">    2188 </span>                :            : @param borderValue border value in case of a constant border
<span class="lineNum">    2189 </span>                :            : @sa  erode, morphologyEx, getStructuringElement
<span class="lineNum">    2190 </span>                :            :  */
<span class="lineNum">    2191 </span>                :            : CV_EXPORTS_W void dilate( InputArray src, OutputArray dst, InputArray kernel,
<span class="lineNum">    2192 </span>                :            :                           Point anchor = Point(-1,-1), int iterations = 1,
<span class="lineNum">    2193 </span>                :            :                           int borderType = BORDER_CONSTANT,
<span class="lineNum">    2194 </span>                :            :                           const Scalar&amp; borderValue = morphologyDefaultBorderValue() );
<span class="lineNum">    2195 </span>                :            : 
<span class="lineNum">    2196 </span>                :            : /** @brief Performs advanced morphological transformations.
<span class="lineNum">    2197 </span>                :            : 
<span class="lineNum">    2198 </span>                :            : The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as
<span class="lineNum">    2199 </span>                :            : basic operations.
<span class="lineNum">    2200 </span>                :            : 
<span class="lineNum">    2201 </span>                :            : Any of the operations can be done in-place. In case of multi-channel images, each channel is
<span class="lineNum">    2202 </span>                :            : processed independently.
<span class="lineNum">    2203 </span>                :            : 
<span class="lineNum">    2204 </span>                :            : @param src Source image. The number of channels can be arbitrary. The depth should be one of
<span class="lineNum">    2205 </span>                :            : CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
<span class="lineNum">    2206 </span>                :            : @param dst Destination image of the same size and type as source image.
<span class="lineNum">    2207 </span>                :            : @param op Type of a morphological operation, see #MorphTypes
<span class="lineNum">    2208 </span>                :            : @param kernel Structuring element. It can be created using #getStructuringElement.
<span class="lineNum">    2209 </span>                :            : @param anchor Anchor position with the kernel. Negative values mean that the anchor is at the
<span class="lineNum">    2210 </span>                :            : kernel center.
<span class="lineNum">    2211 </span>                :            : @param iterations Number of times erosion and dilation are applied.
<span class="lineNum">    2212 </span>                :            : @param borderType Pixel extrapolation method, see #BorderTypes
<span class="lineNum">    2213 </span>                :            : @param borderValue Border value in case of a constant border. The default value has a special
<span class="lineNum">    2214 </span>                :            : meaning.
<span class="lineNum">    2215 </span>                :            : @sa  dilate, erode, getStructuringElement
<span class="lineNum">    2216 </span>                :            : @note The number of iterations is the number of times erosion or dilatation operation will be applied.
<span class="lineNum">    2217 </span>                :            : For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply
<span class="lineNum">    2218 </span>                :            : successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate).
<span class="lineNum">    2219 </span>                :            :  */
<span class="lineNum">    2220 </span>                :            : CV_EXPORTS_W void morphologyEx( InputArray src, OutputArray dst,
<span class="lineNum">    2221 </span>                :            :                                 int op, InputArray kernel,
<span class="lineNum">    2222 </span>                :            :                                 Point anchor = Point(-1,-1), int iterations = 1,
<span class="lineNum">    2223 </span>                :            :                                 int borderType = BORDER_CONSTANT,
<span class="lineNum">    2224 </span>                :            :                                 const Scalar&amp; borderValue = morphologyDefaultBorderValue() );
<span class="lineNum">    2225 </span>                :            : 
<span class="lineNum">    2226 </span>                :            : //! @} imgproc_filter
<span class="lineNum">    2227 </span>                :            : 
<span class="lineNum">    2228 </span>                :            : //! @addtogroup imgproc_transform
<span class="lineNum">    2229 </span>                :            : //! @{
<span class="lineNum">    2230 </span>                :            : 
<span class="lineNum">    2231 </span>                :            : /** @brief Resizes an image.
<span class="lineNum">    2232 </span>                :            : 
<span class="lineNum">    2233 </span>                :            : The function resize resizes the image src down to or up to the specified size. Note that the
<span class="lineNum">    2234 </span>                :            : initial dst type or size are not taken into account. Instead, the size and type are derived from
<span class="lineNum">    2235 </span>                :            : the `src`,`dsize`,`fx`, and `fy`. If you want to resize src so that it fits the pre-created dst,
<span class="lineNum">    2236 </span>                :            : you may call the function as follows:
<span class="lineNum">    2237 </span>                :            : @code
<span class="lineNum">    2238 </span>                :            :     // explicitly specify dsize=dst.size(); fx and fy will be computed from that.
<span class="lineNum">    2239 </span>                :            :     resize(src, dst, dst.size(), 0, 0, interpolation);
<span class="lineNum">    2240 </span>                :            : @endcode
<span class="lineNum">    2241 </span>                :            : If you want to decimate the image by factor of 2 in each direction, you can call the function this
<span class="lineNum">    2242 </span>                :            : way:
<span class="lineNum">    2243 </span>                :            : @code
<span class="lineNum">    2244 </span>                :            :     // specify fx and fy and let the function compute the destination image size.
<span class="lineNum">    2245 </span>                :            :     resize(src, dst, Size(), 0.5, 0.5, interpolation);
<span class="lineNum">    2246 </span>                :            : @endcode
<span class="lineNum">    2247 </span>                :            : To shrink an image, it will generally look best with #INTER_AREA interpolation, whereas to
<span class="lineNum">    2248 </span>                :            : enlarge an image, it will generally look best with c#INTER_CUBIC (slow) or #INTER_LINEAR
<span class="lineNum">    2249 </span>                :            : (faster but still looks OK).
<span class="lineNum">    2250 </span>                :            : 
<span class="lineNum">    2251 </span>                :            : @param src input image.
<span class="lineNum">    2252 </span>                :            : @param dst output image; it has the size dsize (when it is non-zero) or the size computed from
<span class="lineNum">    2253 </span>                :            : src.size(), fx, and fy; the type of dst is the same as of src.
<span class="lineNum">    2254 </span>                :            : @param dsize output image size; if it equals zero, it is computed as:
<span class="lineNum">    2255 </span>                :            :  \f[\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\f]
<span class="lineNum">    2256 </span>                :            :  Either dsize or both fx and fy must be non-zero.
<span class="lineNum">    2257 </span>                :            : @param fx scale factor along the horizontal axis; when it equals 0, it is computed as
<span class="lineNum">    2258 </span>                :            : \f[\texttt{(double)dsize.width/src.cols}\f]
<span class="lineNum">    2259 </span>                :            : @param fy scale factor along the vertical axis; when it equals 0, it is computed as
<span class="lineNum">    2260 </span>                :            : \f[\texttt{(double)dsize.height/src.rows}\f]
<span class="lineNum">    2261 </span>                :            : @param interpolation interpolation method, see #InterpolationFlags
<span class="lineNum">    2262 </span>                :            : 
<span class="lineNum">    2263 </span>                :            : @sa  warpAffine, warpPerspective, remap
<span class="lineNum">    2264 </span>                :            :  */
<span class="lineNum">    2265 </span>                :            : CV_EXPORTS_W void resize( InputArray src, OutputArray dst,
<span class="lineNum">    2266 </span>                :            :                           Size dsize, double fx = 0, double fy = 0,
<span class="lineNum">    2267 </span>                :            :                           int interpolation = INTER_LINEAR );
<span class="lineNum">    2268 </span>                :            : 
<span class="lineNum">    2269 </span>                :            : /** @brief Applies an affine transformation to an image.
<span class="lineNum">    2270 </span>                :            : 
<span class="lineNum">    2271 </span>                :            : The function warpAffine transforms the source image using the specified matrix:
<span class="lineNum">    2272 </span>                :            : 
<span class="lineNum">    2273 </span>                :            : \f[\texttt{dst} (x,y) =  \texttt{src} ( \texttt{M} _{11} x +  \texttt{M} _{12} y +  \texttt{M} _{13}, \texttt{M} _{21} x +  \texttt{M} _{22} y +  \texttt{M} _{23})\f]
<span class="lineNum">    2274 </span>                :            : 
<span class="lineNum">    2275 </span>                :            : when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted
<span class="lineNum">    2276 </span>                :            : with #invertAffineTransform and then put in the formula above instead of M. The function cannot
<span class="lineNum">    2277 </span>                :            : operate in-place.
<span class="lineNum">    2278 </span>                :            : 
<span class="lineNum">    2279 </span>                :            : @param src input image.
<span class="lineNum">    2280 </span>                :            : @param dst output image that has the size dsize and the same type as src .
<span class="lineNum">    2281 </span>                :            : @param M \f$2\times 3\f$ transformation matrix.
<span class="lineNum">    2282 </span>                :            : @param dsize size of the output image.
<span class="lineNum">    2283 </span>                :            : @param flags combination of interpolation methods (see #InterpolationFlags) and the optional
<span class="lineNum">    2284 </span>                :            : flag #WARP_INVERSE_MAP that means that M is the inverse transformation (
<span class="lineNum">    2285 </span>                :            : \f$\texttt{dst}\rightarrow\texttt{src}\f$ ).
<span class="lineNum">    2286 </span>                :            : @param borderMode pixel extrapolation method (see #BorderTypes); when
<span class="lineNum">    2287 </span>                :            : borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to
<span class="lineNum">    2288 </span>                :            : the &quot;outliers&quot; in the source image are not modified by the function.
<span class="lineNum">    2289 </span>                :            : @param borderValue value used in case of a constant border; by default, it is 0.
<span class="lineNum">    2290 </span>                :            : 
<span class="lineNum">    2291 </span>                :            : @sa  warpPerspective, resize, remap, getRectSubPix, transform
<span class="lineNum">    2292 </span>                :            :  */
<span class="lineNum">    2293 </span>                :            : CV_EXPORTS_W void warpAffine( InputArray src, OutputArray dst,
<span class="lineNum">    2294 </span>                :            :                               InputArray M, Size dsize,
<span class="lineNum">    2295 </span>                :            :                               int flags = INTER_LINEAR,
<span class="lineNum">    2296 </span>                :            :                               int borderMode = BORDER_CONSTANT,
<span class="lineNum">    2297 </span>                :            :                               const Scalar&amp; borderValue = Scalar());
<span class="lineNum">    2298 </span>                :            : 
<span class="lineNum">    2299 </span>                :            : /** @example samples/cpp/warpPerspective_demo.cpp
<span class="lineNum">    2300 </span>                :            : An example program shows using cv::findHomography and cv::warpPerspective for image warping
<span class="lineNum">    2301 </span>                :            : */
<span class="lineNum">    2302 </span>                :            : 
<span class="lineNum">    2303 </span>                :            : /** @brief Applies a perspective transformation to an image.
<span class="lineNum">    2304 </span>                :            : 
<span class="lineNum">    2305 </span>                :            : The function warpPerspective transforms the source image using the specified matrix:
<span class="lineNum">    2306 </span>                :            : 
<span class="lineNum">    2307 </span>                :            : \f[\texttt{dst} (x,y) =  \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,
<span class="lineNum">    2308 </span>                :            :      \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right )\f]
<span class="lineNum">    2309 </span>                :            : 
<span class="lineNum">    2310 </span>                :            : when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert
<span class="lineNum">    2311 </span>                :            : and then put in the formula above instead of M. The function cannot operate in-place.
<span class="lineNum">    2312 </span>                :            : 
<span class="lineNum">    2313 </span>                :            : @param src input image.
<span class="lineNum">    2314 </span>                :            : @param dst output image that has the size dsize and the same type as src .
<span class="lineNum">    2315 </span>                :            : @param M \f$3\times 3\f$ transformation matrix.
<span class="lineNum">    2316 </span>                :            : @param dsize size of the output image.
<span class="lineNum">    2317 </span>                :            : @param flags combination of interpolation methods (#INTER_LINEAR or #INTER_NEAREST) and the
<span class="lineNum">    2318 </span>                :            : optional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation (
<span class="lineNum">    2319 </span>                :            : \f$\texttt{dst}\rightarrow\texttt{src}\f$ ).
<span class="lineNum">    2320 </span>                :            : @param borderMode pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE).
<span class="lineNum">    2321 </span>                :            : @param borderValue value used in case of a constant border; by default, it equals 0.
<span class="lineNum">    2322 </span>                :            : 
<span class="lineNum">    2323 </span>                :            : @sa  warpAffine, resize, remap, getRectSubPix, perspectiveTransform
<span class="lineNum">    2324 </span>                :            :  */
<span class="lineNum">    2325 </span>                :            : CV_EXPORTS_W void warpPerspective( InputArray src, OutputArray dst,
<span class="lineNum">    2326 </span>                :            :                                    InputArray M, Size dsize,
<span class="lineNum">    2327 </span>                :            :                                    int flags = INTER_LINEAR,
<span class="lineNum">    2328 </span>                :            :                                    int borderMode = BORDER_CONSTANT,
<span class="lineNum">    2329 </span>                :            :                                    const Scalar&amp; borderValue = Scalar());
<span class="lineNum">    2330 </span>                :            : 
<span class="lineNum">    2331 </span>                :            : /** @brief Applies a generic geometrical transformation to an image.
<span class="lineNum">    2332 </span>                :            : 
<span class="lineNum">    2333 </span>                :            : The function remap transforms the source image using the specified map:
<span class="lineNum">    2334 </span>                :            : 
<span class="lineNum">    2335 </span>                :            : \f[\texttt{dst} (x,y) =  \texttt{src} (map_x(x,y),map_y(x,y))\f]
<span class="lineNum">    2336 </span>                :            : 
<span class="lineNum">    2337 </span>                :            : where values of pixels with non-integer coordinates are computed using one of available
<span class="lineNum">    2338 </span>                :            : interpolation methods. \f$map_x\f$ and \f$map_y\f$ can be encoded as separate floating-point maps
<span class="lineNum">    2339 </span>                :            : in \f$map_1\f$ and \f$map_2\f$ respectively, or interleaved floating-point maps of \f$(x,y)\f$ in
<span class="lineNum">    2340 </span>                :            : \f$map_1\f$, or fixed-point maps created by using convertMaps. The reason you might want to
<span class="lineNum">    2341 </span>                :            : convert from floating to fixed-point representations of a map is that they can yield much faster
<span class="lineNum">    2342 </span>                :            : (\~2x) remapping operations. In the converted case, \f$map_1\f$ contains pairs (cvFloor(x),
<span class="lineNum">    2343 </span>                :            : cvFloor(y)) and \f$map_2\f$ contains indices in a table of interpolation coefficients.
<span class="lineNum">    2344 </span>                :            : 
<span class="lineNum">    2345 </span>                :            : This function cannot operate in-place.
<span class="lineNum">    2346 </span>                :            : 
<span class="lineNum">    2347 </span>                :            : @param src Source image.
<span class="lineNum">    2348 </span>                :            : @param dst Destination image. It has the same size as map1 and the same type as src .
<span class="lineNum">    2349 </span>                :            : @param map1 The first map of either (x,y) points or just x values having the type CV_16SC2 ,
<span class="lineNum">    2350 </span>                :            : CV_32FC1, or CV_32FC2. See convertMaps for details on converting a floating point
<span class="lineNum">    2351 </span>                :            : representation to fixed-point for speed.
<span class="lineNum">    2352 </span>                :            : @param map2 The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map
<span class="lineNum">    2353 </span>                :            : if map1 is (x,y) points), respectively.
<span class="lineNum">    2354 </span>                :            : @param interpolation Interpolation method (see #InterpolationFlags). The method #INTER_AREA is
<span class="lineNum">    2355 </span>                :            : not supported by this function.
<span class="lineNum">    2356 </span>                :            : @param borderMode Pixel extrapolation method (see #BorderTypes). When
<span class="lineNum">    2357 </span>                :            : borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image that
<span class="lineNum">    2358 </span>                :            : corresponds to the &quot;outliers&quot; in the source image are not modified by the function.
<span class="lineNum">    2359 </span>                :            : @param borderValue Value used in case of a constant border. By default, it is 0.
<span class="lineNum">    2360 </span>                :            : @note
<span class="lineNum">    2361 </span>                :            : Due to current implementation limitations the size of an input and output images should be less than 32767x32767.
<span class="lineNum">    2362 </span>                :            :  */
<span class="lineNum">    2363 </span>                :            : CV_EXPORTS_W void remap( InputArray src, OutputArray dst,
<span class="lineNum">    2364 </span>                :            :                          InputArray map1, InputArray map2,
<span class="lineNum">    2365 </span>                :            :                          int interpolation, int borderMode = BORDER_CONSTANT,
<span class="lineNum">    2366 </span>                :            :                          const Scalar&amp; borderValue = Scalar());
<span class="lineNum">    2367 </span>                :            : 
<span class="lineNum">    2368 </span>                :            : /** @brief Converts image transformation maps from one representation to another.
<span class="lineNum">    2369 </span>                :            : 
<span class="lineNum">    2370 </span>                :            : The function converts a pair of maps for remap from one representation to another. The following
<span class="lineNum">    2371 </span>                :            : options ( (map1.type(), map2.type()) \f$\rightarrow\f$ (dstmap1.type(), dstmap2.type()) ) are
<span class="lineNum">    2372 </span>                :            : supported:
<span class="lineNum">    2373 </span>                :            : 
<span class="lineNum">    2374 </span>                :            : - \f$\texttt{(CV_32FC1, CV_32FC1)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)}\f$. This is the
<span class="lineNum">    2375 </span>                :            : most frequently used conversion operation, in which the original floating-point maps (see remap )
<span class="lineNum">    2376 </span>                :            : are converted to a more compact and much faster fixed-point representation. The first output array
<span class="lineNum">    2377 </span>                :            : contains the rounded coordinates and the second array (created only when nninterpolation=false )
<span class="lineNum">    2378 </span>                :            : contains indices in the interpolation tables.
<span class="lineNum">    2379 </span>                :            : 
<span class="lineNum">    2380 </span>                :            : - \f$\texttt{(CV_32FC2)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)}\f$. The same as above but
<span class="lineNum">    2381 </span>                :            : the original maps are stored in one 2-channel matrix.
<span class="lineNum">    2382 </span>                :            : 
<span class="lineNum">    2383 </span>                :            : - Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same
<span class="lineNum">    2384 </span>                :            : as the originals.
<span class="lineNum">    2385 </span>                :            : 
<span class="lineNum">    2386 </span>                :            : @param map1 The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 .
<span class="lineNum">    2387 </span>                :            : @param map2 The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix),
<span class="lineNum">    2388 </span>                :            : respectively.
<span class="lineNum">    2389 </span>                :            : @param dstmap1 The first output map that has the type dstmap1type and the same size as src .
<span class="lineNum">    2390 </span>                :            : @param dstmap2 The second output map.
<span class="lineNum">    2391 </span>                :            : @param dstmap1type Type of the first output map that should be CV_16SC2, CV_32FC1, or
<span class="lineNum">    2392 </span>                :            : CV_32FC2 .
<span class="lineNum">    2393 </span>                :            : @param nninterpolation Flag indicating whether the fixed-point maps are used for the
<span class="lineNum">    2394 </span>                :            : nearest-neighbor or for a more complex interpolation.
<span class="lineNum">    2395 </span>                :            : 
<span class="lineNum">    2396 </span>                :            : @sa  remap, undistort, initUndistortRectifyMap
<span class="lineNum">    2397 </span>                :            :  */
<span class="lineNum">    2398 </span>                :            : CV_EXPORTS_W void convertMaps( InputArray map1, InputArray map2,
<span class="lineNum">    2399 </span>                :            :                                OutputArray dstmap1, OutputArray dstmap2,
<span class="lineNum">    2400 </span>                :            :                                int dstmap1type, bool nninterpolation = false );
<span class="lineNum">    2401 </span>                :            : 
<span class="lineNum">    2402 </span>                :            : /** @brief Calculates an affine matrix of 2D rotation.
<span class="lineNum">    2403 </span>                :            : 
<span class="lineNum">    2404 </span>                :            : The function calculates the following matrix:
<span class="lineNum">    2405 </span>                :            : 
<span class="lineNum">    2406 </span>                :            : \f[\begin{bmatrix} \alpha &amp;  \beta &amp; (1- \alpha )  \cdot \texttt{center.x} -  \beta \cdot \texttt{center.y} \\ - \beta &amp;  \alpha &amp;  \beta \cdot \texttt{center.x} + (1- \alpha )  \cdot \texttt{center.y} \end{bmatrix}\f]
<span class="lineNum">    2407 </span>                :            : 
<span class="lineNum">    2408 </span>                :            : where
<span class="lineNum">    2409 </span>                :            : 
<span class="lineNum">    2410 </span>                :            : \f[\begin{array}{l} \alpha =  \texttt{scale} \cdot \cos \texttt{angle} , \\ \beta =  \texttt{scale} \cdot \sin \texttt{angle} \end{array}\f]
<span class="lineNum">    2411 </span>                :            : 
<span class="lineNum">    2412 </span>                :            : The transformation maps the rotation center to itself. If this is not the target, adjust the shift.
<span class="lineNum">    2413 </span>                :            : 
<span class="lineNum">    2414 </span>                :            : @param center Center of the rotation in the source image.
<span class="lineNum">    2415 </span>                :            : @param angle Rotation angle in degrees. Positive values mean counter-clockwise rotation (the
<span class="lineNum">    2416 </span>                :            : coordinate origin is assumed to be the top-left corner).
<span class="lineNum">    2417 </span>                :            : @param scale Isotropic scale factor.
<span class="lineNum">    2418 </span>                :            : 
<span class="lineNum">    2419 </span>                :            : @sa  getAffineTransform, warpAffine, transform
<span class="lineNum">    2420 </span>                :            :  */
<span class="lineNum">    2421 </span>                :            : CV_EXPORTS_W Mat getRotationMatrix2D( Point2f center, double angle, double scale );
<span class="lineNum">    2422 </span>                :            : 
<span class="lineNum">    2423 </span>                :            : /** @brief Calculates an affine transform from three pairs of the corresponding points.
<span class="lineNum">    2424 </span>                :            : 
<span class="lineNum">    2425 </span>                :            : The function calculates the \f$2 \times 3\f$ matrix of an affine transform so that:
<span class="lineNum">    2426 </span>                :            : 
<span class="lineNum">    2427 </span>                :            : \f[\begin{bmatrix} x'_i \\ y'_i \end{bmatrix} = \texttt{map_matrix} \cdot \begin{bmatrix} x_i \\ y_i \\ 1 \end{bmatrix}\f]
<span class="lineNum">    2428 </span>                :            : 
<span class="lineNum">    2429 </span>                :            : where
<span class="lineNum">    2430 </span>                :            : 
<span class="lineNum">    2431 </span>                :            : \f[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2\f]
<span class="lineNum">    2432 </span>                :            : 
<span class="lineNum">    2433 </span>                :            : @param src Coordinates of triangle vertices in the source image.
<span class="lineNum">    2434 </span>                :            : @param dst Coordinates of the corresponding triangle vertices in the destination image.
<span class="lineNum">    2435 </span>                :            : 
<span class="lineNum">    2436 </span>                :            : @sa  warpAffine, transform
<span class="lineNum">    2437 </span>                :            :  */
<span class="lineNum">    2438 </span>                :            : CV_EXPORTS Mat getAffineTransform( const Point2f src[], const Point2f dst[] );
<span class="lineNum">    2439 </span>                :            : 
<span class="lineNum">    2440 </span>                :            : /** @brief Inverts an affine transformation.
<span class="lineNum">    2441 </span>                :            : 
<span class="lineNum">    2442 </span>                :            : The function computes an inverse affine transformation represented by \f$2 \times 3\f$ matrix M:
<span class="lineNum">    2443 </span>                :            : 
<span class="lineNum">    2444 </span>                :            : \f[\begin{bmatrix} a_{11} &amp; a_{12} &amp; b_1  \\ a_{21} &amp; a_{22} &amp; b_2 \end{bmatrix}\f]
<span class="lineNum">    2445 </span>                :            : 
<span class="lineNum">    2446 </span>                :            : The result is also a \f$2 \times 3\f$ matrix of the same type as M.
<span class="lineNum">    2447 </span>                :            : 
<span class="lineNum">    2448 </span>                :            : @param M Original affine transformation.
<span class="lineNum">    2449 </span>                :            : @param iM Output reverse affine transformation.
<span class="lineNum">    2450 </span>                :            :  */
<span class="lineNum">    2451 </span>                :            : CV_EXPORTS_W void invertAffineTransform( InputArray M, OutputArray iM );
<span class="lineNum">    2452 </span>                :            : 
<span class="lineNum">    2453 </span>                :            : /** @brief Calculates a perspective transform from four pairs of the corresponding points.
<span class="lineNum">    2454 </span>                :            : 
<span class="lineNum">    2455 </span>                :            : The function calculates the \f$3 \times 3\f$ matrix of a perspective transform so that:
<span class="lineNum">    2456 </span>                :            : 
<span class="lineNum">    2457 </span>                :            : \f[\begin{bmatrix} t_i x'_i \\ t_i y'_i \\ t_i \end{bmatrix} = \texttt{map_matrix} \cdot \begin{bmatrix} x_i \\ y_i \\ 1 \end{bmatrix}\f]
<span class="lineNum">    2458 </span>                :            : 
<span class="lineNum">    2459 </span>                :            : where
<span class="lineNum">    2460 </span>                :            : 
<span class="lineNum">    2461 </span>                :            : \f[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3\f]
<span class="lineNum">    2462 </span>                :            : 
<span class="lineNum">    2463 </span>                :            : @param src Coordinates of quadrangle vertices in the source image.
<span class="lineNum">    2464 </span>                :            : @param dst Coordinates of the corresponding quadrangle vertices in the destination image.
<span class="lineNum">    2465 </span>                :            : @param solveMethod method passed to cv::solve (#DecompTypes)
<span class="lineNum">    2466 </span>                :            : 
<span class="lineNum">    2467 </span>                :            : @sa  findHomography, warpPerspective, perspectiveTransform
<span class="lineNum">    2468 </span>                :            :  */
<span class="lineNum">    2469 </span>                :            : CV_EXPORTS_W Mat getPerspectiveTransform(InputArray src, InputArray dst, int solveMethod = DECOMP_LU);
<span class="lineNum">    2470 </span>                :            : 
<span class="lineNum">    2471 </span>                :            : /** @overload */
<span class="lineNum">    2472 </span>                :            : CV_EXPORTS Mat getPerspectiveTransform(const Point2f src[], const Point2f dst[], int solveMethod = DECOMP_LU);
<span class="lineNum">    2473 </span>                :            : 
<span class="lineNum">    2474 </span>                :            : 
<span class="lineNum">    2475 </span>                :            : CV_EXPORTS_W Mat getAffineTransform( InputArray src, InputArray dst );
<span class="lineNum">    2476 </span>                :            : 
<span class="lineNum">    2477 </span>                :            : /** @brief Retrieves a pixel rectangle from an image with sub-pixel accuracy.
<span class="lineNum">    2478 </span>                :            : 
<span class="lineNum">    2479 </span>                :            : The function getRectSubPix extracts pixels from src:
<span class="lineNum">    2480 </span>                :            : 
<span class="lineNum">    2481 </span>                :            : \f[patch(x, y) = src(x +  \texttt{center.x} - ( \texttt{dst.cols} -1)*0.5, y +  \texttt{center.y} - ( \texttt{dst.rows} -1)*0.5)\f]
<span class="lineNum">    2482 </span>                :            : 
<span class="lineNum">    2483 </span>                :            : where the values of the pixels at non-integer coordinates are retrieved using bilinear
<span class="lineNum">    2484 </span>                :            : interpolation. Every channel of multi-channel images is processed independently. Also
<span class="lineNum">    2485 </span>                :            : the image should be a single channel or three channel image. While the center of the
<span class="lineNum">    2486 </span>                :            : rectangle must be inside the image, parts of the rectangle may be outside.
<span class="lineNum">    2487 </span>                :            : 
<span class="lineNum">    2488 </span>                :            : @param image Source image.
<span class="lineNum">    2489 </span>                :            : @param patchSize Size of the extracted patch.
<span class="lineNum">    2490 </span>                :            : @param center Floating point coordinates of the center of the extracted rectangle within the
<span class="lineNum">    2491 </span>                :            : source image. The center must be inside the image.
<span class="lineNum">    2492 </span>                :            : @param patch Extracted patch that has the size patchSize and the same number of channels as src .
<span class="lineNum">    2493 </span>                :            : @param patchType Depth of the extracted pixels. By default, they have the same depth as src .
<span class="lineNum">    2494 </span>                :            : 
<span class="lineNum">    2495 </span>                :            : @sa  warpAffine, warpPerspective
<span class="lineNum">    2496 </span>                :            :  */
<span class="lineNum">    2497 </span>                :            : CV_EXPORTS_W void getRectSubPix( InputArray image, Size patchSize,
<span class="lineNum">    2498 </span>                :            :                                  Point2f center, OutputArray patch, int patchType = -1 );
<span class="lineNum">    2499 </span>                :            : 
<span class="lineNum">    2500 </span>                :            : /** @example samples/cpp/polar_transforms.cpp
<span class="lineNum">    2501 </span>                :            : An example using the cv::linearPolar and cv::logPolar operations
<span class="lineNum">    2502 </span>                :            : */
<span class="lineNum">    2503 </span>                :            : 
<span class="lineNum">    2504 </span>                :            : /** @brief Remaps an image to semilog-polar coordinates space.
<span class="lineNum">    2505 </span>                :            : 
<span class="lineNum">    2506 </span>                :            : @deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags+WARP_POLAR_LOG);
<span class="lineNum">    2507 </span>                :            : 
<span class="lineNum">    2508 </span>                :            : @internal
<span class="lineNum">    2509 </span>                :            : Transform the source image using the following transformation (See @ref polar_remaps_reference_image &quot;Polar remaps reference image d)&quot;):
<span class="lineNum">    2510 </span>                :            : \f[\begin{array}{l}
<span class="lineNum">    2511 </span>                :            :   dst( \rho , \phi ) = src(x,y) \\
<span class="lineNum">    2512 </span>                :            :   dst.size() \leftarrow src.size()
<span class="lineNum">    2513 </span>                :            : \end{array}\f]
<span class="lineNum">    2514 </span>                :            : 
<span class="lineNum">    2515 </span>                :            : where
<span class="lineNum">    2516 </span>                :            : \f[\begin{array}{l}
<span class="lineNum">    2517 </span>                :            :   I = (dx,dy) = (x - center.x,y - center.y) \\
<span class="lineNum">    2518 </span>                :            :   \rho = M \cdot log_e(\texttt{magnitude} (I)) ,\\
<span class="lineNum">    2519 </span>                :            :   \phi = Kangle \cdot \texttt{angle} (I) \\
<span class="lineNum">    2520 </span>                :            : \end{array}\f]
<span class="lineNum">    2521 </span>                :            : 
<span class="lineNum">    2522 </span>                :            : and
<span class="lineNum">    2523 </span>                :            : \f[\begin{array}{l}
<span class="lineNum">    2524 </span>                :            :   M = src.cols / log_e(maxRadius) \\
<span class="lineNum">    2525 </span>                :            :   Kangle = src.rows / 2\Pi \\
<span class="lineNum">    2526 </span>                :            : \end{array}\f]
<span class="lineNum">    2527 </span>                :            : 
<span class="lineNum">    2528 </span>                :            : The function emulates the human &quot;foveal&quot; vision and can be used for fast scale and
<span class="lineNum">    2529 </span>                :            : rotation-invariant template matching, for object tracking and so forth.
<span class="lineNum">    2530 </span>                :            : @param src Source image
<span class="lineNum">    2531 </span>                :            : @param dst Destination image. It will have same size and type as src.
<span class="lineNum">    2532 </span>                :            : @param center The transformation center; where the output precision is maximal
<span class="lineNum">    2533 </span>                :            : @param M Magnitude scale parameter. It determines the radius of the bounding circle to transform too.
<span class="lineNum">    2534 </span>                :            : @param flags A combination of interpolation methods, see #InterpolationFlags
<span class="lineNum">    2535 </span>                :            : 
<span class="lineNum">    2536 </span>                :            : @note
<span class="lineNum">    2537 </span>                :            : -   The function can not operate in-place.
<span class="lineNum">    2538 </span>                :            : -   To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.
<span class="lineNum">    2539 </span>                :            : 
<span class="lineNum">    2540 </span>                :            : @sa cv::linearPolar
<span class="lineNum">    2541 </span>                :            : @endinternal
<span class="lineNum">    2542 </span>                :            : */
<span class="lineNum">    2543 </span>                :            : CV_EXPORTS_W void logPolar( InputArray src, OutputArray dst,
<span class="lineNum">    2544 </span>                :            :                             Point2f center, double M, int flags );
<span class="lineNum">    2545 </span>                :            : 
<span class="lineNum">    2546 </span>                :            : /** @brief Remaps an image to polar coordinates space.
<span class="lineNum">    2547 </span>                :            : 
<span class="lineNum">    2548 </span>                :            : @deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags)
<span class="lineNum">    2549 </span>                :            : 
<span class="lineNum">    2550 </span>                :            : @internal
<span class="lineNum">    2551 </span>                :            : Transform the source image using the following transformation (See @ref polar_remaps_reference_image &quot;Polar remaps reference image c)&quot;):
<span class="lineNum">    2552 </span>                :            : \f[\begin{array}{l}
<span class="lineNum">    2553 </span>                :            :   dst( \rho , \phi ) = src(x,y) \\
<span class="lineNum">    2554 </span>                :            :   dst.size() \leftarrow src.size()
<span class="lineNum">    2555 </span>                :            : \end{array}\f]
<span class="lineNum">    2556 </span>                :            : 
<span class="lineNum">    2557 </span>                :            : where
<span class="lineNum">    2558 </span>                :            : \f[\begin{array}{l}
<span class="lineNum">    2559 </span>                :            :   I = (dx,dy) = (x - center.x,y - center.y) \\
<span class="lineNum">    2560 </span>                :            :   \rho = Kmag \cdot \texttt{magnitude} (I) ,\\
<span class="lineNum">    2561 </span>                :            :   \phi = angle \cdot \texttt{angle} (I)
<span class="lineNum">    2562 </span>                :            : \end{array}\f]
<span class="lineNum">    2563 </span>                :            : 
<span class="lineNum">    2564 </span>                :            : and
<span class="lineNum">    2565 </span>                :            : \f[\begin{array}{l}
<span class="lineNum">    2566 </span>                :            :   Kx = src.cols / maxRadius \\
<span class="lineNum">    2567 </span>                :            :   Ky = src.rows / 2\Pi
<span class="lineNum">    2568 </span>                :            : \end{array}\f]
<span class="lineNum">    2569 </span>                :            : 
<span class="lineNum">    2570 </span>                :            : 
<span class="lineNum">    2571 </span>                :            : @param src Source image
<span class="lineNum">    2572 </span>                :            : @param dst Destination image. It will have same size and type as src.
<span class="lineNum">    2573 </span>                :            : @param center The transformation center;
<span class="lineNum">    2574 </span>                :            : @param maxRadius The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.
<span class="lineNum">    2575 </span>                :            : @param flags A combination of interpolation methods, see #InterpolationFlags
<span class="lineNum">    2576 </span>                :            : 
<span class="lineNum">    2577 </span>                :            : @note
<span class="lineNum">    2578 </span>                :            : -   The function can not operate in-place.
<span class="lineNum">    2579 </span>                :            : -   To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.
<span class="lineNum">    2580 </span>                :            : 
<span class="lineNum">    2581 </span>                :            : @sa cv::logPolar
<span class="lineNum">    2582 </span>                :            : @endinternal
<span class="lineNum">    2583 </span>                :            : */
<span class="lineNum">    2584 </span>                :            : CV_EXPORTS_W void linearPolar( InputArray src, OutputArray dst,
<span class="lineNum">    2585 </span>                :            :                                Point2f center, double maxRadius, int flags );
<span class="lineNum">    2586 </span>                :            : 
<span class="lineNum">    2587 </span>                :            : 
<span class="lineNum">    2588 </span>                :            : /** \brief Remaps an image to polar or semilog-polar coordinates space
<span class="lineNum">    2589 </span>                :            : 
<span class="lineNum">    2590 </span>                :            : @anchor polar_remaps_reference_image
<span class="lineNum">    2591 </span>                :            : ![Polar remaps reference](pics/polar_remap_doc.png)
<span class="lineNum">    2592 </span>                :            : 
<span class="lineNum">    2593 </span>                :            : Transform the source image using the following transformation:
<span class="lineNum">    2594 </span>                :            : \f[
<span class="lineNum">    2595 </span>                :            : dst(\rho , \phi ) = src(x,y)
<span class="lineNum">    2596 </span>                :            : \f]
<span class="lineNum">    2597 </span>                :            : 
<span class="lineNum">    2598 </span>                :            : where
<span class="lineNum">    2599 </span>                :            : \f[
<span class="lineNum">    2600 </span>                :            : \begin{array}{l}
<span class="lineNum">    2601 </span>                :            : \vec{I} = (x - center.x, \;y - center.y) \\
<span class="lineNum">    2602 </span>                :            : \phi = Kangle \cdot \texttt{angle} (\vec{I}) \\
<span class="lineNum">    2603 </span>                :            : \rho = \left\{\begin{matrix}
<span class="lineNum">    2604 </span>                :            : Klin \cdot \texttt{magnitude} (\vec{I}) &amp; default \\
<span class="lineNum">    2605 </span>                :            : Klog \cdot log_e(\texttt{magnitude} (\vec{I})) &amp; if \; semilog \\
<span class="lineNum">    2606 </span>                :            : \end{matrix}\right.
<span class="lineNum">    2607 </span>                :            : \end{array}
<span class="lineNum">    2608 </span>                :            : \f]
<span class="lineNum">    2609 </span>                :            : 
<span class="lineNum">    2610 </span>                :            : and
<span class="lineNum">    2611 </span>                :            : \f[
<span class="lineNum">    2612 </span>                :            : \begin{array}{l}
<span class="lineNum">    2613 </span>                :            : Kangle = dsize.height / 2\Pi \\
<span class="lineNum">    2614 </span>                :            : Klin = dsize.width / maxRadius \\
<span class="lineNum">    2615 </span>                :            : Klog = dsize.width / log_e(maxRadius) \\
<span class="lineNum">    2616 </span>                :            : \end{array}
<span class="lineNum">    2617 </span>                :            : \f]
<span class="lineNum">    2618 </span>                :            : 
<span class="lineNum">    2619 </span>                :            : 
<span class="lineNum">    2620 </span>                :            : \par Linear vs semilog mapping
<span class="lineNum">    2621 </span>                :            : 
<span class="lineNum">    2622 </span>                :            : Polar mapping can be linear or semi-log. Add one of #WarpPolarMode to `flags` to specify the polar mapping mode.
<span class="lineNum">    2623 </span>                :            : 
<span class="lineNum">    2624 </span>                :            : Linear is the default mode.
<span class="lineNum">    2625 </span>                :            : 
<span class="lineNum">    2626 </span>                :            : The semilog mapping emulates the human &quot;foveal&quot; vision that permit very high acuity on the line of sight (central vision)
<span class="lineNum">    2627 </span>                :            : in contrast to peripheral vision where acuity is minor.
<span class="lineNum">    2628 </span>                :            : 
<span class="lineNum">    2629 </span>                :            : \par Option on `dsize`:
<span class="lineNum">    2630 </span>                :            : 
<span class="lineNum">    2631 </span>                :            : - if both values in `dsize &lt;=0 ` (default),
<span class="lineNum">    2632 </span>                :            : the destination image will have (almost) same area of source bounding circle:
<span class="lineNum">    2633 </span>                :            : \f[\begin{array}{l}
<span class="lineNum">    2634 </span>                :            : dsize.area  \leftarrow (maxRadius^2 \cdot \Pi) \\
<span class="lineNum">    2635 </span>                :            : dsize.width = \texttt{cvRound}(maxRadius) \\
<span class="lineNum">    2636 </span>                :            : dsize.height = \texttt{cvRound}(maxRadius \cdot \Pi) \\
<span class="lineNum">    2637 </span>                :            : \end{array}\f]
<span class="lineNum">    2638 </span>                :            : 
<span class="lineNum">    2639 </span>                :            : 
<span class="lineNum">    2640 </span>                :            : - if only `dsize.height &lt;= 0`,
<span class="lineNum">    2641 </span>                :            : the destination image area will be proportional to the bounding circle area but scaled by `Kx * Kx`:
<span class="lineNum">    2642 </span>                :            : \f[\begin{array}{l}
<span class="lineNum">    2643 </span>                :            : dsize.height = \texttt{cvRound}(dsize.width \cdot \Pi) \\
<span class="lineNum">    2644 </span>                :            : \end{array}
<span class="lineNum">    2645 </span>                :            : \f]
<span class="lineNum">    2646 </span>                :            : 
<span class="lineNum">    2647 </span>                :            : - if both values in `dsize &gt; 0 `,
<span class="lineNum">    2648 </span>                :            : the destination image will have the given size therefore the area of the bounding circle will be scaled to `dsize`.
<span class="lineNum">    2649 </span>                :            : 
<span class="lineNum">    2650 </span>                :            : 
<span class="lineNum">    2651 </span>                :            : \par Reverse mapping
<span class="lineNum">    2652 </span>                :            : 
<span class="lineNum">    2653 </span>                :            : You can get reverse mapping adding #WARP_INVERSE_MAP to `flags`
<span class="lineNum">    2654 </span>                :            : \snippet polar_transforms.cpp InverseMap
<span class="lineNum">    2655 </span>                :            : 
<span class="lineNum">    2656 </span>                :            : In addiction, to calculate the original coordinate from a polar mapped coordinate \f$(rho, phi)-&gt;(x, y)\f$:
<span class="lineNum">    2657 </span>                :            : \snippet polar_transforms.cpp InverseCoordinate
<span class="lineNum">    2658 </span>                :            : 
<span class="lineNum">    2659 </span>                :            : @param src Source image.
<span class="lineNum">    2660 </span>                :            : @param dst Destination image. It will have same type as src.
<span class="lineNum">    2661 </span>                :            : @param dsize The destination image size (see description for valid options).
<span class="lineNum">    2662 </span>                :            : @param center The transformation center.
<span class="lineNum">    2663 </span>                :            : @param maxRadius The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.
<span class="lineNum">    2664 </span>                :            : @param flags A combination of interpolation methods, #InterpolationFlags + #WarpPolarMode.
<span class="lineNum">    2665 </span>                :            :             - Add #WARP_POLAR_LINEAR to select linear polar mapping (default)
<span class="lineNum">    2666 </span>                :            :             - Add #WARP_POLAR_LOG to select semilog polar mapping
<span class="lineNum">    2667 </span>                :            :             - Add #WARP_INVERSE_MAP for reverse mapping.
<span class="lineNum">    2668 </span>                :            : @note
<span class="lineNum">    2669 </span>                :            : -  The function can not operate in-place.
<span class="lineNum">    2670 </span>                :            : -  To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.
<span class="lineNum">    2671 </span>                :            : -  This function uses #remap. Due to current implementation limitations the size of an input and output images should be less than 32767x32767.
<span class="lineNum">    2672 </span>                :            : 
<span class="lineNum">    2673 </span>                :            : @sa cv::remap
<span class="lineNum">    2674 </span>                :            : */
<span class="lineNum">    2675 </span>                :            : CV_EXPORTS_W void warpPolar(InputArray src, OutputArray dst, Size dsize,
<span class="lineNum">    2676 </span>                :            :                             Point2f center, double maxRadius, int flags);
<span class="lineNum">    2677 </span>                :            : 
<span class="lineNum">    2678 </span>                :            : 
<span class="lineNum">    2679 </span>                :            : //! @} imgproc_transform
<span class="lineNum">    2680 </span>                :            : 
<span class="lineNum">    2681 </span>                :            : //! @addtogroup imgproc_misc
<span class="lineNum">    2682 </span>                :            : //! @{
<span class="lineNum">    2683 </span>                :            : 
<span class="lineNum">    2684 </span>                :            : /** @overload */
<span class="lineNum">    2685 </span>                :            : CV_EXPORTS_W void integral( InputArray src, OutputArray sum, int sdepth = -1 );
<span class="lineNum">    2686 </span>                :            : 
<span class="lineNum">    2687 </span>                :            : /** @overload */
<span class="lineNum">    2688 </span>                :            : CV_EXPORTS_AS(integral2) void integral( InputArray src, OutputArray sum,
<span class="lineNum">    2689 </span>                :            :                                         OutputArray sqsum, int sdepth = -1, int sqdepth = -1 );
<span class="lineNum">    2690 </span>                :            : 
<span class="lineNum">    2691 </span>                :            : /** @brief Calculates the integral of an image.
<span class="lineNum">    2692 </span>                :            : 
<span class="lineNum">    2693 </span>                :            : The function calculates one or more integral images for the source image as follows:
<span class="lineNum">    2694 </span>                :            : 
<span class="lineNum">    2695 </span>                :            : \f[\texttt{sum} (X,Y) =  \sum _{x&lt;X,y&lt;Y}  \texttt{image} (x,y)\f]
<span class="lineNum">    2696 </span>                :            : 
<span class="lineNum">    2697 </span>                :            : \f[\texttt{sqsum} (X,Y) =  \sum _{x&lt;X,y&lt;Y}  \texttt{image} (x,y)^2\f]
<span class="lineNum">    2698 </span>                :            : 
<span class="lineNum">    2699 </span>                :            : \f[\texttt{tilted} (X,Y) =  \sum _{y&lt;Y,abs(x-X+1) \leq Y-y-1}  \texttt{image} (x,y)\f]
<span class="lineNum">    2700 </span>                :            : 
<span class="lineNum">    2701 </span>                :            : Using these integral images, you can calculate sum, mean, and standard deviation over a specific
<span class="lineNum">    2702 </span>                :            : up-right or rotated rectangular region of the image in a constant time, for example:
<span class="lineNum">    2703 </span>                :            : 
<span class="lineNum">    2704 </span>                :            : \f[\sum _{x_1 \leq x &lt; x_2,  \, y_1  \leq y &lt; y_2}  \texttt{image} (x,y) =  \texttt{sum} (x_2,y_2)- \texttt{sum} (x_1,y_2)- \texttt{sum} (x_2,y_1)+ \texttt{sum} (x_1,y_1)\f]
<span class="lineNum">    2705 </span>                :            : 
<span class="lineNum">    2706 </span>                :            : It makes possible to do a fast blurring or fast block correlation with a variable window size, for
<span class="lineNum">    2707 </span>                :            : example. In case of multi-channel images, sums for each channel are accumulated independently.
<span class="lineNum">    2708 </span>                :            : 
<span class="lineNum">    2709 </span>                :            : As a practical example, the next figure shows the calculation of the integral of a straight
<span class="lineNum">    2710 </span>                :            : rectangle Rect(3,3,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the
<span class="lineNum">    2711 </span>                :            : original image are shown, as well as the relative pixels in the integral images sum and tilted .
<span class="lineNum">    2712 </span>                :            : 
<span class="lineNum">    2713 </span>                :            : ![integral calculation example](pics/integral.png)
<span class="lineNum">    2714 </span>                :            : 
<span class="lineNum">    2715 </span>                :            : @param src input image as \f$W \times H\f$, 8-bit or floating-point (32f or 64f).
<span class="lineNum">    2716 </span>                :            : @param sum integral image as \f$(W+1)\times (H+1)\f$ , 32-bit integer or floating-point (32f or 64f).
<span class="lineNum">    2717 </span>                :            : @param sqsum integral image for squared pixel values; it is \f$(W+1)\times (H+1)\f$, double-precision
<span class="lineNum">    2718 </span>                :            : floating-point (64f) array.
<span class="lineNum">    2719 </span>                :            : @param tilted integral for the image rotated by 45 degrees; it is \f$(W+1)\times (H+1)\f$ array with
<span class="lineNum">    2720 </span>                :            : the same data type as sum.
<span class="lineNum">    2721 </span>                :            : @param sdepth desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or
<span class="lineNum">    2722 </span>                :            : CV_64F.
<span class="lineNum">    2723 </span>                :            : @param sqdepth desired depth of the integral image of squared pixel values, CV_32F or CV_64F.
<span class="lineNum">    2724 </span>                :            :  */
<span class="lineNum">    2725 </span>                :            : CV_EXPORTS_AS(integral3) void integral( InputArray src, OutputArray sum,
<span class="lineNum">    2726 </span>                :            :                                         OutputArray sqsum, OutputArray tilted,
<span class="lineNum">    2727 </span>                :            :                                         int sdepth = -1, int sqdepth = -1 );
<span class="lineNum">    2728 </span>                :            : 
<span class="lineNum">    2729 </span>                :            : //! @} imgproc_misc
<span class="lineNum">    2730 </span>                :            : 
<span class="lineNum">    2731 </span>                :            : //! @addtogroup imgproc_motion
<span class="lineNum">    2732 </span>                :            : //! @{
<span class="lineNum">    2733 </span>                :            : 
<span class="lineNum">    2734 </span>                :            : /** @brief Adds an image to the accumulator image.
<span class="lineNum">    2735 </span>                :            : 
<span class="lineNum">    2736 </span>                :            : The function adds src or some of its elements to dst :
<span class="lineNum">    2737 </span>                :            : 
<span class="lineNum">    2738 </span>                :            : \f[\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\f]
<span class="lineNum">    2739 </span>                :            : 
<span class="lineNum">    2740 </span>                :            : The function supports multi-channel images. Each channel is processed independently.
<span class="lineNum">    2741 </span>                :            : 
<span class="lineNum">    2742 </span>                :            : The function cv::accumulate can be used, for example, to collect statistics of a scene background
<span class="lineNum">    2743 </span>                :            : viewed by a still camera and for the further foreground-background segmentation.
<span class="lineNum">    2744 </span>                :            : 
<span class="lineNum">    2745 </span>                :            : @param src Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or CV_64FC(n), where n is a positive integer.
<span class="lineNum">    2746 </span>                :            : @param dst %Accumulator image with the same number of channels as input image, and a depth of CV_32F or CV_64F.
<span class="lineNum">    2747 </span>                :            : @param mask Optional operation mask.
<span class="lineNum">    2748 </span>                :            : 
<span class="lineNum">    2749 </span>                :            : @sa  accumulateSquare, accumulateProduct, accumulateWeighted
<span class="lineNum">    2750 </span>                :            :  */
<span class="lineNum">    2751 </span>                :            : CV_EXPORTS_W void accumulate( InputArray src, InputOutputArray dst,
<span class="lineNum">    2752 </span>                :            :                               InputArray mask = noArray() );
<span class="lineNum">    2753 </span>                :            : 
<span class="lineNum">    2754 </span>                :            : /** @brief Adds the square of a source image to the accumulator image.
<span class="lineNum">    2755 </span>                :            : 
<span class="lineNum">    2756 </span>                :            : The function adds the input image src or its selected region, raised to a power of 2, to the
<span class="lineNum">    2757 </span>                :            : accumulator dst :
<span class="lineNum">    2758 </span>                :            : 
<span class="lineNum">    2759 </span>                :            : \f[\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src} (x,y)^2  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\f]
<span class="lineNum">    2760 </span>                :            : 
<span class="lineNum">    2761 </span>                :            : The function supports multi-channel images. Each channel is processed independently.
<span class="lineNum">    2762 </span>                :            : 
<span class="lineNum">    2763 </span>                :            : @param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point.
<span class="lineNum">    2764 </span>                :            : @param dst %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
<span class="lineNum">    2765 </span>                :            : floating-point.
<span class="lineNum">    2766 </span>                :            : @param mask Optional operation mask.
<span class="lineNum">    2767 </span>                :            : 
<span class="lineNum">    2768 </span>                :            : @sa  accumulateSquare, accumulateProduct, accumulateWeighted
<span class="lineNum">    2769 </span>                :            :  */
<span class="lineNum">    2770 </span>                :            : CV_EXPORTS_W void accumulateSquare( InputArray src, InputOutputArray dst,
<span class="lineNum">    2771 </span>                :            :                                     InputArray mask = noArray() );
<span class="lineNum">    2772 </span>                :            : 
<span class="lineNum">    2773 </span>                :            : /** @brief Adds the per-element product of two input images to the accumulator image.
<span class="lineNum">    2774 </span>                :            : 
<span class="lineNum">    2775 </span>                :            : The function adds the product of two images or their selected regions to the accumulator dst :
<span class="lineNum">    2776 </span>                :            : 
<span class="lineNum">    2777 </span>                :            : \f[\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src1} (x,y)  \cdot \texttt{src2} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\f]
<span class="lineNum">    2778 </span>                :            : 
<span class="lineNum">    2779 </span>                :            : The function supports multi-channel images. Each channel is processed independently.
<span class="lineNum">    2780 </span>                :            : 
<span class="lineNum">    2781 </span>                :            : @param src1 First input image, 1- or 3-channel, 8-bit or 32-bit floating point.
<span class="lineNum">    2782 </span>                :            : @param src2 Second input image of the same type and the same size as src1 .
<span class="lineNum">    2783 </span>                :            : @param dst %Accumulator image with the same number of channels as input images, 32-bit or 64-bit
<span class="lineNum">    2784 </span>                :            : floating-point.
<span class="lineNum">    2785 </span>                :            : @param mask Optional operation mask.
<span class="lineNum">    2786 </span>                :            : 
<span class="lineNum">    2787 </span>                :            : @sa  accumulate, accumulateSquare, accumulateWeighted
<span class="lineNum">    2788 </span>                :            :  */
<span class="lineNum">    2789 </span>                :            : CV_EXPORTS_W void accumulateProduct( InputArray src1, InputArray src2,
<span class="lineNum">    2790 </span>                :            :                                      InputOutputArray dst, InputArray mask=noArray() );
<span class="lineNum">    2791 </span>                :            : 
<span class="lineNum">    2792 </span>                :            : /** @brief Updates a running average.
<span class="lineNum">    2793 </span>                :            : 
<span class="lineNum">    2794 </span>                :            : The function calculates the weighted sum of the input image src and the accumulator dst so that dst
<span class="lineNum">    2795 </span>                :            : becomes a running average of a frame sequence:
<span class="lineNum">    2796 </span>                :            : 
<span class="lineNum">    2797 </span>                :            : \f[\texttt{dst} (x,y)  \leftarrow (1- \texttt{alpha} )  \cdot \texttt{dst} (x,y) +  \texttt{alpha} \cdot \texttt{src} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\f]
<span class="lineNum">    2798 </span>                :            : 
<span class="lineNum">    2799 </span>                :            : That is, alpha regulates the update speed (how fast the accumulator &quot;forgets&quot; about earlier images).
<span class="lineNum">    2800 </span>                :            : The function supports multi-channel images. Each channel is processed independently.
<span class="lineNum">    2801 </span>                :            : 
<span class="lineNum">    2802 </span>                :            : @param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point.
<span class="lineNum">    2803 </span>                :            : @param dst %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
<span class="lineNum">    2804 </span>                :            : floating-point.
<span class="lineNum">    2805 </span>                :            : @param alpha Weight of the input image.
<span class="lineNum">    2806 </span>                :            : @param mask Optional operation mask.
<span class="lineNum">    2807 </span>                :            : 
<span class="lineNum">    2808 </span>                :            : @sa  accumulate, accumulateSquare, accumulateProduct
<span class="lineNum">    2809 </span>                :            :  */
<span class="lineNum">    2810 </span>                :            : CV_EXPORTS_W void accumulateWeighted( InputArray src, InputOutputArray dst,
<span class="lineNum">    2811 </span>                :            :                                       double alpha, InputArray mask = noArray() );
<span class="lineNum">    2812 </span>                :            : 
<span class="lineNum">    2813 </span>                :            : /** @brief The function is used to detect translational shifts that occur between two images.
<span class="lineNum">    2814 </span>                :            : 
<span class="lineNum">    2815 </span>                :            : The operation takes advantage of the Fourier shift theorem for detecting the translational shift in
<span class="lineNum">    2816 </span>                :            : the frequency domain. It can be used for fast image registration as well as motion estimation. For
<span class="lineNum">    2817 </span>                :            : more information please see &lt;http://en.wikipedia.org/wiki/Phase_correlation&gt;
<span class="lineNum">    2818 </span>                :            : 
<span class="lineNum">    2819 </span>                :            : Calculates the cross-power spectrum of two supplied source arrays. The arrays are padded if needed
<span class="lineNum">    2820 </span>                :            : with getOptimalDFTSize.
<span class="lineNum">    2821 </span>                :            : 
<span class="lineNum">    2822 </span>                :            : The function performs the following equations:
<span class="lineNum">    2823 </span>                :            : - First it applies a Hanning window (see &lt;http://en.wikipedia.org/wiki/Hann_function&gt;) to each
<span class="lineNum">    2824 </span>                :            : image to remove possible edge effects. This window is cached until the array size changes to speed
<span class="lineNum">    2825 </span>                :            : up processing time.
<span class="lineNum">    2826 </span>                :            : - Next it computes the forward DFTs of each source array:
<span class="lineNum">    2827 </span>                :            : \f[\mathbf{G}_a = \mathcal{F}\{src_1\}, \; \mathbf{G}_b = \mathcal{F}\{src_2\}\f]
<span class="lineNum">    2828 </span>                :            : where \f$\mathcal{F}\f$ is the forward DFT.
<span class="lineNum">    2829 </span>                :            : - It then computes the cross-power spectrum of each frequency domain array:
<span class="lineNum">    2830 </span>                :            : \f[R = \frac{ \mathbf{G}_a \mathbf{G}_b^*}{|\mathbf{G}_a \mathbf{G}_b^*|}\f]
<span class="lineNum">    2831 </span>                :            : - Next the cross-correlation is converted back into the time domain via the inverse DFT:
<span class="lineNum">    2832 </span>                :            : \f[r = \mathcal{F}^{-1}\{R\}\f]
<span class="lineNum">    2833 </span>                :            : - Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to
<span class="lineNum">    2834 </span>                :            : achieve sub-pixel accuracy.
<span class="lineNum">    2835 </span>                :            : \f[(\Delta x, \Delta y) = \texttt{weightedCentroid} \{\arg \max_{(x, y)}\{r\}\}\f]
<span class="lineNum">    2836 </span>                :            : - If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5
<span class="lineNum">    2837 </span>                :            : centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single
<span class="lineNum">    2838 </span>                :            : peak) and will be smaller when there are multiple peaks.
<span class="lineNum">    2839 </span>                :            : 
<span class="lineNum">    2840 </span>                :            : @param src1 Source floating point array (CV_32FC1 or CV_64FC1)
<span class="lineNum">    2841 </span>                :            : @param src2 Source floating point array (CV_32FC1 or CV_64FC1)
<span class="lineNum">    2842 </span>                :            : @param window Floating point array with windowing coefficients to reduce edge effects (optional).
<span class="lineNum">    2843 </span>                :            : @param response Signal power within the 5x5 centroid around the peak, between 0 and 1 (optional).
<span class="lineNum">    2844 </span>                :            : @returns detected phase shift (sub-pixel) between the two arrays.
<span class="lineNum">    2845 </span>                :            : 
<span class="lineNum">    2846 </span>                :            : @sa dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow
<span class="lineNum">    2847 </span>                :            :  */
<span class="lineNum">    2848 </span>                :            : CV_EXPORTS_W Point2d phaseCorrelate(InputArray src1, InputArray src2,
<span class="lineNum">    2849 </span>                :            :                                     InputArray window = noArray(), CV_OUT double* response = 0);
<span class="lineNum">    2850 </span>                :            : 
<span class="lineNum">    2851 </span>                :            : /** @brief This function computes a Hanning window coefficients in two dimensions.
<span class="lineNum">    2852 </span>                :            : 
<span class="lineNum">    2853 </span>                :            : See (http://en.wikipedia.org/wiki/Hann_function) and (http://en.wikipedia.org/wiki/Window_function)
<span class="lineNum">    2854 </span>                :            : for more information.
<span class="lineNum">    2855 </span>                :            : 
<span class="lineNum">    2856 </span>                :            : An example is shown below:
<span class="lineNum">    2857 </span>                :            : @code
<span class="lineNum">    2858 </span>                :            :     // create hanning window of size 100x100 and type CV_32F
<span class="lineNum">    2859 </span>                :            :     Mat hann;
<span class="lineNum">    2860 </span>                :            :     createHanningWindow(hann, Size(100, 100), CV_32F);
<span class="lineNum">    2861 </span>                :            : @endcode
<span class="lineNum">    2862 </span>                :            : @param dst Destination array to place Hann coefficients in
<span class="lineNum">    2863 </span>                :            : @param winSize The window size specifications (both width and height must be &gt; 1)
<span class="lineNum">    2864 </span>                :            : @param type Created array type
<span class="lineNum">    2865 </span>                :            :  */
<span class="lineNum">    2866 </span>                :            : CV_EXPORTS_W void createHanningWindow(OutputArray dst, Size winSize, int type);
<span class="lineNum">    2867 </span>                :            : 
<span class="lineNum">    2868 </span>                :            : //! @} imgproc_motion
<span class="lineNum">    2869 </span>                :            : 
<span class="lineNum">    2870 </span>                :            : //! @addtogroup imgproc_misc
<span class="lineNum">    2871 </span>                :            : //! @{
<span class="lineNum">    2872 </span>                :            : 
<span class="lineNum">    2873 </span>                :            : /** @brief Applies a fixed-level threshold to each array element.
<span class="lineNum">    2874 </span>                :            : 
<span class="lineNum">    2875 </span>                :            : The function applies fixed-level thresholding to a multiple-channel array. The function is typically
<span class="lineNum">    2876 </span>                :            : used to get a bi-level (binary) image out of a grayscale image ( #compare could be also used for
<span class="lineNum">    2877 </span>                :            : this purpose) or for removing a noise, that is, filtering out pixels with too small or too large
<span class="lineNum">    2878 </span>                :            : values. There are several types of thresholding supported by the function. They are determined by
<span class="lineNum">    2879 </span>                :            : type parameter.
<span class="lineNum">    2880 </span>                :            : 
<span class="lineNum">    2881 </span>                :            : Also, the special values #THRESH_OTSU or #THRESH_TRIANGLE may be combined with one of the
<span class="lineNum">    2882 </span>                :            : above values. In these cases, the function determines the optimal threshold value using the Otsu's
<span class="lineNum">    2883 </span>                :            : or Triangle algorithm and uses it instead of the specified thresh.
<span class="lineNum">    2884 </span>                :            : 
<span class="lineNum">    2885 </span>                :            : @note Currently, the Otsu's and Triangle methods are implemented only for 8-bit single-channel images.
<span class="lineNum">    2886 </span>                :            : 
<span class="lineNum">    2887 </span>                :            : @param src input array (multiple-channel, 8-bit or 32-bit floating point).
<span class="lineNum">    2888 </span>                :            : @param dst output array of the same size  and type and the same number of channels as src.
<span class="lineNum">    2889 </span>                :            : @param thresh threshold value.
<span class="lineNum">    2890 </span>                :            : @param maxval maximum value to use with the #THRESH_BINARY and #THRESH_BINARY_INV thresholding
<span class="lineNum">    2891 </span>                :            : types.
<span class="lineNum">    2892 </span>                :            : @param type thresholding type (see #ThresholdTypes).
<span class="lineNum">    2893 </span>                :            : @return the computed threshold value if Otsu's or Triangle methods used.
<span class="lineNum">    2894 </span>                :            : 
<span class="lineNum">    2895 </span>                :            : @sa  adaptiveThreshold, findContours, compare, min, max
<span class="lineNum">    2896 </span>                :            :  */
<span class="lineNum">    2897 </span>                :            : CV_EXPORTS_W double threshold( InputArray src, OutputArray dst,
<span class="lineNum">    2898 </span>                :            :                                double thresh, double maxval, int type );
<span class="lineNum">    2899 </span>                :            : 
<span class="lineNum">    2900 </span>                :            : 
<span class="lineNum">    2901 </span>                :            : /** @brief Applies an adaptive threshold to an array.
<span class="lineNum">    2902 </span>                :            : 
<span class="lineNum">    2903 </span>                :            : The function transforms a grayscale image to a binary image according to the formulae:
<span class="lineNum">    2904 </span>                :            : -   **THRESH_BINARY**
<span class="lineNum">    2905 </span>                :            :     \f[dst(x,y) =  \fork{\texttt{maxValue}}{if \(src(x,y) &gt; T(x,y)\)}{0}{otherwise}\f]
<span class="lineNum">    2906 </span>                :            : -   **THRESH_BINARY_INV**
<span class="lineNum">    2907 </span>                :            :     \f[dst(x,y) =  \fork{0}{if \(src(x,y) &gt; T(x,y)\)}{\texttt{maxValue}}{otherwise}\f]
<span class="lineNum">    2908 </span>                :            : where \f$T(x,y)\f$ is a threshold calculated individually for each pixel (see adaptiveMethod parameter).
<span class="lineNum">    2909 </span>                :            : 
<span class="lineNum">    2910 </span>                :            : The function can process the image in-place.
<span class="lineNum">    2911 </span>                :            : 
<span class="lineNum">    2912 </span>                :            : @param src Source 8-bit single-channel image.
<span class="lineNum">    2913 </span>                :            : @param dst Destination image of the same size and the same type as src.
<span class="lineNum">    2914 </span>                :            : @param maxValue Non-zero value assigned to the pixels for which the condition is satisfied
<span class="lineNum">    2915 </span>                :            : @param adaptiveMethod Adaptive thresholding algorithm to use, see #AdaptiveThresholdTypes.
<span class="lineNum">    2916 </span>                :            : The #BORDER_REPLICATE | #BORDER_ISOLATED is used to process boundaries.
<span class="lineNum">    2917 </span>                :            : @param thresholdType Thresholding type that must be either #THRESH_BINARY or #THRESH_BINARY_INV,
<span class="lineNum">    2918 </span>                :            : see #ThresholdTypes.
<span class="lineNum">    2919 </span>                :            : @param blockSize Size of a pixel neighborhood that is used to calculate a threshold value for the
<span class="lineNum">    2920 </span>                :            : pixel: 3, 5, 7, and so on.
<span class="lineNum">    2921 </span>                :            : @param C Constant subtracted from the mean or weighted mean (see the details below). Normally, it
<span class="lineNum">    2922 </span>                :            : is positive but may be zero or negative as well.
<span class="lineNum">    2923 </span>                :            : 
<span class="lineNum">    2924 </span>                :            : @sa  threshold, blur, GaussianBlur
<span class="lineNum">    2925 </span>                :            :  */
<span class="lineNum">    2926 </span>                :            : CV_EXPORTS_W void adaptiveThreshold( InputArray src, OutputArray dst,
<span class="lineNum">    2927 </span>                :            :                                      double maxValue, int adaptiveMethod,
<span class="lineNum">    2928 </span>                :            :                                      int thresholdType, int blockSize, double C );
<span class="lineNum">    2929 </span>                :            : 
<span class="lineNum">    2930 </span>                :            : //! @} imgproc_misc
<span class="lineNum">    2931 </span>                :            : 
<span class="lineNum">    2932 </span>                :            : //! @addtogroup imgproc_filter
<span class="lineNum">    2933 </span>                :            : //! @{
<span class="lineNum">    2934 </span>                :            : 
<span class="lineNum">    2935 </span>                :            : /** @example samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp
<span class="lineNum">    2936 </span>                :            : An example using pyrDown and pyrUp functions
<span class="lineNum">    2937 </span>                :            : */
<span class="lineNum">    2938 </span>                :            : 
<span class="lineNum">    2939 </span>                :            : /** @brief Blurs an image and downsamples it.
<span class="lineNum">    2940 </span>                :            : 
<span class="lineNum">    2941 </span>                :            : By default, size of the output image is computed as `Size((src.cols+1)/2, (src.rows+1)/2)`, but in
<span class="lineNum">    2942 </span>                :            : any case, the following conditions should be satisfied:
<span class="lineNum">    2943 </span>                :            : 
<span class="lineNum">    2944 </span>                :            : \f[\begin{array}{l} | \texttt{dstsize.width} *2-src.cols| \leq 2 \\ | \texttt{dstsize.height} *2-src.rows| \leq 2 \end{array}\f]
<span class="lineNum">    2945 </span>                :            : 
<span class="lineNum">    2946 </span>                :            : The function performs the downsampling step of the Gaussian pyramid construction. First, it
<span class="lineNum">    2947 </span>                :            : convolves the source image with the kernel:
<span class="lineNum">    2948 </span>                :            : 
<span class="lineNum">    2949 </span>                :            : \f[\frac{1}{256} \begin{bmatrix} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \end{bmatrix}\f]
<span class="lineNum">    2950 </span>                :            : 
<span class="lineNum">    2951 </span>                :            : Then, it downsamples the image by rejecting even rows and columns.
<span class="lineNum">    2952 </span>                :            : 
<span class="lineNum">    2953 </span>                :            : @param src input image.
<span class="lineNum">    2954 </span>                :            : @param dst output image; it has the specified size and the same type as src.
<span class="lineNum">    2955 </span>                :            : @param dstsize size of the output image.
<span class="lineNum">    2956 </span>                :            : @param borderType Pixel extrapolation method, see #BorderTypes (#BORDER_CONSTANT isn't supported)
<span class="lineNum">    2957 </span>                :            :  */
<span class="lineNum">    2958 </span>                :            : CV_EXPORTS_W void pyrDown( InputArray src, OutputArray dst,
<span class="lineNum">    2959 </span>                :            :                            const Size&amp; dstsize = Size(), int borderType = BORDER_DEFAULT );
<span class="lineNum">    2960 </span>                :            : 
<span class="lineNum">    2961 </span>                :            : /** @brief Upsamples an image and then blurs it.
<span class="lineNum">    2962 </span>                :            : 
<span class="lineNum">    2963 </span>                :            : By default, size of the output image is computed as `Size(src.cols\*2, (src.rows\*2)`, but in any
<span class="lineNum">    2964 </span>                :            : case, the following conditions should be satisfied:
<span class="lineNum">    2965 </span>                :            : 
<span class="lineNum">    2966 </span>                :            : \f[\begin{array}{l} | \texttt{dstsize.width} -src.cols*2| \leq  ( \texttt{dstsize.width}   \mod  2)  \\ | \texttt{dstsize.height} -src.rows*2| \leq  ( \texttt{dstsize.height}   \mod  2) \end{array}\f]
<span class="lineNum">    2967 </span>                :            : 
<span class="lineNum">    2968 </span>                :            : The function performs the upsampling step of the Gaussian pyramid construction, though it can
<span class="lineNum">    2969 </span>                :            : actually be used to construct the Laplacian pyramid. First, it upsamples the source image by
<span class="lineNum">    2970 </span>                :            : injecting even zero rows and columns and then convolves the result with the same kernel as in
<span class="lineNum">    2971 </span>                :            : pyrDown multiplied by 4.
<span class="lineNum">    2972 </span>                :            : 
<span class="lineNum">    2973 </span>                :            : @param src input image.
<span class="lineNum">    2974 </span>                :            : @param dst output image. It has the specified size and the same type as src .
<span class="lineNum">    2975 </span>                :            : @param dstsize size of the output image.
<span class="lineNum">    2976 </span>                :            : @param borderType Pixel extrapolation method, see #BorderTypes (only #BORDER_DEFAULT is supported)
<span class="lineNum">    2977 </span>                :            :  */
<span class="lineNum">    2978 </span>                :            : CV_EXPORTS_W void pyrUp( InputArray src, OutputArray dst,
<span class="lineNum">    2979 </span>                :            :                          const Size&amp; dstsize = Size(), int borderType = BORDER_DEFAULT );
<span class="lineNum">    2980 </span>                :            : 
<span class="lineNum">    2981 </span>                :            : /** @brief Constructs the Gaussian pyramid for an image.
<span class="lineNum">    2982 </span>                :            : 
<span class="lineNum">    2983 </span>                :            : The function constructs a vector of images and builds the Gaussian pyramid by recursively applying
<span class="lineNum">    2984 </span>                :            : pyrDown to the previously built pyramid layers, starting from `dst[0]==src`.
<span class="lineNum">    2985 </span>                :            : 
<span class="lineNum">    2986 </span>                :            : @param src Source image. Check pyrDown for the list of supported types.
<span class="lineNum">    2987 </span>                :            : @param dst Destination vector of maxlevel+1 images of the same type as src. dst[0] will be the
<span class="lineNum">    2988 </span>                :            : same as src. dst[1] is the next pyramid layer, a smoothed and down-sized src, and so on.
<span class="lineNum">    2989 </span>                :            : @param maxlevel 0-based index of the last (the smallest) pyramid layer. It must be non-negative.
<span class="lineNum">    2990 </span>                :            : @param borderType Pixel extrapolation method, see #BorderTypes (#BORDER_CONSTANT isn't supported)
<span class="lineNum">    2991 </span>                :            :  */
<span class="lineNum">    2992 </span>                :            : CV_EXPORTS void buildPyramid( InputArray src, OutputArrayOfArrays dst,
<span class="lineNum">    2993 </span>                :            :                               int maxlevel, int borderType = BORDER_DEFAULT );
<span class="lineNum">    2994 </span>                :            : 
<span class="lineNum">    2995 </span>                :            : //! @} imgproc_filter
<span class="lineNum">    2996 </span>                :            : 
<span class="lineNum">    2997 </span>                :            : //! @addtogroup imgproc_hist
<span class="lineNum">    2998 </span>                :            : //! @{
<span class="lineNum">    2999 </span>                :            : 
<span class="lineNum">    3000 </span>                :            : /** @example samples/cpp/demhist.cpp
<span class="lineNum">    3001 </span>                :            : An example for creating histograms of an image
<span class="lineNum">    3002 </span>                :            : */
<span class="lineNum">    3003 </span>                :            : 
<span class="lineNum">    3004 </span>                :            : /** @brief Calculates a histogram of a set of arrays.
<span class="lineNum">    3005 </span>                :            : 
<span class="lineNum">    3006 </span>                :            : The function cv::calcHist calculates the histogram of one or more arrays. The elements of a tuple used
<span class="lineNum">    3007 </span>                :            : to increment a histogram bin are taken from the corresponding input arrays at the same location. The
<span class="lineNum">    3008 </span>                :            : sample below shows how to compute a 2D Hue-Saturation histogram for a color image. :
<span class="lineNum">    3009 </span>                :            : @include snippets/imgproc_calcHist.cpp
<span class="lineNum">    3010 </span>                :            : 
<span class="lineNum">    3011 </span>                :            : @param images Source arrays. They all should have the same depth, CV_8U, CV_16U or CV_32F , and the same
<span class="lineNum">    3012 </span>                :            : size. Each of them can have an arbitrary number of channels.
<span class="lineNum">    3013 </span>                :            : @param nimages Number of source images.
<span class="lineNum">    3014 </span>                :            : @param channels List of the dims channels used to compute the histogram. The first array channels
<span class="lineNum">    3015 </span>                :            : are numerated from 0 to images[0].channels()-1 , the second array channels are counted from
<span class="lineNum">    3016 </span>                :            : images[0].channels() to images[0].channels() + images[1].channels()-1, and so on.
<span class="lineNum">    3017 </span>                :            : @param mask Optional mask. If the matrix is not empty, it must be an 8-bit array of the same size
<span class="lineNum">    3018 </span>                :            : as images[i] . The non-zero mask elements mark the array elements counted in the histogram.
<span class="lineNum">    3019 </span>                :            : @param hist Output histogram, which is a dense or sparse dims -dimensional array.
<span class="lineNum">    3020 </span>                :            : @param dims Histogram dimensionality that must be positive and not greater than CV_MAX_DIMS
<span class="lineNum">    3021 </span>                :            : (equal to 32 in the current OpenCV version).
<span class="lineNum">    3022 </span>                :            : @param histSize Array of histogram sizes in each dimension.
<span class="lineNum">    3023 </span>                :            : @param ranges Array of the dims arrays of the histogram bin boundaries in each dimension. When the
<span class="lineNum">    3024 </span>                :            : histogram is uniform ( uniform =true), then for each dimension i it is enough to specify the lower
<span class="lineNum">    3025 </span>                :            : (inclusive) boundary \f$L_0\f$ of the 0-th histogram bin and the upper (exclusive) boundary
<span class="lineNum">    3026 </span>                :            : \f$U_{\texttt{histSize}[i]-1}\f$ for the last histogram bin histSize[i]-1 . That is, in case of a
<span class="lineNum">    3027 </span>                :            : uniform histogram each of ranges[i] is an array of 2 elements. When the histogram is not uniform (
<span class="lineNum">    3028 </span>                :            : uniform=false ), then each of ranges[i] contains histSize[i]+1 elements:
<span class="lineNum">    3029 </span>                :            : \f$L_0, U_0=L_1, U_1=L_2, ..., U_{\texttt{histSize[i]}-2}=L_{\texttt{histSize[i]}-1}, U_{\texttt{histSize[i]}-1}\f$
<span class="lineNum">    3030 </span>                :            : . The array elements, that are not between \f$L_0\f$ and \f$U_{\texttt{histSize[i]}-1}\f$ , are not
<span class="lineNum">    3031 </span>                :            : counted in the histogram.
<span class="lineNum">    3032 </span>                :            : @param uniform Flag indicating whether the histogram is uniform or not (see above).
<span class="lineNum">    3033 </span>                :            : @param accumulate Accumulation flag. If it is set, the histogram is not cleared in the beginning
<span class="lineNum">    3034 </span>                :            : when it is allocated. This feature enables you to compute a single histogram from several sets of
<span class="lineNum">    3035 </span>                :            : arrays, or to update the histogram in time.
<span class="lineNum">    3036 </span>                :            : */
<span class="lineNum">    3037 </span>                :            : CV_EXPORTS void calcHist( const Mat* images, int nimages,
<span class="lineNum">    3038 </span>                :            :                           const int* channels, InputArray mask,
<span class="lineNum">    3039 </span>                :            :                           OutputArray hist, int dims, const int* histSize,
<span class="lineNum">    3040 </span>                :            :                           const float** ranges, bool uniform = true, bool accumulate = false );
<span class="lineNum">    3041 </span>                :            : 
<span class="lineNum">    3042 </span>                :            : /** @overload
<span class="lineNum">    3043 </span>                :            : 
<span class="lineNum">    3044 </span>                :            : this variant uses %SparseMat for output
<span class="lineNum">    3045 </span>                :            : */
<span class="lineNum">    3046 </span>                :            : CV_EXPORTS void calcHist( const Mat* images, int nimages,
<span class="lineNum">    3047 </span>                :            :                           const int* channels, InputArray mask,
<span class="lineNum">    3048 </span>                :            :                           SparseMat&amp; hist, int dims,
<span class="lineNum">    3049 </span>                :            :                           const int* histSize, const float** ranges,
<span class="lineNum">    3050 </span>                :            :                           bool uniform = true, bool accumulate = false );
<span class="lineNum">    3051 </span>                :            : 
<span class="lineNum">    3052 </span>                :            : /** @overload */
<span class="lineNum">    3053 </span>                :            : CV_EXPORTS_W void calcHist( InputArrayOfArrays images,
<span class="lineNum">    3054 </span>                :            :                             const std::vector&lt;int&gt;&amp; channels,
<span class="lineNum">    3055 </span>                :            :                             InputArray mask, OutputArray hist,
<span class="lineNum">    3056 </span>                :            :                             const std::vector&lt;int&gt;&amp; histSize,
<span class="lineNum">    3057 </span>                :            :                             const std::vector&lt;float&gt;&amp; ranges,
<span class="lineNum">    3058 </span>                :            :                             bool accumulate = false );
<span class="lineNum">    3059 </span>                :            : 
<span class="lineNum">    3060 </span>                :            : /** @brief Calculates the back projection of a histogram.
<span class="lineNum">    3061 </span>                :            : 
<span class="lineNum">    3062 </span>                :            : The function cv::calcBackProject calculates the back project of the histogram. That is, similarly to
<span class="lineNum">    3063 </span>                :            : #calcHist , at each location (x, y) the function collects the values from the selected channels
<span class="lineNum">    3064 </span>                :            : in the input images and finds the corresponding histogram bin. But instead of incrementing it, the
<span class="lineNum">    3065 </span>                :            : function reads the bin value, scales it by scale , and stores in backProject(x,y) . In terms of
<span class="lineNum">    3066 </span>                :            : statistics, the function computes probability of each element value in respect with the empirical
<span class="lineNum">    3067 </span>                :            : probability distribution represented by the histogram. See how, for example, you can find and track
<span class="lineNum">    3068 </span>                :            : a bright-colored object in a scene:
<span class="lineNum">    3069 </span>                :            : 
<span class="lineNum">    3070 </span>                :            : - Before tracking, show the object to the camera so that it covers almost the whole frame.
<span class="lineNum">    3071 </span>                :            : Calculate a hue histogram. The histogram may have strong maximums, corresponding to the dominant
<span class="lineNum">    3072 </span>                :            : colors in the object.
<span class="lineNum">    3073 </span>                :            : 
<span class="lineNum">    3074 </span>                :            : - When tracking, calculate a back projection of a hue plane of each input video frame using that
<span class="lineNum">    3075 </span>                :            : pre-computed histogram. Threshold the back projection to suppress weak colors. It may also make
<span class="lineNum">    3076 </span>                :            : sense to suppress pixels with non-sufficient color saturation and too dark or too bright pixels.
<span class="lineNum">    3077 </span>                :            : 
<span class="lineNum">    3078 </span>                :            : - Find connected components in the resulting picture and choose, for example, the largest
<span class="lineNum">    3079 </span>                :            : component.
<span class="lineNum">    3080 </span>                :            : 
<span class="lineNum">    3081 </span>                :            : This is an approximate algorithm of the CamShift color object tracker.
<span class="lineNum">    3082 </span>                :            : 
<span class="lineNum">    3083 </span>                :            : @param images Source arrays. They all should have the same depth, CV_8U, CV_16U or CV_32F , and the same
<span class="lineNum">    3084 </span>                :            : size. Each of them can have an arbitrary number of channels.
<span class="lineNum">    3085 </span>                :            : @param nimages Number of source images.
<span class="lineNum">    3086 </span>                :            : @param channels The list of channels used to compute the back projection. The number of channels
<span class="lineNum">    3087 </span>                :            : must match the histogram dimensionality. The first array channels are numerated from 0 to
<span class="lineNum">    3088 </span>                :            : images[0].channels()-1 , the second array channels are counted from images[0].channels() to
<span class="lineNum">    3089 </span>                :            : images[0].channels() + images[1].channels()-1, and so on.
<span class="lineNum">    3090 </span>                :            : @param hist Input histogram that can be dense or sparse.
<span class="lineNum">    3091 </span>                :            : @param backProject Destination back projection array that is a single-channel array of the same
<span class="lineNum">    3092 </span>                :            : size and depth as images[0] .
<span class="lineNum">    3093 </span>                :            : @param ranges Array of arrays of the histogram bin boundaries in each dimension. See #calcHist .
<span class="lineNum">    3094 </span>                :            : @param scale Optional scale factor for the output back projection.
<span class="lineNum">    3095 </span>                :            : @param uniform Flag indicating whether the histogram is uniform or not (see above).
<span class="lineNum">    3096 </span>                :            : 
<span class="lineNum">    3097 </span>                :            : @sa calcHist, compareHist
<span class="lineNum">    3098 </span>                :            :  */
<span class="lineNum">    3099 </span>                :            : CV_EXPORTS void calcBackProject( const Mat* images, int nimages,
<span class="lineNum">    3100 </span>                :            :                                  const int* channels, InputArray hist,
<span class="lineNum">    3101 </span>                :            :                                  OutputArray backProject, const float** ranges,
<span class="lineNum">    3102 </span>                :            :                                  double scale = 1, bool uniform = true );
<span class="lineNum">    3103 </span>                :            : 
<span class="lineNum">    3104 </span>                :            : /** @overload */
<span class="lineNum">    3105 </span>                :            : CV_EXPORTS void calcBackProject( const Mat* images, int nimages,
<span class="lineNum">    3106 </span>                :            :                                  const int* channels, const SparseMat&amp; hist,
<span class="lineNum">    3107 </span>                :            :                                  OutputArray backProject, const float** ranges,
<span class="lineNum">    3108 </span>                :            :                                  double scale = 1, bool uniform = true );
<span class="lineNum">    3109 </span>                :            : 
<span class="lineNum">    3110 </span>                :            : /** @overload */
<span class="lineNum">    3111 </span>                :            : CV_EXPORTS_W void calcBackProject( InputArrayOfArrays images, const std::vector&lt;int&gt;&amp; channels,
<span class="lineNum">    3112 </span>                :            :                                    InputArray hist, OutputArray dst,
<span class="lineNum">    3113 </span>                :            :                                    const std::vector&lt;float&gt;&amp; ranges,
<span class="lineNum">    3114 </span>                :            :                                    double scale );
<span class="lineNum">    3115 </span>                :            : 
<span class="lineNum">    3116 </span>                :            : /** @brief Compares two histograms.
<span class="lineNum">    3117 </span>                :            : 
<span class="lineNum">    3118 </span>                :            : The function cv::compareHist compares two dense or two sparse histograms using the specified method.
<span class="lineNum">    3119 </span>                :            : 
<span class="lineNum">    3120 </span>                :            : The function returns \f$d(H_1, H_2)\f$ .
<span class="lineNum">    3121 </span>                :            : 
<span class="lineNum">    3122 </span>                :            : While the function works well with 1-, 2-, 3-dimensional dense histograms, it may not be suitable
<span class="lineNum">    3123 </span>                :            : for high-dimensional sparse histograms. In such histograms, because of aliasing and sampling
<span class="lineNum">    3124 </span>                :            : problems, the coordinates of non-zero histogram bins can slightly shift. To compare such histograms
<span class="lineNum">    3125 </span>                :            : or more general sparse configurations of weighted points, consider using the #EMD function.
<span class="lineNum">    3126 </span>                :            : 
<span class="lineNum">    3127 </span>                :            : @param H1 First compared histogram.
<span class="lineNum">    3128 </span>                :            : @param H2 Second compared histogram of the same size as H1 .
<span class="lineNum">    3129 </span>                :            : @param method Comparison method, see #HistCompMethods
<span class="lineNum">    3130 </span>                :            :  */
<span class="lineNum">    3131 </span>                :            : CV_EXPORTS_W double compareHist( InputArray H1, InputArray H2, int method );
<span class="lineNum">    3132 </span>                :            : 
<span class="lineNum">    3133 </span>                :            : /** @overload */
<span class="lineNum">    3134 </span>                :            : CV_EXPORTS double compareHist( const SparseMat&amp; H1, const SparseMat&amp; H2, int method );
<span class="lineNum">    3135 </span>                :            : 
<span class="lineNum">    3136 </span>                :            : /** @brief Equalizes the histogram of a grayscale image.
<span class="lineNum">    3137 </span>                :            : 
<span class="lineNum">    3138 </span>                :            : The function equalizes the histogram of the input image using the following algorithm:
<span class="lineNum">    3139 </span>                :            : 
<span class="lineNum">    3140 </span>                :            : - Calculate the histogram \f$H\f$ for src .
<span class="lineNum">    3141 </span>                :            : - Normalize the histogram so that the sum of histogram bins is 255.
<span class="lineNum">    3142 </span>                :            : - Compute the integral of the histogram:
<span class="lineNum">    3143 </span>                :            : \f[H'_i =  \sum _{0  \le j &lt; i} H(j)\f]
<span class="lineNum">    3144 </span>                :            : - Transform the image using \f$H'\f$ as a look-up table: \f$\texttt{dst}(x,y) = H'(\texttt{src}(x,y))\f$
<span class="lineNum">    3145 </span>                :            : 
<span class="lineNum">    3146 </span>                :            : The algorithm normalizes the brightness and increases the contrast of the image.
<span class="lineNum">    3147 </span>                :            : 
<span class="lineNum">    3148 </span>                :            : @param src Source 8-bit single channel image.
<span class="lineNum">    3149 </span>                :            : @param dst Destination image of the same size and type as src .
<span class="lineNum">    3150 </span>                :            :  */
<span class="lineNum">    3151 </span>                :            : CV_EXPORTS_W void equalizeHist( InputArray src, OutputArray dst );
<span class="lineNum">    3152 </span>                :            : 
<span class="lineNum">    3153 </span>                :            : /** @brief Creates a smart pointer to a cv::CLAHE class and initializes it.
<span class="lineNum">    3154 </span>                :            : 
<span class="lineNum">    3155 </span>                :            : @param clipLimit Threshold for contrast limiting.
<span class="lineNum">    3156 </span>                :            : @param tileGridSize Size of grid for histogram equalization. Input image will be divided into
<span class="lineNum">    3157 </span>                :            : equally sized rectangular tiles. tileGridSize defines the number of tiles in row and column.
<span class="lineNum">    3158 </span>                :            :  */
<span class="lineNum">    3159 </span>                :            : CV_EXPORTS_W Ptr&lt;CLAHE&gt; createCLAHE(double clipLimit = 40.0, Size tileGridSize = Size(8, 8));
<span class="lineNum">    3160 </span>                :            : 
<span class="lineNum">    3161 </span>                :            : /** @brief Computes the &quot;minimal work&quot; distance between two weighted point configurations.
<span class="lineNum">    3162 </span>                :            : 
<span class="lineNum">    3163 </span>                :            : The function computes the earth mover distance and/or a lower boundary of the distance between the
<span class="lineNum">    3164 </span>                :            : two weighted point configurations. One of the applications described in @cite RubnerSept98,
<span class="lineNum">    3165 </span>                :            : @cite Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation
<span class="lineNum">    3166 </span>                :            : problem that is solved using some modification of a simplex algorithm, thus the complexity is
<span class="lineNum">    3167 </span>                :            : exponential in the worst case, though, on average it is much faster. In the case of a real metric
<span class="lineNum">    3168 </span>                :            : the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used
<span class="lineNum">    3169 </span>                :            : to determine roughly whether the two signatures are far enough so that they cannot relate to the
<span class="lineNum">    3170 </span>                :            : same object.
<span class="lineNum">    3171 </span>                :            : 
<span class="lineNum">    3172 </span>                :            : @param signature1 First signature, a \f$\texttt{size1}\times \texttt{dims}+1\f$ floating-point matrix.
<span class="lineNum">    3173 </span>                :            : Each row stores the point weight followed by the point coordinates. The matrix is allowed to have
<span class="lineNum">    3174 </span>                :            : a single column (weights only) if the user-defined cost matrix is used. The weights must be
<span class="lineNum">    3175 </span>                :            : non-negative and have at least one non-zero value.
<span class="lineNum">    3176 </span>                :            : @param signature2 Second signature of the same format as signature1 , though the number of rows
<span class="lineNum">    3177 </span>                :            : may be different. The total weights may be different. In this case an extra &quot;dummy&quot; point is added
<span class="lineNum">    3178 </span>                :            : to either signature1 or signature2. The weights must be non-negative and have at least one non-zero
<span class="lineNum">    3179 </span>                :            : value.
<span class="lineNum">    3180 </span>                :            : @param distType Used metric. See #DistanceTypes.
<span class="lineNum">    3181 </span>                :            : @param cost User-defined \f$\texttt{size1}\times \texttt{size2}\f$ cost matrix. Also, if a cost matrix
<span class="lineNum">    3182 </span>                :            : is used, lower boundary lowerBound cannot be calculated because it needs a metric function.
<span class="lineNum">    3183 </span>                :            : @param lowerBound Optional input/output parameter: lower boundary of a distance between the two
<span class="lineNum">    3184 </span>                :            : signatures that is a distance between mass centers. The lower boundary may not be calculated if
<span class="lineNum">    3185 </span>                :            : the user-defined cost matrix is used, the total weights of point configurations are not equal, or
<span class="lineNum">    3186 </span>                :            : if the signatures consist of weights only (the signature matrices have a single column). You
<span class="lineNum">    3187 </span>                :            : **must** initialize \*lowerBound . If the calculated distance between mass centers is greater or
<span class="lineNum">    3188 </span>                :            : equal to \*lowerBound (it means that the signatures are far enough), the function does not
<span class="lineNum">    3189 </span>                :            : calculate EMD. In any case \*lowerBound is set to the calculated distance between mass centers on
<span class="lineNum">    3190 </span>                :            : return. Thus, if you want to calculate both distance between mass centers and EMD, \*lowerBound
<span class="lineNum">    3191 </span>                :            : should be set to 0.
<span class="lineNum">    3192 </span>                :            : @param flow Resultant \f$\texttt{size1} \times \texttt{size2}\f$ flow matrix: \f$\texttt{flow}_{i,j}\f$ is
<span class="lineNum">    3193 </span>                :            : a flow from \f$i\f$ -th point of signature1 to \f$j\f$ -th point of signature2 .
<span class="lineNum">    3194 </span>                :            :  */
<span class="lineNum">    3195 </span>                :            : CV_EXPORTS float EMD( InputArray signature1, InputArray signature2,
<span class="lineNum">    3196 </span>                :            :                       int distType, InputArray cost=noArray(),
<span class="lineNum">    3197 </span>                :            :                       float* lowerBound = 0, OutputArray flow = noArray() );
<span class="lineNum">    3198 </span>                :            : 
<span class="lineNum">    3199 </span>                :            : CV_EXPORTS_AS(EMD) float wrapperEMD( InputArray signature1, InputArray signature2,
<span class="lineNum">    3200 </span>                :            :                       int distType, InputArray cost=noArray(),
<span class="lineNum">    3201 </span>                :            :                       CV_IN_OUT Ptr&lt;float&gt; lowerBound = Ptr&lt;float&gt;(), OutputArray flow = noArray() );
<span class="lineNum">    3202 </span>                :            : 
<span class="lineNum">    3203 </span>                :            : //! @} imgproc_hist
<span class="lineNum">    3204 </span>                :            : 
<span class="lineNum">    3205 </span>                :            : /** @example samples/cpp/watershed.cpp
<span class="lineNum">    3206 </span>                :            : An example using the watershed algorithm
<span class="lineNum">    3207 </span>                :            : */
<span class="lineNum">    3208 </span>                :            : 
<span class="lineNum">    3209 </span>                :            : /** @brief Performs a marker-based image segmentation using the watershed algorithm.
<span class="lineNum">    3210 </span>                :            : 
<span class="lineNum">    3211 </span>                :            : The function implements one of the variants of watershed, non-parametric marker-based segmentation
<span class="lineNum">    3212 </span>                :            : algorithm, described in @cite Meyer92 .
<span class="lineNum">    3213 </span>                :            : 
<span class="lineNum">    3214 </span>                :            : Before passing the image to the function, you have to roughly outline the desired regions in the
<span class="lineNum">    3215 </span>                :            : image markers with positive (\&gt;0) indices. So, every region is represented as one or more connected
<span class="lineNum">    3216 </span>                :            : components with the pixel values 1, 2, 3, and so on. Such markers can be retrieved from a binary
<span class="lineNum">    3217 </span>                :            : mask using #findContours and #drawContours (see the watershed.cpp demo). The markers are &quot;seeds&quot; of
<span class="lineNum">    3218 </span>                :            : the future image regions. All the other pixels in markers , whose relation to the outlined regions
<span class="lineNum">    3219 </span>                :            : is not known and should be defined by the algorithm, should be set to 0's. In the function output,
<span class="lineNum">    3220 </span>                :            : each pixel in markers is set to a value of the &quot;seed&quot; components or to -1 at boundaries between the
<span class="lineNum">    3221 </span>                :            : regions.
<span class="lineNum">    3222 </span>                :            : 
<span class="lineNum">    3223 </span>                :            : @note Any two neighbor connected components are not necessarily separated by a watershed boundary
<span class="lineNum">    3224 </span>                :            : (-1's pixels); for example, they can touch each other in the initial marker image passed to the
<span class="lineNum">    3225 </span>                :            : function.
<span class="lineNum">    3226 </span>                :            : 
<span class="lineNum">    3227 </span>                :            : @param image Input 8-bit 3-channel image.
<span class="lineNum">    3228 </span>                :            : @param markers Input/output 32-bit single-channel image (map) of markers. It should have the same
<span class="lineNum">    3229 </span>                :            : size as image .
<span class="lineNum">    3230 </span>                :            : 
<span class="lineNum">    3231 </span>                :            : @sa findContours
<span class="lineNum">    3232 </span>                :            : 
<span class="lineNum">    3233 </span>                :            : @ingroup imgproc_misc
<span class="lineNum">    3234 </span>                :            :  */
<span class="lineNum">    3235 </span>                :            : CV_EXPORTS_W void watershed( InputArray image, InputOutputArray markers );
<span class="lineNum">    3236 </span>                :            : 
<span class="lineNum">    3237 </span>                :            : //! @addtogroup imgproc_filter
<span class="lineNum">    3238 </span>                :            : //! @{
<span class="lineNum">    3239 </span>                :            : 
<span class="lineNum">    3240 </span>                :            : /** @brief Performs initial step of meanshift segmentation of an image.
<span class="lineNum">    3241 </span>                :            : 
<span class="lineNum">    3242 </span>                :            : The function implements the filtering stage of meanshift segmentation, that is, the output of the
<span class="lineNum">    3243 </span>                :            : function is the filtered &quot;posterized&quot; image with color gradients and fine-grain texture flattened.
<span class="lineNum">    3244 </span>                :            : At every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes
<span class="lineNum">    3245 </span>                :            : meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is
<span class="lineNum">    3246 </span>                :            : considered:
<span class="lineNum">    3247 </span>                :            : 
<span class="lineNum">    3248 </span>                :            : \f[(x,y): X- \texttt{sp} \le x  \le X+ \texttt{sp} , Y- \texttt{sp} \le y  \le Y+ \texttt{sp} , ||(R,G,B)-(r,g,b)||   \le \texttt{sr}\f]
<span class="lineNum">    3249 </span>                :            : 
<span class="lineNum">    3250 </span>                :            : where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively
<span class="lineNum">    3251 </span>                :            : (though, the algorithm does not depend on the color space used, so any 3-component color space can
<span class="lineNum">    3252 </span>                :            : be used instead). Over the neighborhood the average spatial value (X',Y') and average color vector
<span class="lineNum">    3253 </span>                :            : (R',G',B') are found and they act as the neighborhood center on the next iteration:
<span class="lineNum">    3254 </span>                :            : 
<span class="lineNum">    3255 </span>                :            : \f[(X,Y)~(X',Y'), (R,G,B)~(R',G',B').\f]
<span class="lineNum">    3256 </span>                :            : 
<span class="lineNum">    3257 </span>                :            : After the iterations over, the color components of the initial pixel (that is, the pixel from where
<span class="lineNum">    3258 </span>                :            : the iterations started) are set to the final value (average color at the last iteration):
<span class="lineNum">    3259 </span>                :            : 
<span class="lineNum">    3260 </span>                :            : \f[I(X,Y) &lt;- (R*,G*,B*)\f]
<span class="lineNum">    3261 </span>                :            : 
<span class="lineNum">    3262 </span>                :            : When maxLevel \&gt; 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is
<span class="lineNum">    3263 </span>                :            : run on the smallest layer first. After that, the results are propagated to the larger layer and the
<span class="lineNum">    3264 </span>                :            : iterations are run again only on those pixels where the layer colors differ by more than sr from the
<span class="lineNum">    3265 </span>                :            : lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the
<span class="lineNum">    3266 </span>                :            : results will be actually different from the ones obtained by running the meanshift procedure on the
<span class="lineNum">    3267 </span>                :            : whole original image (i.e. when maxLevel==0).
<span class="lineNum">    3268 </span>                :            : 
<span class="lineNum">    3269 </span>                :            : @param src The source 8-bit, 3-channel image.
<span class="lineNum">    3270 </span>                :            : @param dst The destination image of the same format and the same size as the source.
<span class="lineNum">    3271 </span>                :            : @param sp The spatial window radius.
<span class="lineNum">    3272 </span>                :            : @param sr The color window radius.
<span class="lineNum">    3273 </span>                :            : @param maxLevel Maximum level of the pyramid for the segmentation.
<span class="lineNum">    3274 </span>                :            : @param termcrit Termination criteria: when to stop meanshift iterations.
<span class="lineNum">    3275 </span>                :            :  */
<span class="lineNum">    3276 </span>                :            : CV_EXPORTS_W void pyrMeanShiftFiltering( InputArray src, OutputArray dst,
<span class="lineNum">    3277 </span>                :            :                                          double sp, double sr, int maxLevel = 1,
<span class="lineNum">    3278 </span>                :            :                                          TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) );
<span class="lineNum">    3279 </span>                :            : 
<span class="lineNum">    3280 </span>                :            : //! @}
<span class="lineNum">    3281 </span>                :            : 
<span class="lineNum">    3282 </span>                :            : //! @addtogroup imgproc_misc
<span class="lineNum">    3283 </span>                :            : //! @{
<span class="lineNum">    3284 </span>                :            : 
<span class="lineNum">    3285 </span>                :            : /** @example samples/cpp/grabcut.cpp
<span class="lineNum">    3286 </span>                :            : An example using the GrabCut algorithm
<span class="lineNum">    3287 </span>                :            : ![Sample Screenshot](grabcut_output1.jpg)
<span class="lineNum">    3288 </span>                :            : */
<span class="lineNum">    3289 </span>                :            : 
<span class="lineNum">    3290 </span>                :            : /** @brief Runs the GrabCut algorithm.
<span class="lineNum">    3291 </span>                :            : 
<span class="lineNum">    3292 </span>                :            : The function implements the [GrabCut image segmentation algorithm](http://en.wikipedia.org/wiki/GrabCut).
<span class="lineNum">    3293 </span>                :            : 
<span class="lineNum">    3294 </span>                :            : @param img Input 8-bit 3-channel image.
<span class="lineNum">    3295 </span>                :            : @param mask Input/output 8-bit single-channel mask. The mask is initialized by the function when
<span class="lineNum">    3296 </span>                :            : mode is set to #GC_INIT_WITH_RECT. Its elements may have one of the #GrabCutClasses.
<span class="lineNum">    3297 </span>                :            : @param rect ROI containing a segmented object. The pixels outside of the ROI are marked as
<span class="lineNum">    3298 </span>                :            : &quot;obvious background&quot;. The parameter is only used when mode==#GC_INIT_WITH_RECT .
<span class="lineNum">    3299 </span>                :            : @param bgdModel Temporary array for the background model. Do not modify it while you are
<span class="lineNum">    3300 </span>                :            : processing the same image.
<span class="lineNum">    3301 </span>                :            : @param fgdModel Temporary arrays for the foreground model. Do not modify it while you are
<span class="lineNum">    3302 </span>                :            : processing the same image.
<span class="lineNum">    3303 </span>                :            : @param iterCount Number of iterations the algorithm should make before returning the result. Note
<span class="lineNum">    3304 </span>                :            : that the result can be refined with further calls with mode==#GC_INIT_WITH_MASK or
<span class="lineNum">    3305 </span>                :            : mode==GC_EVAL .
<span class="lineNum">    3306 </span>                :            : @param mode Operation mode that could be one of the #GrabCutModes
<span class="lineNum">    3307 </span>                :            :  */
<span class="lineNum">    3308 </span>                :            : CV_EXPORTS_W void grabCut( InputArray img, InputOutputArray mask, Rect rect,
<span class="lineNum">    3309 </span>                :            :                            InputOutputArray bgdModel, InputOutputArray fgdModel,
<span class="lineNum">    3310 </span>                :            :                            int iterCount, int mode = GC_EVAL );
<span class="lineNum">    3311 </span>                :            : 
<span class="lineNum">    3312 </span>                :            : /** @example samples/cpp/distrans.cpp
<span class="lineNum">    3313 </span>                :            : An example on using the distance transform
<span class="lineNum">    3314 </span>                :            : */
<span class="lineNum">    3315 </span>                :            : 
<span class="lineNum">    3316 </span>                :            : /** @brief Calculates the distance to the closest zero pixel for each pixel of the source image.
<span class="lineNum">    3317 </span>                :            : 
<span class="lineNum">    3318 </span>                :            : The function cv::distanceTransform calculates the approximate or precise distance from every binary
<span class="lineNum">    3319 </span>                :            : image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.
<span class="lineNum">    3320 </span>                :            : 
<span class="lineNum">    3321 </span>                :            : When maskSize == #DIST_MASK_PRECISE and distanceType == #DIST_L2 , the function runs the
<span class="lineNum">    3322 </span>                :            : algorithm described in @cite Felzenszwalb04 . This algorithm is parallelized with the TBB library.
<span class="lineNum">    3323 </span>                :            : 
<span class="lineNum">    3324 </span>                :            : In other cases, the algorithm @cite Borgefors86 is used. This means that for a pixel the function
<span class="lineNum">    3325 </span>                :            : finds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical,
<span class="lineNum">    3326 </span>                :            : diagonal, or knight's move (the latest is available for a \f$5\times 5\f$ mask). The overall
<span class="lineNum">    3327 </span>                :            : distance is calculated as a sum of these basic distances. Since the distance function should be
<span class="lineNum">    3328 </span>                :            : symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all
<span class="lineNum">    3329 </span>                :            : the diagonal shifts must have the same cost (denoted as `b`), and all knight's moves must have the
<span class="lineNum">    3330 </span>                :            : same cost (denoted as `c`). For the #DIST_C and #DIST_L1 types, the distance is calculated
<span class="lineNum">    3331 </span>                :            : precisely, whereas for #DIST_L2 (Euclidean distance) the distance can be calculated only with a
<span class="lineNum">    3332 </span>                :            : relative error (a \f$5\times 5\f$ mask gives more accurate results). For `a`,`b`, and `c`, OpenCV
<span class="lineNum">    3333 </span>                :            : uses the values suggested in the original paper:
<span class="lineNum">    3334 </span>                :            : - DIST_L1: `a = 1, b = 2`
<span class="lineNum">    3335 </span>                :            : - DIST_L2:
<span class="lineNum">    3336 </span>                :            :     - `3 x 3`: `a=0.955, b=1.3693`
<span class="lineNum">    3337 </span>                :            :     - `5 x 5`: `a=1, b=1.4, c=2.1969`
<span class="lineNum">    3338 </span>                :            : - DIST_C: `a = 1, b = 1`
<span class="lineNum">    3339 </span>                :            : 
<span class="lineNum">    3340 </span>                :            : Typically, for a fast, coarse distance estimation #DIST_L2, a \f$3\times 3\f$ mask is used. For a
<span class="lineNum">    3341 </span>                :            : more accurate distance estimation #DIST_L2, a \f$5\times 5\f$ mask or the precise algorithm is used.
<span class="lineNum">    3342 </span>                :            : Note that both the precise and the approximate algorithms are linear on the number of pixels.
<span class="lineNum">    3343 </span>                :            : 
<span class="lineNum">    3344 </span>                :            : This variant of the function does not only compute the minimum distance for each pixel \f$(x, y)\f$
<span class="lineNum">    3345 </span>                :            : but also identifies the nearest connected component consisting of zero pixels
<span class="lineNum">    3346 </span>                :            : (labelType==#DIST_LABEL_CCOMP) or the nearest zero pixel (labelType==#DIST_LABEL_PIXEL). Index of the
<span class="lineNum">    3347 </span>                :            : component/pixel is stored in `labels(x, y)`. When labelType==#DIST_LABEL_CCOMP, the function
<span class="lineNum">    3348 </span>                :            : automatically finds connected components of zero pixels in the input image and marks them with
<span class="lineNum">    3349 </span>                :            : distinct labels. When labelType==#DIST_LABEL_CCOMP, the function scans through the input image and
<span class="lineNum">    3350 </span>                :            : marks all the zero pixels with distinct labels.
<span class="lineNum">    3351 </span>                :            : 
<span class="lineNum">    3352 </span>                :            : In this mode, the complexity is still linear. That is, the function provides a very fast way to
<span class="lineNum">    3353 </span>                :            : compute the Voronoi diagram for a binary image. Currently, the second variant can use only the
<span class="lineNum">    3354 </span>                :            : approximate distance transform algorithm, i.e. maskSize=#DIST_MASK_PRECISE is not supported
<span class="lineNum">    3355 </span>                :            : yet.
<span class="lineNum">    3356 </span>                :            : 
<span class="lineNum">    3357 </span>                :            : @param src 8-bit, single-channel (binary) source image.
<span class="lineNum">    3358 </span>                :            : @param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
<span class="lineNum">    3359 </span>                :            : single-channel image of the same size as src.
<span class="lineNum">    3360 </span>                :            : @param labels Output 2D array of labels (the discrete Voronoi diagram). It has the type
<span class="lineNum">    3361 </span>                :            : CV_32SC1 and the same size as src.
<span class="lineNum">    3362 </span>                :            : @param distanceType Type of distance, see #DistanceTypes
<span class="lineNum">    3363 </span>                :            : @param maskSize Size of the distance transform mask, see #DistanceTransformMasks.
<span class="lineNum">    3364 </span>                :            : #DIST_MASK_PRECISE is not supported by this variant. In case of the #DIST_L1 or #DIST_C distance type,
<span class="lineNum">    3365 </span>                :            : the parameter is forced to 3 because a \f$3\times 3\f$ mask gives the same result as \f$5\times
<span class="lineNum">    3366 </span>                :            : 5\f$ or any larger aperture.
<span class="lineNum">    3367 </span>                :            : @param labelType Type of the label array to build, see #DistanceTransformLabelTypes.
<span class="lineNum">    3368 </span>                :            :  */
<span class="lineNum">    3369 </span>                :            : CV_EXPORTS_AS(distanceTransformWithLabels) void distanceTransform( InputArray src, OutputArray dst,
<span class="lineNum">    3370 </span>                :            :                                      OutputArray labels, int distanceType, int maskSize,
<span class="lineNum">    3371 </span>                :            :                                      int labelType = DIST_LABEL_CCOMP );
<span class="lineNum">    3372 </span>                :            : 
<span class="lineNum">    3373 </span>                :            : /** @overload
<span class="lineNum">    3374 </span>                :            : @param src 8-bit, single-channel (binary) source image.
<span class="lineNum">    3375 </span>                :            : @param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
<span class="lineNum">    3376 </span>                :            : single-channel image of the same size as src .
<span class="lineNum">    3377 </span>                :            : @param distanceType Type of distance, see #DistanceTypes
<span class="lineNum">    3378 </span>                :            : @param maskSize Size of the distance transform mask, see #DistanceTransformMasks. In case of the
<span class="lineNum">    3379 </span>                :            : #DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a \f$3\times 3\f$ mask gives
<span class="lineNum">    3380 </span>                :            : the same result as \f$5\times 5\f$ or any larger aperture.
<span class="lineNum">    3381 </span>                :            : @param dstType Type of output image. It can be CV_8U or CV_32F. Type CV_8U can be used only for
<span class="lineNum">    3382 </span>                :            : the first variant of the function and distanceType == #DIST_L1.
<span class="lineNum">    3383 </span>                :            : */
<span class="lineNum">    3384 </span>                :            : CV_EXPORTS_W void distanceTransform( InputArray src, OutputArray dst,
<span class="lineNum">    3385 </span>                :            :                                      int distanceType, int maskSize, int dstType=CV_32F);
<span class="lineNum">    3386 </span>                :            : 
<span class="lineNum">    3387 </span>                :            : /** @example samples/cpp/ffilldemo.cpp
<span class="lineNum">    3388 </span>                :            : An example using the FloodFill technique
<span class="lineNum">    3389 </span>                :            : */
<span class="lineNum">    3390 </span>                :            : 
<span class="lineNum">    3391 </span>                :            : /** @overload
<span class="lineNum">    3392 </span>                :            : 
<span class="lineNum">    3393 </span>                :            : variant without `mask` parameter
<span class="lineNum">    3394 </span>                :            : */
<span class="lineNum">    3395 </span>                :            : CV_EXPORTS int floodFill( InputOutputArray image,
<span class="lineNum">    3396 </span>                :            :                           Point seedPoint, Scalar newVal, CV_OUT Rect* rect = 0,
<span class="lineNum">    3397 </span>                :            :                           Scalar loDiff = Scalar(), Scalar upDiff = Scalar(),
<span class="lineNum">    3398 </span>                :            :                           int flags = 4 );
<span class="lineNum">    3399 </span>                :            : 
<span class="lineNum">    3400 </span>                :            : /** @brief Fills a connected component with the given color.
<span class="lineNum">    3401 </span>                :            : 
<span class="lineNum">    3402 </span>                :            : The function cv::floodFill fills a connected component starting from the seed point with the specified
<span class="lineNum">    3403 </span>                :            : color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The
<span class="lineNum">    3404 </span>                :            : pixel at \f$(x,y)\f$ is considered to belong to the repainted domain if:
<span class="lineNum">    3405 </span>                :            : 
<span class="lineNum">    3406 </span>                :            : - in case of a grayscale image and floating range
<span class="lineNum">    3407 </span>                :            : \f[\texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} (x',y')+ \texttt{upDiff}\f]
<span class="lineNum">    3408 </span>                :            : 
<span class="lineNum">    3409 </span>                :            : 
<span class="lineNum">    3410 </span>                :            : - in case of a grayscale image and fixed range
<span class="lineNum">    3411 </span>                :            : \f[\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff}\f]
<span class="lineNum">    3412 </span>                :            : 
<span class="lineNum">    3413 </span>                :            : 
<span class="lineNum">    3414 </span>                :            : - in case of a color image and floating range
<span class="lineNum">    3415 </span>                :            : \f[\texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r,\f]
<span class="lineNum">    3416 </span>                :            : \f[\texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g\f]
<span class="lineNum">    3417 </span>                :            : and
<span class="lineNum">    3418 </span>                :            : \f[\texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b\f]
<span class="lineNum">    3419 </span>                :            : 
<span class="lineNum">    3420 </span>                :            : 
<span class="lineNum">    3421 </span>                :            : - in case of a color image and fixed range
<span class="lineNum">    3422 </span>                :            : \f[\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r,\f]
<span class="lineNum">    3423 </span>                :            : \f[\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g\f]
<span class="lineNum">    3424 </span>                :            : and
<span class="lineNum">    3425 </span>                :            : \f[\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b\f]
<span class="lineNum">    3426 </span>                :            : 
<span class="lineNum">    3427 </span>                :            : 
<span class="lineNum">    3428 </span>                :            : where \f$src(x',y')\f$ is the value of one of pixel neighbors that is already known to belong to the
<span class="lineNum">    3429 </span>                :            : component. That is, to be added to the connected component, a color/brightness of the pixel should
<span class="lineNum">    3430 </span>                :            : be close enough to:
<span class="lineNum">    3431 </span>                :            : - Color/brightness of one of its neighbors that already belong to the connected component in case
<span class="lineNum">    3432 </span>                :            : of a floating range.
<span class="lineNum">    3433 </span>                :            : - Color/brightness of the seed point in case of a fixed range.
<span class="lineNum">    3434 </span>                :            : 
<span class="lineNum">    3435 </span>                :            : Use these functions to either mark a connected component with the specified color in-place, or build
<span class="lineNum">    3436 </span>                :            : a mask and then extract the contour, or copy the region to another image, and so on.
<span class="lineNum">    3437 </span>                :            : 
<span class="lineNum">    3438 </span>                :            : @param image Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the
<span class="lineNum">    3439 </span>                :            : function unless the #FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See
<span class="lineNum">    3440 </span>                :            : the details below.
<span class="lineNum">    3441 </span>                :            : @param mask Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels
<span class="lineNum">    3442 </span>                :            : taller than image. Since this is both an input and output parameter, you must take responsibility
<span class="lineNum">    3443 </span>                :            : of initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example,
<span class="lineNum">    3444 </span>                :            : an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the
<span class="lineNum">    3445 </span>                :            : mask corresponding to filled pixels in the image are set to 1 or to the a value specified in flags
<span class="lineNum">    3446 </span>                :            : as described below. Additionally, the function fills the border of the mask with ones to simplify
<span class="lineNum">    3447 </span>                :            : internal processing. It is therefore possible to use the same mask in multiple calls to the function
<span class="lineNum">    3448 </span>                :            : to make sure the filled areas do not overlap.
<span class="lineNum">    3449 </span>                :            : @param seedPoint Starting point.
<span class="lineNum">    3450 </span>                :            : @param newVal New value of the repainted domain pixels.
<span class="lineNum">    3451 </span>                :            : @param loDiff Maximal lower brightness/color difference between the currently observed pixel and
<span class="lineNum">    3452 </span>                :            : one of its neighbors belonging to the component, or a seed pixel being added to the component.
<span class="lineNum">    3453 </span>                :            : @param upDiff Maximal upper brightness/color difference between the currently observed pixel and
<span class="lineNum">    3454 </span>                :            : one of its neighbors belonging to the component, or a seed pixel being added to the component.
<span class="lineNum">    3455 </span>                :            : @param rect Optional output parameter set by the function to the minimum bounding rectangle of the
<span class="lineNum">    3456 </span>                :            : repainted domain.
<span class="lineNum">    3457 </span>                :            : @param flags Operation flags. The first 8 bits contain a connectivity value. The default value of
<span class="lineNum">    3458 </span>                :            : 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A
<span class="lineNum">    3459 </span>                :            : connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner)
<span class="lineNum">    3460 </span>                :            : will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill
<span class="lineNum">    3461 </span>                :            : the mask (the default value is 1). For example, 4 | ( 255 \&lt;\&lt; 8 ) will consider 4 nearest
<span class="lineNum">    3462 </span>                :            : neighbours and fill the mask with a value of 255. The following additional options occupy higher
<span class="lineNum">    3463 </span>                :            : bits and therefore may be further combined with the connectivity and mask fill values using
<span class="lineNum">    3464 </span>                :            : bit-wise or (|), see #FloodFillFlags.
<span class="lineNum">    3465 </span>                :            : 
<span class="lineNum">    3466 </span>                :            : @note Since the mask is larger than the filled image, a pixel \f$(x, y)\f$ in image corresponds to the
<span class="lineNum">    3467 </span>                :            : pixel \f$(x+1, y+1)\f$ in the mask .
<span class="lineNum">    3468 </span>                :            : 
<span class="lineNum">    3469 </span>                :            : @sa findContours
<span class="lineNum">    3470 </span>                :            :  */
<span class="lineNum">    3471 </span>                :            : CV_EXPORTS_W int floodFill( InputOutputArray image, InputOutputArray mask,
<span class="lineNum">    3472 </span>                :            :                             Point seedPoint, Scalar newVal, CV_OUT Rect* rect=0,
<span class="lineNum">    3473 </span>                :            :                             Scalar loDiff = Scalar(), Scalar upDiff = Scalar(),
<span class="lineNum">    3474 </span>                :            :                             int flags = 4 );
<span class="lineNum">    3475 </span>                :            : 
<span class="lineNum">    3476 </span>                :            : //! Performs linear blending of two images:
<span class="lineNum">    3477 </span>                :            : //! \f[ \texttt{dst}(i,j) = \texttt{weights1}(i,j)*\texttt{src1}(i,j) + \texttt{weights2}(i,j)*\texttt{src2}(i,j) \f]
<span class="lineNum">    3478 </span>                :            : //! @param src1 It has a type of CV_8UC(n) or CV_32FC(n), where n is a positive integer.
<span class="lineNum">    3479 </span>                :            : //! @param src2 It has the same type and size as src1.
<span class="lineNum">    3480 </span>                :            : //! @param weights1 It has a type of CV_32FC1 and the same size with src1.
<span class="lineNum">    3481 </span>                :            : //! @param weights2 It has a type of CV_32FC1 and the same size with src1.
<span class="lineNum">    3482 </span>                :            : //! @param dst It is created if it does not have the same size and type with src1.
<span class="lineNum">    3483 </span>                :            : CV_EXPORTS void blendLinear(InputArray src1, InputArray src2, InputArray weights1, InputArray weights2, OutputArray dst);
<span class="lineNum">    3484 </span>                :            : 
<span class="lineNum">    3485 </span>                :            : //! @} imgproc_misc
<span class="lineNum">    3486 </span>                :            : 
<span class="lineNum">    3487 </span>                :            : //! @addtogroup imgproc_color_conversions
<span class="lineNum">    3488 </span>                :            : //! @{
<span class="lineNum">    3489 </span>                :            : 
<span class="lineNum">    3490 </span>                :            : /** @brief Converts an image from one color space to another.
<span class="lineNum">    3491 </span>                :            : 
<span class="lineNum">    3492 </span>                :            : The function converts an input image from one color space to another. In case of a transformation
<span class="lineNum">    3493 </span>                :            : to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note
<span class="lineNum">    3494 </span>                :            : that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the
<span class="lineNum">    3495 </span>                :            : bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue
<span class="lineNum">    3496 </span>                :            : component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and
<span class="lineNum">    3497 </span>                :            : sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.
<span class="lineNum">    3498 </span>                :            : 
<span class="lineNum">    3499 </span>                :            : The conventional ranges for R, G, and B channel values are:
<span class="lineNum">    3500 </span>                :            : -   0 to 255 for CV_8U images
<span class="lineNum">    3501 </span>                :            : -   0 to 65535 for CV_16U images
<span class="lineNum">    3502 </span>                :            : -   0 to 1 for CV_32F images
<span class="lineNum">    3503 </span>                :            : 
<span class="lineNum">    3504 </span>                :            : In case of linear transformations, the range does not matter. But in case of a non-linear
<span class="lineNum">    3505 </span>                :            : transformation, an input RGB image should be normalized to the proper value range to get the correct
<span class="lineNum">    3506 </span>                :            : results, for example, for RGB \f$\rightarrow\f$ L\*u\*v\* transformation. For example, if you have a
<span class="lineNum">    3507 </span>                :            : 32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will
<span class="lineNum">    3508 </span>                :            : have the 0..255 value range instead of 0..1 assumed by the function. So, before calling #cvtColor ,
<span class="lineNum">    3509 </span>                :            : you need first to scale the image down:
<span class="lineNum">    3510 </span>                :            : @code
<span class="lineNum">    3511 </span>                :            :     img *= 1./255;
<span class="lineNum">    3512 </span>                :            :     cvtColor(img, img, COLOR_BGR2Luv);
<span class="lineNum">    3513 </span>                :            : @endcode
<span class="lineNum">    3514 </span>                :            : If you use #cvtColor with 8-bit images, the conversion will have some information lost. For many
<span class="lineNum">    3515 </span>                :            : applications, this will not be noticeable but it is recommended to use 32-bit images in applications
<span class="lineNum">    3516 </span>                :            : that need the full range of colors or that convert an image before an operation and then convert
<span class="lineNum">    3517 </span>                :            : back.
<span class="lineNum">    3518 </span>                :            : 
<span class="lineNum">    3519 </span>                :            : If conversion adds the alpha channel, its value will set to the maximum of corresponding channel
<span class="lineNum">    3520 </span>                :            : range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.
<span class="lineNum">    3521 </span>                :            : 
<span class="lineNum">    3522 </span>                :            : @param src input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision
<span class="lineNum">    3523 </span>                :            : floating-point.
<span class="lineNum">    3524 </span>                :            : @param dst output image of the same size and depth as src.
<span class="lineNum">    3525 </span>                :            : @param code color space conversion code (see #ColorConversionCodes).
<span class="lineNum">    3526 </span>                :            : @param dstCn number of channels in the destination image; if the parameter is 0, the number of the
<span class="lineNum">    3527 </span>                :            : channels is derived automatically from src and code.
<span class="lineNum">    3528 </span>                :            : 
<span class="lineNum">    3529 </span>                :            : @see @ref imgproc_color_conversions
<span class="lineNum">    3530 </span>                :            :  */
<span class="lineNum">    3531 </span>                :            : CV_EXPORTS_W void cvtColor( InputArray src, OutputArray dst, int code, int dstCn = 0 );
<span class="lineNum">    3532 </span>                :            : 
<span class="lineNum">    3533 </span>                :            : /** @brief Converts an image from one color space to another where the source image is
<span class="lineNum">    3534 </span>                :            : stored in two planes.
<span class="lineNum">    3535 </span>                :            : 
<span class="lineNum">    3536 </span>                :            : This function only supports YUV420 to RGB conversion as of now.
<span class="lineNum">    3537 </span>                :            : 
<span class="lineNum">    3538 </span>                :            : @param src1: 8-bit image (#CV_8U) of the Y plane.
<span class="lineNum">    3539 </span>                :            : @param src2: image containing interleaved U/V plane.
<span class="lineNum">    3540 </span>                :            : @param dst: output image.
<span class="lineNum">    3541 </span>                :            : @param code: Specifies the type of conversion. It can take any of the following values:
<span class="lineNum">    3542 </span>                :            : - #COLOR_YUV2BGR_NV12
<span class="lineNum">    3543 </span>                :            : - #COLOR_YUV2RGB_NV12
<span class="lineNum">    3544 </span>                :            : - #COLOR_YUV2BGRA_NV12
<span class="lineNum">    3545 </span>                :            : - #COLOR_YUV2RGBA_NV12
<span class="lineNum">    3546 </span>                :            : - #COLOR_YUV2BGR_NV21
<span class="lineNum">    3547 </span>                :            : - #COLOR_YUV2RGB_NV21
<span class="lineNum">    3548 </span>                :            : - #COLOR_YUV2BGRA_NV21
<span class="lineNum">    3549 </span>                :            : - #COLOR_YUV2RGBA_NV21
<span class="lineNum">    3550 </span>                :            : */
<span class="lineNum">    3551 </span>                :            : CV_EXPORTS_W void cvtColorTwoPlane( InputArray src1, InputArray src2, OutputArray dst, int code );
<span class="lineNum">    3552 </span>                :            : 
<span class="lineNum">    3553 </span>                :            : /** @brief main function for all demosaicing processes
<span class="lineNum">    3554 </span>                :            : 
<span class="lineNum">    3555 </span>                :            : @param src input image: 8-bit unsigned or 16-bit unsigned.
<span class="lineNum">    3556 </span>                :            : @param dst output image of the same size and depth as src.
<span class="lineNum">    3557 </span>                :            : @param code Color space conversion code (see the description below).
<span class="lineNum">    3558 </span>                :            : @param dstCn number of channels in the destination image; if the parameter is 0, the number of the
<span class="lineNum">    3559 </span>                :            : channels is derived automatically from src and code.
<span class="lineNum">    3560 </span>                :            : 
<span class="lineNum">    3561 </span>                :            : The function can do the following transformations:
<span class="lineNum">    3562 </span>                :            : 
<span class="lineNum">    3563 </span>                :            : -   Demosaicing using bilinear interpolation
<span class="lineNum">    3564 </span>                :            : 
<span class="lineNum">    3565 </span>                :            :     #COLOR_BayerBG2BGR , #COLOR_BayerGB2BGR , #COLOR_BayerRG2BGR , #COLOR_BayerGR2BGR
<span class="lineNum">    3566 </span>                :            : 
<span class="lineNum">    3567 </span>                :            :     #COLOR_BayerBG2GRAY , #COLOR_BayerGB2GRAY , #COLOR_BayerRG2GRAY , #COLOR_BayerGR2GRAY
<span class="lineNum">    3568 </span>                :            : 
<span class="lineNum">    3569 </span>                :            : -   Demosaicing using Variable Number of Gradients.
<span class="lineNum">    3570 </span>                :            : 
<span class="lineNum">    3571 </span>                :            :     #COLOR_BayerBG2BGR_VNG , #COLOR_BayerGB2BGR_VNG , #COLOR_BayerRG2BGR_VNG , #COLOR_BayerGR2BGR_VNG
<span class="lineNum">    3572 </span>                :            : 
<span class="lineNum">    3573 </span>                :            : -   Edge-Aware Demosaicing.
<span class="lineNum">    3574 </span>                :            : 
<span class="lineNum">    3575 </span>                :            :     #COLOR_BayerBG2BGR_EA , #COLOR_BayerGB2BGR_EA , #COLOR_BayerRG2BGR_EA , #COLOR_BayerGR2BGR_EA
<span class="lineNum">    3576 </span>                :            : 
<span class="lineNum">    3577 </span>                :            : -   Demosaicing with alpha channel
<span class="lineNum">    3578 </span>                :            : 
<span class="lineNum">    3579 </span>                :            :     #COLOR_BayerBG2BGRA , #COLOR_BayerGB2BGRA , #COLOR_BayerRG2BGRA , #COLOR_BayerGR2BGRA
<span class="lineNum">    3580 </span>                :            : 
<span class="lineNum">    3581 </span>                :            : @sa cvtColor
<span class="lineNum">    3582 </span>                :            : */
<span class="lineNum">    3583 </span>                :            : CV_EXPORTS_W void demosaicing(InputArray src, OutputArray dst, int code, int dstCn = 0);
<span class="lineNum">    3584 </span>                :            : 
<span class="lineNum">    3585 </span>                :            : //! @} imgproc_color_conversions
<span class="lineNum">    3586 </span>                :            : 
<span class="lineNum">    3587 </span>                :            : //! @addtogroup imgproc_shape
<span class="lineNum">    3588 </span>                :            : //! @{
<span class="lineNum">    3589 </span>                :            : 
<span class="lineNum">    3590 </span>                :            : /** @brief Calculates all of the moments up to the third order of a polygon or rasterized shape.
<span class="lineNum">    3591 </span>                :            : 
<span class="lineNum">    3592 </span>                :            : The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The
<span class="lineNum">    3593 </span>                :            : results are returned in the structure cv::Moments.
<span class="lineNum">    3594 </span>                :            : 
<span class="lineNum">    3595 </span>                :            : @param array Raster image (single-channel, 8-bit or floating-point 2D array) or an array (
<span class="lineNum">    3596 </span>                :            : \f$1 \times N\f$ or \f$N \times 1\f$ ) of 2D points (Point or Point2f ).
<span class="lineNum">    3597 </span>                :            : @param binaryImage If it is true, all non-zero image pixels are treated as 1's. The parameter is
<span class="lineNum">    3598 </span>                :            : used for images only.
<span class="lineNum">    3599 </span>                :            : @returns moments.
<span class="lineNum">    3600 </span>                :            : 
<span class="lineNum">    3601 </span>                :            : @note Only applicable to contour moments calculations from Python bindings: Note that the numpy
<span class="lineNum">    3602 </span>                :            : type for the input array should be either np.int32 or np.float32.
<span class="lineNum">    3603 </span>                :            : 
<span class="lineNum">    3604 </span>                :            : @sa  contourArea, arcLength
<span class="lineNum">    3605 </span>                :            :  */
<span class="lineNum">    3606 </span>                :            : CV_EXPORTS_W Moments moments( InputArray array, bool binaryImage = false );
<span class="lineNum">    3607 </span>                :            : 
<span class="lineNum">    3608 </span>                :            : /** @brief Calculates seven Hu invariants.
<span class="lineNum">    3609 </span>                :            : 
<span class="lineNum">    3610 </span>                :            : The function calculates seven Hu invariants (introduced in @cite Hu62; see also
<span class="lineNum">    3611 </span>                :            : &lt;http://en.wikipedia.org/wiki/Image_moment&gt;) defined as:
<span class="lineNum">    3612 </span>                :            : 
<span class="lineNum">    3613 </span>                :            : \f[\begin{array}{l} hu[0]= \eta _{20}+ \eta _{02} \\ hu[1]=( \eta _{20}- \eta _{02})^{2}+4 \eta _{11}^{2} \\ hu[2]=( \eta _{30}-3 \eta _{12})^{2}+ (3 \eta _{21}- \eta _{03})^{2} \\ hu[3]=( \eta _{30}+ \eta _{12})^{2}+ ( \eta _{21}+ \eta _{03})^{2} \\ hu[4]=( \eta _{30}-3 \eta _{12})( \eta _{30}+ \eta _{12})[( \eta _{30}+ \eta _{12})^{2}-3( \eta _{21}+ \eta _{03})^{2}]+(3 \eta _{21}- \eta _{03})( \eta _{21}+ \eta _{03})[3( \eta _{30}+ \eta _{12})^{2}-( \eta _{21}+ \eta _{03})^{2}] \\ hu[5]=( \eta _{20}- \eta _{02})[( \eta _{30}+ \eta _{12})^{2}- ( \eta _{21}+ \eta _{03})^{2}]+4 \eta _{11}( \eta _{30}+ \eta _{12})( \eta _{21}+ \eta _{03}) \\ hu[6]=(3 \eta _{21}- \eta _{03})( \eta _{21}+ \eta _{03})[3( \eta _{30}+ \eta _{12})^{2}-( \eta _{21}+ \eta _{03})^{2}]-( \eta _{30}-3 \eta _{12})( \eta _{21}+ \eta _{03})[3( \eta _{30}+ \eta _{12})^{2}-( \eta _{21}+ \eta _{03})^{2}] \\ \end{array}\f]
<span class="lineNum">    3614 </span>                :            : 
<span class="lineNum">    3615 </span>                :            : where \f$\eta_{ji}\f$ stands for \f$\texttt{Moments::nu}_{ji}\f$ .
<span class="lineNum">    3616 </span>                :            : 
<span class="lineNum">    3617 </span>                :            : These values are proved to be invariants to the image scale, rotation, and reflection except the
<span class="lineNum">    3618 </span>                :            : seventh one, whose sign is changed by reflection. This invariance is proved with the assumption of
<span class="lineNum">    3619 </span>                :            : infinite image resolution. In case of raster images, the computed Hu invariants for the original and
<span class="lineNum">    3620 </span>                :            : transformed images are a bit different.
<span class="lineNum">    3621 </span>                :            : 
<span class="lineNum">    3622 </span>                :            : @param moments Input moments computed with moments .
<span class="lineNum">    3623 </span>                :            : @param hu Output Hu invariants.
<span class="lineNum">    3624 </span>                :            : 
<span class="lineNum">    3625 </span>                :            : @sa matchShapes
<span class="lineNum">    3626 </span>                :            :  */
<span class="lineNum">    3627 </span>                :            : CV_EXPORTS void HuMoments( const Moments&amp; moments, double hu[7] );
<span class="lineNum">    3628 </span>                :            : 
<span class="lineNum">    3629 </span>                :            : /** @overload */
<span class="lineNum">    3630 </span>                :            : CV_EXPORTS_W void HuMoments( const Moments&amp; m, OutputArray hu );
<span class="lineNum">    3631 </span>                :            : 
<span class="lineNum">    3632 </span>                :            : //! @} imgproc_shape
<span class="lineNum">    3633 </span>                :            : 
<span class="lineNum">    3634 </span>                :            : //! @addtogroup imgproc_object
<span class="lineNum">    3635 </span>                :            : //! @{
<span class="lineNum">    3636 </span>                :            : 
<span class="lineNum">    3637 </span>                :            : //! type of the template matching operation
<span class="lineNum">    3638 </span>                :            : enum TemplateMatchModes {
<span class="lineNum">    3639 </span>                :            :     TM_SQDIFF        = 0, //!&lt; \f[R(x,y)= \sum _{x',y'} (T(x',y')-I(x+x',y+y'))^2\f]
<span class="lineNum">    3640 </span>                :            :     TM_SQDIFF_NORMED = 1, //!&lt; \f[R(x,y)= \frac{\sum_{x',y'} (T(x',y')-I(x+x',y+y'))^2}{\sqrt{\sum_{x',y'}T(x',y')^2 \cdot \sum_{x',y'} I(x+x',y+y')^2}}\f]
<span class="lineNum">    3641 </span>                :            :     TM_CCORR         = 2, //!&lt; \f[R(x,y)= \sum _{x',y'} (T(x',y')  \cdot I(x+x',y+y'))\f]
<span class="lineNum">    3642 </span>                :            :     TM_CCORR_NORMED  = 3, //!&lt; \f[R(x,y)= \frac{\sum_{x',y'} (T(x',y') \cdot I(x+x',y+y'))}{\sqrt{\sum_{x',y'}T(x',y')^2 \cdot \sum_{x',y'} I(x+x',y+y')^2}}\f]
<span class="lineNum">    3643 </span>                :            :     TM_CCOEFF        = 4, //!&lt; \f[R(x,y)= \sum _{x',y'} (T'(x',y')  \cdot I'(x+x',y+y'))\f]
<span class="lineNum">    3644 </span>                :            :                           //!&lt; where
<span class="lineNum">    3645 </span>                :            :                           //!&lt; \f[\begin{array}{l} T'(x',y')=T(x',y') - 1/(w  \cdot h)  \cdot \sum _{x'',y''} T(x'',y'') \\ I'(x+x',y+y')=I(x+x',y+y') - 1/(w  \cdot h)  \cdot \sum _{x'',y''} I(x+x'',y+y'') \end{array}\f]
<span class="lineNum">    3646 </span>                :            :     TM_CCOEFF_NORMED = 5  //!&lt; \f[R(x,y)= \frac{ \sum_{x',y'} (T'(x',y') \cdot I'(x+x',y+y')) }{ \sqrt{\sum_{x',y'}T'(x',y')^2 \cdot \sum_{x',y'} I'(x+x',y+y')^2} }\f]
<span class="lineNum">    3647 </span>                :            : };
<span class="lineNum">    3648 </span>                :            : 
<span class="lineNum">    3649 </span>                :            : /** @example samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp
<span class="lineNum">    3650 </span>                :            : An example using Template Matching algorithm
<span class="lineNum">    3651 </span>                :            : */
<span class="lineNum">    3652 </span>                :            : 
<span class="lineNum">    3653 </span>                :            : /** @brief Compares a template against overlapped image regions.
<span class="lineNum">    3654 </span>                :            : 
<span class="lineNum">    3655 </span>                :            : The function slides through image , compares the overlapped patches of size \f$w \times h\f$ against
<span class="lineNum">    3656 </span>                :            : templ using the specified method and stores the comparison results in result . Here are the formulae
<span class="lineNum">    3657 </span>                :            : for the available comparison methods ( \f$I\f$ denotes image, \f$T\f$ template, \f$R\f$ result ). The summation
<span class="lineNum">    3658 </span>                :            : is done over template and/or the image patch: \f$x' = 0...w-1, y' = 0...h-1\f$
<span class="lineNum">    3659 </span>                :            : 
<span class="lineNum">    3660 </span>                :            : After the function finishes the comparison, the best matches can be found as global minimums (when
<span class="lineNum">    3661 </span>                :            : #TM_SQDIFF was used) or maximums (when #TM_CCORR or #TM_CCOEFF was used) using the
<span class="lineNum">    3662 </span>                :            : #minMaxLoc function. In case of a color image, template summation in the numerator and each sum in
<span class="lineNum">    3663 </span>                :            : the denominator is done over all of the channels and separate mean values are used for each channel.
<span class="lineNum">    3664 </span>                :            : That is, the function can take a color template and a color image. The result will still be a
<span class="lineNum">    3665 </span>                :            : single-channel image, which is easier to analyze.
<span class="lineNum">    3666 </span>                :            : 
<span class="lineNum">    3667 </span>                :            : @param image Image where the search is running. It must be 8-bit or 32-bit floating-point.
<span class="lineNum">    3668 </span>                :            : @param templ Searched template. It must be not greater than the source image and have the same
<span class="lineNum">    3669 </span>                :            : data type.
<span class="lineNum">    3670 </span>                :            : @param result Map of comparison results. It must be single-channel 32-bit floating-point. If image
<span class="lineNum">    3671 </span>                :            : is \f$W \times H\f$ and templ is \f$w \times h\f$ , then result is \f$(W-w+1) \times (H-h+1)\f$ .
<span class="lineNum">    3672 </span>                :            : @param method Parameter specifying the comparison method, see #TemplateMatchModes
<span class="lineNum">    3673 </span>                :            : @param mask Mask of searched template. It must have the same datatype and size with templ. It is
<span class="lineNum">    3674 </span>                :            : not set by default. Currently, only the #TM_SQDIFF and #TM_CCORR_NORMED methods are supported.
<span class="lineNum">    3675 </span>                :            :  */
<span class="lineNum">    3676 </span>                :            : CV_EXPORTS_W void matchTemplate( InputArray image, InputArray templ,
<span class="lineNum">    3677 </span>                :            :                                  OutputArray result, int method, InputArray mask = noArray() );
<span class="lineNum">    3678 </span>                :            : 
<span class="lineNum">    3679 </span>                :            : //! @}
<span class="lineNum">    3680 </span>                :            : 
<span class="lineNum">    3681 </span>                :            : //! @addtogroup imgproc_shape
<span class="lineNum">    3682 </span>                :            : //! @{
<span class="lineNum">    3683 </span>                :            : 
<span class="lineNum">    3684 </span>                :            : /** @example samples/cpp/connected_components.cpp
<span class="lineNum">    3685 </span>                :            : This program demonstrates connected components and use of the trackbar
<span class="lineNum">    3686 </span>                :            : */
<span class="lineNum">    3687 </span>                :            : 
<span class="lineNum">    3688 </span>                :            : /** @brief computes the connected components labeled image of boolean image
<span class="lineNum">    3689 </span>                :            : 
<span class="lineNum">    3690 </span>                :            : image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
<span class="lineNum">    3691 </span>                :            : represents the background label. ltype specifies the output label image type, an important
<span class="lineNum">    3692 </span>                :            : consideration based on the total number of labels or alternatively the total number of pixels in
<span class="lineNum">    3693 </span>                :            : the source image. ccltype specifies the connected components labeling algorithm to use, currently
<span class="lineNum">    3694 </span>                :            : Grana (BBDT) and Wu's (SAUF) algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes
<span class="lineNum">    3695 </span>                :            : for details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not.
<span class="lineNum">    3696 </span>                :            : This function uses parallel version of both Grana and Wu's algorithms if at least one allowed
<span class="lineNum">    3697 </span>                :            : parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.
<span class="lineNum">    3698 </span>                :            : 
<span class="lineNum">    3699 </span>                :            : @param image the 8-bit single-channel image to be labeled
<span class="lineNum">    3700 </span>                :            : @param labels destination labeled image
<span class="lineNum">    3701 </span>                :            : @param connectivity 8 or 4 for 8-way or 4-way connectivity respectively
<span class="lineNum">    3702 </span>                :            : @param ltype output image label type. Currently CV_32S and CV_16U are supported.
<span class="lineNum">    3703 </span>                :            : @param ccltype connected components algorithm type (see the #ConnectedComponentsAlgorithmsTypes).
<span class="lineNum">    3704 </span>                :            : */
<span class="lineNum">    3705 </span>                :            : CV_EXPORTS_AS(connectedComponentsWithAlgorithm) int connectedComponents(InputArray image, OutputArray labels,
<span class="lineNum">    3706 </span>                :            :                                                                         int connectivity, int ltype, int ccltype);
<span class="lineNum">    3707 </span>                :            : 
<span class="lineNum">    3708 </span>                :            : 
<span class="lineNum">    3709 </span>                :            : /** @overload
<span class="lineNum">    3710 </span>                :            : 
<span class="lineNum">    3711 </span>                :            : @param image the 8-bit single-channel image to be labeled
<span class="lineNum">    3712 </span>                :            : @param labels destination labeled image
<span class="lineNum">    3713 </span>                :            : @param connectivity 8 or 4 for 8-way or 4-way connectivity respectively
<span class="lineNum">    3714 </span>                :            : @param ltype output image label type. Currently CV_32S and CV_16U are supported.
<span class="lineNum">    3715 </span>                :            : */
<span class="lineNum">    3716 </span>                :            : CV_EXPORTS_W int connectedComponents(InputArray image, OutputArray labels,
<span class="lineNum">    3717 </span>                :            :                                      int connectivity = 8, int ltype = CV_32S);
<span class="lineNum">    3718 </span>                :            : 
<span class="lineNum">    3719 </span>                :            : 
<span class="lineNum">    3720 </span>                :            : /** @brief computes the connected components labeled image of boolean image and also produces a statistics output for each label
<span class="lineNum">    3721 </span>                :            : 
<span class="lineNum">    3722 </span>                :            : image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
<span class="lineNum">    3723 </span>                :            : represents the background label. ltype specifies the output label image type, an important
<span class="lineNum">    3724 </span>                :            : consideration based on the total number of labels or alternatively the total number of pixels in
<span class="lineNum">    3725 </span>                :            : the source image. ccltype specifies the connected components labeling algorithm to use, currently
<span class="lineNum">    3726 </span>                :            : Grana's (BBDT) and Wu's (SAUF) algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes
<span class="lineNum">    3727 </span>                :            : for details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not.
<span class="lineNum">    3728 </span>                :            : This function uses parallel version of both Grana and Wu's algorithms (statistics included) if at least one allowed
<span class="lineNum">    3729 </span>                :            : parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.
<span class="lineNum">    3730 </span>                :            : 
<span class="lineNum">    3731 </span>                :            : @param image the 8-bit single-channel image to be labeled
<span class="lineNum">    3732 </span>                :            : @param labels destination labeled image
<span class="lineNum">    3733 </span>                :            : @param stats statistics output for each label, including the background label, see below for
<span class="lineNum">    3734 </span>                :            : available statistics. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
<span class="lineNum">    3735 </span>                :            : #ConnectedComponentsTypes. The data type is CV_32S.
<span class="lineNum">    3736 </span>                :            : @param centroids centroid output for each label, including the background label. Centroids are
<span class="lineNum">    3737 </span>                :            : accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.
<span class="lineNum">    3738 </span>                :            : @param connectivity 8 or 4 for 8-way or 4-way connectivity respectively
<span class="lineNum">    3739 </span>                :            : @param ltype output image label type. Currently CV_32S and CV_16U are supported.
<span class="lineNum">    3740 </span>                :            : @param ccltype connected components algorithm type (see #ConnectedComponentsAlgorithmsTypes).
<span class="lineNum">    3741 </span>                :            : */
<span class="lineNum">    3742 </span>                :            : CV_EXPORTS_AS(connectedComponentsWithStatsWithAlgorithm) int connectedComponentsWithStats(InputArray image, OutputArray labels,
<span class="lineNum">    3743 </span>                :            :                                                                                           OutputArray stats, OutputArray centroids,
<span class="lineNum">    3744 </span>                :            :                                                                                           int connectivity, int ltype, int ccltype);
<span class="lineNum">    3745 </span>                :            : 
<span class="lineNum">    3746 </span>                :            : /** @overload
<span class="lineNum">    3747 </span>                :            : @param image the 8-bit single-channel image to be labeled
<span class="lineNum">    3748 </span>                :            : @param labels destination labeled image
<span class="lineNum">    3749 </span>                :            : @param stats statistics output for each label, including the background label, see below for
<span class="lineNum">    3750 </span>                :            : available statistics. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
<span class="lineNum">    3751 </span>                :            : #ConnectedComponentsTypes. The data type is CV_32S.
<span class="lineNum">    3752 </span>                :            : @param centroids centroid output for each label, including the background label. Centroids are
<span class="lineNum">    3753 </span>                :            : accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.
<span class="lineNum">    3754 </span>                :            : @param connectivity 8 or 4 for 8-way or 4-way connectivity respectively
<span class="lineNum">    3755 </span>                :            : @param ltype output image label type. Currently CV_32S and CV_16U are supported.
<span class="lineNum">    3756 </span>                :            : */
<span class="lineNum">    3757 </span>                :            : CV_EXPORTS_W int connectedComponentsWithStats(InputArray image, OutputArray labels,
<span class="lineNum">    3758 </span>                :            :                                               OutputArray stats, OutputArray centroids,
<span class="lineNum">    3759 </span>                :            :                                               int connectivity = 8, int ltype = CV_32S);
<span class="lineNum">    3760 </span>                :            : 
<span class="lineNum">    3761 </span>                :            : 
<span class="lineNum">    3762 </span>                :            : /** @brief Finds contours in a binary image.
<span class="lineNum">    3763 </span>                :            : 
<span class="lineNum">    3764 </span>                :            : The function retrieves contours from the binary image using the algorithm @cite Suzuki85 . The contours
<span class="lineNum">    3765 </span>                :            : are a useful tool for shape analysis and object detection and recognition. See squares.cpp in the
<span class="lineNum">    3766 </span>                :            : OpenCV sample directory.
<span class="lineNum">    3767 </span>                :            : @note Since opencv 3.2 source image is not modified by this function.
<span class="lineNum">    3768 </span>                :            : 
<span class="lineNum">    3769 </span>                :            : @param image Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero
<span class="lineNum">    3770 </span>                :            : pixels remain 0's, so the image is treated as binary . You can use #compare, #inRange, #threshold ,
<span class="lineNum">    3771 </span>                :            : #adaptiveThreshold, #Canny, and others to create a binary image out of a grayscale or color one.
<span class="lineNum">    3772 </span>                :            : If mode equals to #RETR_CCOMP or #RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1).
<span class="lineNum">    3773 </span>                :            : @param contours Detected contours. Each contour is stored as a vector of points (e.g.
<span class="lineNum">    3774 </span>                :            : std::vector&lt;std::vector&lt;cv::Point&gt; &gt;).
<span class="lineNum">    3775 </span>                :            : @param hierarchy Optional output vector (e.g. std::vector&lt;cv::Vec4i&gt;), containing information about the image topology. It has
<span class="lineNum">    3776 </span>                :            : as many elements as the number of contours. For each i-th contour contours[i], the elements
<span class="lineNum">    3777 </span>                :            : hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices
<span class="lineNum">    3778 </span>                :            : in contours of the next and previous contours at the same hierarchical level, the first child
<span class="lineNum">    3779 </span>                :            : contour and the parent contour, respectively. If for the contour i there are no next, previous,
<span class="lineNum">    3780 </span>                :            : parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.
<span class="lineNum">    3781 </span>                :            : @param mode Contour retrieval mode, see #RetrievalModes
<span class="lineNum">    3782 </span>                :            : @param method Contour approximation method, see #ContourApproximationModes
<span class="lineNum">    3783 </span>                :            : @param offset Optional offset by which every contour point is shifted. This is useful if the
<span class="lineNum">    3784 </span>                :            : contours are extracted from the image ROI and then they should be analyzed in the whole image
<span class="lineNum">    3785 </span>                :            : context.
<span class="lineNum">    3786 </span>                :            :  */
<span class="lineNum">    3787 </span>                :            : CV_EXPORTS_W void findContours( InputArray image, OutputArrayOfArrays contours,
<span class="lineNum">    3788 </span>                :            :                               OutputArray hierarchy, int mode,
<span class="lineNum">    3789 </span>                :            :                               int method, Point offset = Point());
<span class="lineNum">    3790 </span>                :            : 
<span class="lineNum">    3791 </span>                :            : /** @overload */
<span class="lineNum">    3792 </span>                :            : CV_EXPORTS void findContours( InputArray image, OutputArrayOfArrays contours,
<span class="lineNum">    3793 </span>                :            :                               int mode, int method, Point offset = Point());
<span class="lineNum">    3794 </span>                :            : 
<span class="lineNum">    3795 </span>                :            : /** @example samples/cpp/squares.cpp
<span class="lineNum">    3796 </span>                :            : A program using pyramid scaling, Canny, contours and contour simplification to find
<span class="lineNum">    3797 </span>                :            : squares in a list of images (pic1-6.png). Returns sequence of squares detected on the image.
<span class="lineNum">    3798 </span>                :            : */
<span class="lineNum">    3799 </span>                :            : 
<span class="lineNum">    3800 </span>                :            : /** @example samples/tapi/squares.cpp
<span class="lineNum">    3801 </span>                :            : A program using pyramid scaling, Canny, contours and contour simplification to find
<span class="lineNum">    3802 </span>                :            : squares in the input image.
<span class="lineNum">    3803 </span>                :            : */
<span class="lineNum">    3804 </span>                :            : 
<span class="lineNum">    3805 </span>                :            : /** @brief Approximates a polygonal curve(s) with the specified precision.
<span class="lineNum">    3806 </span>                :            : 
<span class="lineNum">    3807 </span>                :            : The function cv::approxPolyDP approximates a curve or a polygon with another curve/polygon with less
<span class="lineNum">    3808 </span>                :            : vertices so that the distance between them is less or equal to the specified precision. It uses the
<span class="lineNum">    3809 </span>                :            : Douglas-Peucker algorithm &lt;http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm&gt;
<span class="lineNum">    3810 </span>                :            : 
<span class="lineNum">    3811 </span>                :            : @param curve Input vector of a 2D point stored in std::vector or Mat
<span class="lineNum">    3812 </span>                :            : @param approxCurve Result of the approximation. The type should match the type of the input curve.
<span class="lineNum">    3813 </span>                :            : @param epsilon Parameter specifying the approximation accuracy. This is the maximum distance
<span class="lineNum">    3814 </span>                :            : between the original curve and its approximation.
<span class="lineNum">    3815 </span>                :            : @param closed If true, the approximated curve is closed (its first and last vertices are
<span class="lineNum">    3816 </span>                :            : connected). Otherwise, it is not closed.
<span class="lineNum">    3817 </span>                :            :  */
<span class="lineNum">    3818 </span>                :            : CV_EXPORTS_W void approxPolyDP( InputArray curve,
<span class="lineNum">    3819 </span>                :            :                                 OutputArray approxCurve,
<span class="lineNum">    3820 </span>                :            :                                 double epsilon, bool closed );
<span class="lineNum">    3821 </span>                :            : 
<span class="lineNum">    3822 </span>                :            : /** @brief Calculates a contour perimeter or a curve length.
<span class="lineNum">    3823 </span>                :            : 
<span class="lineNum">    3824 </span>                :            : The function computes a curve length or a closed contour perimeter.
<span class="lineNum">    3825 </span>                :            : 
<span class="lineNum">    3826 </span>                :            : @param curve Input vector of 2D points, stored in std::vector or Mat.
<span class="lineNum">    3827 </span>                :            : @param closed Flag indicating whether the curve is closed or not.
<span class="lineNum">    3828 </span>                :            :  */
<span class="lineNum">    3829 </span>                :            : CV_EXPORTS_W double arcLength( InputArray curve, bool closed );
<span class="lineNum">    3830 </span>                :            : 
<span class="lineNum">    3831 </span>                :            : /** @brief Calculates the up-right bounding rectangle of a point set or non-zero pixels of gray-scale image.
<span class="lineNum">    3832 </span>                :            : 
<span class="lineNum">    3833 </span>                :            : The function calculates and returns the minimal up-right bounding rectangle for the specified point set or
<span class="lineNum">    3834 </span>                :            : non-zero pixels of gray-scale image.
<span class="lineNum">    3835 </span>                :            : 
<span class="lineNum">    3836 </span>                :            : @param array Input gray-scale image or 2D point set, stored in std::vector or Mat.
<span class="lineNum">    3837 </span>                :            :  */
<span class="lineNum">    3838 </span>                :            : CV_EXPORTS_W Rect boundingRect( InputArray array );
<span class="lineNum">    3839 </span>                :            : 
<span class="lineNum">    3840 </span>                :            : /** @brief Calculates a contour area.
<span class="lineNum">    3841 </span>                :            : 
<span class="lineNum">    3842 </span>                :            : The function computes a contour area. Similarly to moments , the area is computed using the Green
<span class="lineNum">    3843 </span>                :            : formula. Thus, the returned area and the number of non-zero pixels, if you draw the contour using
<span class="lineNum">    3844 </span>                :            : #drawContours or #fillPoly , can be different. Also, the function will most certainly give a wrong
<span class="lineNum">    3845 </span>                :            : results for contours with self-intersections.
<span class="lineNum">    3846 </span>                :            : 
<span class="lineNum">    3847 </span>                :            : Example:
<span class="lineNum">    3848 </span>                :            : @code
<span class="lineNum">    3849 </span>                :            :     vector&lt;Point&gt; contour;
<span class="lineNum">    3850 </span>                :            :     contour.push_back(Point2f(0, 0));
<span class="lineNum">    3851 </span>                :            :     contour.push_back(Point2f(10, 0));
<span class="lineNum">    3852 </span>                :            :     contour.push_back(Point2f(10, 10));
<span class="lineNum">    3853 </span>                :            :     contour.push_back(Point2f(5, 4));
<span class="lineNum">    3854 </span>                :            : 
<span class="lineNum">    3855 </span>                :            :     double area0 = contourArea(contour);
<span class="lineNum">    3856 </span>                :            :     vector&lt;Point&gt; approx;
<span class="lineNum">    3857 </span>                :            :     approxPolyDP(contour, approx, 5, true);
<span class="lineNum">    3858 </span>                :            :     double area1 = contourArea(approx);
<span class="lineNum">    3859 </span>                :            : 
<span class="lineNum">    3860 </span>                :            :     cout &lt;&lt; &quot;area0 =&quot; &lt;&lt; area0 &lt;&lt; endl &lt;&lt;
<span class="lineNum">    3861 </span>                :            :             &quot;area1 =&quot; &lt;&lt; area1 &lt;&lt; endl &lt;&lt;
<span class="lineNum">    3862 </span>                :            :             &quot;approx poly vertices&quot; &lt;&lt; approx.size() &lt;&lt; endl;
<span class="lineNum">    3863 </span>                :            : @endcode
<span class="lineNum">    3864 </span>                :            : @param contour Input vector of 2D points (contour vertices), stored in std::vector or Mat.
<span class="lineNum">    3865 </span>                :            : @param oriented Oriented area flag. If it is true, the function returns a signed area value,
<span class="lineNum">    3866 </span>                :            : depending on the contour orientation (clockwise or counter-clockwise). Using this feature you can
<span class="lineNum">    3867 </span>                :            : determine orientation of a contour by taking the sign of an area. By default, the parameter is
<span class="lineNum">    3868 </span>                :            : false, which means that the absolute value is returned.
<span class="lineNum">    3869 </span>                :            :  */
<span class="lineNum">    3870 </span>                :            : CV_EXPORTS_W double contourArea( InputArray contour, bool oriented = false );
<span class="lineNum">    3871 </span>                :            : 
<span class="lineNum">    3872 </span>                :            : /** @brief Finds a rotated rectangle of the minimum area enclosing the input 2D point set.
<span class="lineNum">    3873 </span>                :            : 
<span class="lineNum">    3874 </span>                :            : The function calculates and returns the minimum-area bounding rectangle (possibly rotated) for a
<span class="lineNum">    3875 </span>                :            : specified point set. Developer should keep in mind that the returned RotatedRect can contain negative
<span class="lineNum">    3876 </span>                :            : indices when data is close to the containing Mat element boundary.
<span class="lineNum">    3877 </span>                :            : 
<span class="lineNum">    3878 </span>                :            : @param points Input vector of 2D points, stored in std::vector\&lt;\&gt; or Mat
<span class="lineNum">    3879 </span>                :            :  */
<span class="lineNum">    3880 </span>                :            : CV_EXPORTS_W RotatedRect minAreaRect( InputArray points );
<span class="lineNum">    3881 </span>                :            : 
<span class="lineNum">    3882 </span>                :            : /** @brief Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle.
<span class="lineNum">    3883 </span>                :            : 
<span class="lineNum">    3884 </span>                :            : The function finds the four vertices of a rotated rectangle. This function is useful to draw the
<span class="lineNum">    3885 </span>                :            : rectangle. In C++, instead of using this function, you can directly use RotatedRect::points method. Please
<span class="lineNum">    3886 </span>                :            : visit the @ref tutorial_bounding_rotated_ellipses &quot;tutorial on Creating Bounding rotated boxes and ellipses for contours&quot; for more information.
<span class="lineNum">    3887 </span>                :            : 
<span class="lineNum">    3888 </span>                :            : @param box The input rotated rectangle. It may be the output of
<span class="lineNum">    3889 </span>                :            : @param points The output array of four vertices of rectangles.
<span class="lineNum">    3890 </span>                :            :  */
<span class="lineNum">    3891 </span>                :            : CV_EXPORTS_W void boxPoints(RotatedRect box, OutputArray points);
<span class="lineNum">    3892 </span>                :            : 
<span class="lineNum">    3893 </span>                :            : /** @brief Finds a circle of the minimum area enclosing a 2D point set.
<span class="lineNum">    3894 </span>                :            : 
<span class="lineNum">    3895 </span>                :            : The function finds the minimal enclosing circle of a 2D point set using an iterative algorithm.
<span class="lineNum">    3896 </span>                :            : 
<span class="lineNum">    3897 </span>                :            : @param points Input vector of 2D points, stored in std::vector\&lt;\&gt; or Mat
<span class="lineNum">    3898 </span>                :            : @param center Output center of the circle.
<span class="lineNum">    3899 </span>                :            : @param radius Output radius of the circle.
<span class="lineNum">    3900 </span>                :            :  */
<span class="lineNum">    3901 </span>                :            : CV_EXPORTS_W void minEnclosingCircle( InputArray points,
<span class="lineNum">    3902 </span>                :            :                                       CV_OUT Point2f&amp; center, CV_OUT float&amp; radius );
<span class="lineNum">    3903 </span>                :            : 
<span class="lineNum">    3904 </span>                :            : /** @example samples/cpp/minarea.cpp
<span class="lineNum">    3905 </span>                :            : */
<span class="lineNum">    3906 </span>                :            : 
<span class="lineNum">    3907 </span>                :            : /** @brief Finds a triangle of minimum area enclosing a 2D point set and returns its area.
<span class="lineNum">    3908 </span>                :            : 
<span class="lineNum">    3909 </span>                :            : The function finds a triangle of minimum area enclosing the given set of 2D points and returns its
<span class="lineNum">    3910 </span>                :            : area. The output for a given 2D point set is shown in the image below. 2D points are depicted in
<span class="lineNum">    3911 </span>                :            : *red* and the enclosing triangle in *yellow*.
<span class="lineNum">    3912 </span>                :            : 
<span class="lineNum">    3913 </span>                :            : ![Sample output of the minimum enclosing triangle function](pics/minenclosingtriangle.png)
<span class="lineNum">    3914 </span>                :            : 
<span class="lineNum">    3915 </span>                :            : The implementation of the algorithm is based on O'Rourke's @cite ORourke86 and Klee and Laskowski's
<span class="lineNum">    3916 </span>                :            : @cite KleeLaskowski85 papers. O'Rourke provides a \f$\theta(n)\f$ algorithm for finding the minimal
<span class="lineNum">    3917 </span>                :            : enclosing triangle of a 2D convex polygon with n vertices. Since the #minEnclosingTriangle function
<span class="lineNum">    3918 </span>                :            : takes a 2D point set as input an additional preprocessing step of computing the convex hull of the
<span class="lineNum">    3919 </span>                :            : 2D point set is required. The complexity of the #convexHull function is \f$O(n log(n))\f$ which is higher
<span class="lineNum">    3920 </span>                :            : than \f$\theta(n)\f$. Thus the overall complexity of the function is \f$O(n log(n))\f$.
<span class="lineNum">    3921 </span>                :            : 
<span class="lineNum">    3922 </span>                :            : @param points Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector\&lt;\&gt; or Mat
<span class="lineNum">    3923 </span>                :            : @param triangle Output vector of three 2D points defining the vertices of the triangle. The depth
<span class="lineNum">    3924 </span>                :            : of the OutputArray must be CV_32F.
<span class="lineNum">    3925 </span>                :            :  */
<span class="lineNum">    3926 </span>                :            : CV_EXPORTS_W double minEnclosingTriangle( InputArray points, CV_OUT OutputArray triangle );
<span class="lineNum">    3927 </span>                :            : 
<span class="lineNum">    3928 </span>                :            : /** @brief Compares two shapes.
<span class="lineNum">    3929 </span>                :            : 
<span class="lineNum">    3930 </span>                :            : The function compares two shapes. All three implemented methods use the Hu invariants (see #HuMoments)
<span class="lineNum">    3931 </span>                :            : 
<span class="lineNum">    3932 </span>                :            : @param contour1 First contour or grayscale image.
<span class="lineNum">    3933 </span>                :            : @param contour2 Second contour or grayscale image.
<span class="lineNum">    3934 </span>                :            : @param method Comparison method, see #ShapeMatchModes
<span class="lineNum">    3935 </span>                :            : @param parameter Method-specific parameter (not supported now).
<span class="lineNum">    3936 </span>                :            :  */
<span class="lineNum">    3937 </span>                :            : CV_EXPORTS_W double matchShapes( InputArray contour1, InputArray contour2,
<span class="lineNum">    3938 </span>                :            :                                  int method, double parameter );
<span class="lineNum">    3939 </span>                :            : 
<span class="lineNum">    3940 </span>                :            : /** @example samples/cpp/convexhull.cpp
<span class="lineNum">    3941 </span>                :            : An example using the convexHull functionality
<span class="lineNum">    3942 </span>                :            : */
<span class="lineNum">    3943 </span>                :            : 
<span class="lineNum">    3944 </span>                :            : /** @brief Finds the convex hull of a point set.
<span class="lineNum">    3945 </span>                :            : 
<span class="lineNum">    3946 </span>                :            : The function cv::convexHull finds the convex hull of a 2D point set using the Sklansky's algorithm @cite Sklansky82
<span class="lineNum">    3947 </span>                :            : that has *O(N logN)* complexity in the current implementation.
<span class="lineNum">    3948 </span>                :            : 
<span class="lineNum">    3949 </span>                :            : @param points Input 2D point set, stored in std::vector or Mat.
<span class="lineNum">    3950 </span>                :            : @param hull Output convex hull. It is either an integer vector of indices or vector of points. In
<span class="lineNum">    3951 </span>                :            : the first case, the hull elements are 0-based indices of the convex hull points in the original
<span class="lineNum">    3952 </span>                :            : array (since the set of convex hull points is a subset of the original point set). In the second
<span class="lineNum">    3953 </span>                :            : case, hull elements are the convex hull points themselves.
<span class="lineNum">    3954 </span>                :            : @param clockwise Orientation flag. If it is true, the output convex hull is oriented clockwise.
<span class="lineNum">    3955 </span>                :            : Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing
<span class="lineNum">    3956 </span>                :            : to the right, and its Y axis pointing upwards.
<span class="lineNum">    3957 </span>                :            : @param returnPoints Operation flag. In case of a matrix, when the flag is true, the function
<span class="lineNum">    3958 </span>                :            : returns convex hull points. Otherwise, it returns indices of the convex hull points. When the
<span class="lineNum">    3959 </span>                :            : output array is std::vector, the flag is ignored, and the output depends on the type of the
<span class="lineNum">    3960 </span>                :            : vector: std::vector\&lt;int\&gt; implies returnPoints=false, std::vector\&lt;Point\&gt; implies
<span class="lineNum">    3961 </span>                :            : returnPoints=true.
<span class="lineNum">    3962 </span>                :            : 
<span class="lineNum">    3963 </span>                :            : @note `points` and `hull` should be different arrays, inplace processing isn't supported.
<span class="lineNum">    3964 </span>                :            : 
<span class="lineNum">    3965 </span>                :            : Check @ref tutorial_hull &quot;the corresponding tutorial&quot; for more details.
<span class="lineNum">    3966 </span>                :            : 
<span class="lineNum">    3967 </span>                :            : useful links:
<span class="lineNum">    3968 </span>                :            : 
<span class="lineNum">    3969 </span>                :            : https://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/
<span class="lineNum">    3970 </span>                :            :  */
<span class="lineNum">    3971 </span>                :            : CV_EXPORTS_W void convexHull( InputArray points, OutputArray hull,
<span class="lineNum">    3972 </span>                :            :                               bool clockwise = false, bool returnPoints = true );
<span class="lineNum">    3973 </span>                :            : 
<span class="lineNum">    3974 </span>                :            : /** @brief Finds the convexity defects of a contour.
<span class="lineNum">    3975 </span>                :            : 
<span class="lineNum">    3976 </span>                :            : The figure below displays convexity defects of a hand contour:
<span class="lineNum">    3977 </span>                :            : 
<span class="lineNum">    3978 </span>                :            : ![image](pics/defects.png)
<span class="lineNum">    3979 </span>                :            : 
<span class="lineNum">    3980 </span>                :            : @param contour Input contour.
<span class="lineNum">    3981 </span>                :            : @param convexhull Convex hull obtained using convexHull that should contain indices of the contour
<span class="lineNum">    3982 </span>                :            : points that make the hull.
<span class="lineNum">    3983 </span>                :            : @param convexityDefects The output vector of convexity defects. In C++ and the new Python/Java
<span class="lineNum">    3984 </span>                :            : interface each convexity defect is represented as 4-element integer vector (a.k.a. #Vec4i):
<span class="lineNum">    3985 </span>                :            : (start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices
<span class="lineNum">    3986 </span>                :            : in the original contour of the convexity defect beginning, end and the farthest point, and
<span class="lineNum">    3987 </span>                :            : fixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the
<span class="lineNum">    3988 </span>                :            : farthest contour point and the hull. That is, to get the floating-point value of the depth will be
<span class="lineNum">    3989 </span>                :            : fixpt_depth/256.0.
<span class="lineNum">    3990 </span>                :            :  */
<span class="lineNum">    3991 </span>                :            : CV_EXPORTS_W void convexityDefects( InputArray contour, InputArray convexhull, OutputArray convexityDefects );
<span class="lineNum">    3992 </span>                :            : 
<span class="lineNum">    3993 </span>                :            : /** @brief Tests a contour convexity.
<span class="lineNum">    3994 </span>                :            : 
<span class="lineNum">    3995 </span>                :            : The function tests whether the input contour is convex or not. The contour must be simple, that is,
<span class="lineNum">    3996 </span>                :            : without self-intersections. Otherwise, the function output is undefined.
<span class="lineNum">    3997 </span>                :            : 
<span class="lineNum">    3998 </span>                :            : @param contour Input vector of 2D points, stored in std::vector\&lt;\&gt; or Mat
<span class="lineNum">    3999 </span>                :            :  */
<span class="lineNum">    4000 </span>                :            : CV_EXPORTS_W bool isContourConvex( InputArray contour );
<span class="lineNum">    4001 </span>                :            : 
<span class="lineNum">    4002 </span>                :            : //! finds intersection of two convex polygons
<span class="lineNum">    4003 </span>                :            : CV_EXPORTS_W float intersectConvexConvex( InputArray _p1, InputArray _p2,
<span class="lineNum">    4004 </span>                :            :                                           OutputArray _p12, bool handleNested = true );
<span class="lineNum">    4005 </span>                :            : 
<span class="lineNum">    4006 </span>                :            : /** @example samples/cpp/fitellipse.cpp
<span class="lineNum">    4007 </span>                :            : An example using the fitEllipse technique
<span class="lineNum">    4008 </span>                :            : */
<span class="lineNum">    4009 </span>                :            : 
<span class="lineNum">    4010 </span>                :            : /** @brief Fits an ellipse around a set of 2D points.
<span class="lineNum">    4011 </span>                :            : 
<span class="lineNum">    4012 </span>                :            : The function calculates the ellipse that fits (in a least-squares sense) a set of 2D points best of
<span class="lineNum">    4013 </span>                :            : all. It returns the rotated rectangle in which the ellipse is inscribed. The first algorithm described by @cite Fitzgibbon95
<span class="lineNum">    4014 </span>                :            : is used. Developer should keep in mind that it is possible that the returned
<span class="lineNum">    4015 </span>                :            : ellipse/rotatedRect data contains negative indices, due to the data points being close to the
<span class="lineNum">    4016 </span>                :            : border of the containing Mat element.
<span class="lineNum">    4017 </span>                :            : 
<span class="lineNum">    4018 </span>                :            : @param points Input 2D point set, stored in std::vector\&lt;\&gt; or Mat
<span class="lineNum">    4019 </span>                :            :  */
<span class="lineNum">    4020 </span>                :            : CV_EXPORTS_W RotatedRect fitEllipse( InputArray points );
<span class="lineNum">    4021 </span>                :            : 
<span class="lineNum">    4022 </span>                :            : /** @brief Fits an ellipse around a set of 2D points.
<span class="lineNum">    4023 </span>                :            : 
<span class="lineNum">    4024 </span>                :            :  The function calculates the ellipse that fits a set of 2D points.
<span class="lineNum">    4025 </span>                :            :  It returns the rotated rectangle in which the ellipse is inscribed.
<span class="lineNum">    4026 </span>                :            :  The Approximate Mean Square (AMS) proposed by @cite Taubin1991 is used.
<span class="lineNum">    4027 </span>                :            : 
<span class="lineNum">    4028 </span>                :            :  For an ellipse, this basis set is \f$ \chi= \left(x^2, x y, y^2, x, y, 1\right) \f$,
<span class="lineNum">    4029 </span>                :            :  which is a set of six free coefficients \f$ A^T=\left\{A_{\text{xx}},A_{\text{xy}},A_{\text{yy}},A_x,A_y,A_0\right\} \f$.
<span class="lineNum">    4030 </span>                :            :  However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \f$ (a,b) \f$,
<span class="lineNum">    4031 </span>                :            :  the position \f$ (x_0,y_0) \f$, and the orientation \f$ \theta \f$. This is because the basis set includes lines,
<span class="lineNum">    4032 </span>                :            :  quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits.
<span class="lineNum">    4033 </span>                :            :  If the fit is found to be a parabolic or hyperbolic function then the standard #fitEllipse method is used.
<span class="lineNum">    4034 </span>                :            :  The AMS method restricts the fit to parabolic, hyperbolic and elliptical curves
<span class="lineNum">    4035 </span>                :            :  by imposing the condition that \f$ A^T ( D_x^T D_x  +   D_y^T D_y) A = 1 \f$ where
<span class="lineNum">    4036 </span>                :            :  the matrices \f$ Dx \f$ and \f$ Dy \f$ are the partial derivatives of the design matrix \f$ D \f$ with
<span class="lineNum">    4037 </span>                :            :  respect to x and y. The matrices are formed row by row applying the following to
<span class="lineNum">    4038 </span>                :            :  each of the points in the set:
<span class="lineNum">    4039 </span>                :            :  \f{align*}{
<span class="lineNum">    4040 </span>                :            :  D(i,:)&amp;=\left\{x_i^2, x_i y_i, y_i^2, x_i, y_i, 1\right\} &amp;
<span class="lineNum">    4041 </span>                :            :  D_x(i,:)&amp;=\left\{2 x_i,y_i,0,1,0,0\right\} &amp;
<span class="lineNum">    4042 </span>                :            :  D_y(i,:)&amp;=\left\{0,x_i,2 y_i,0,1,0\right\}
<span class="lineNum">    4043 </span>                :            :  \f}
<span class="lineNum">    4044 </span>                :            :  The AMS method minimizes the cost function
<span class="lineNum">    4045 </span>                :            :  \f{equation*}{
<span class="lineNum">    4046 </span>                :            :  \epsilon ^2=\frac{ A^T D^T D A }{ A^T (D_x^T D_x +  D_y^T D_y) A^T }
<span class="lineNum">    4047 </span>                :            :  \f}
<span class="lineNum">    4048 </span>                :            : 
<span class="lineNum">    4049 </span>                :            :  The minimum cost is found by solving the generalized eigenvalue problem.
<span class="lineNum">    4050 </span>                :            : 
<span class="lineNum">    4051 </span>                :            :  \f{equation*}{
<span class="lineNum">    4052 </span>                :            :  D^T D A = \lambda  \left( D_x^T D_x +  D_y^T D_y\right) A
<span class="lineNum">    4053 </span>                :            :  \f}
<span class="lineNum">    4054 </span>                :            : 
<span class="lineNum">    4055 </span>                :            :  @param points Input 2D point set, stored in std::vector\&lt;\&gt; or Mat
<span class="lineNum">    4056 </span>                :            :  */
<span class="lineNum">    4057 </span>                :            : CV_EXPORTS_W RotatedRect fitEllipseAMS( InputArray points );
<span class="lineNum">    4058 </span>                :            : 
<span class="lineNum">    4059 </span>                :            : 
<span class="lineNum">    4060 </span>                :            : /** @brief Fits an ellipse around a set of 2D points.
<span class="lineNum">    4061 </span>                :            : 
<span class="lineNum">    4062 </span>                :            :  The function calculates the ellipse that fits a set of 2D points.
<span class="lineNum">    4063 </span>                :            :  It returns the rotated rectangle in which the ellipse is inscribed.
<span class="lineNum">    4064 </span>                :            :  The Direct least square (Direct) method by @cite Fitzgibbon1999 is used.
<span class="lineNum">    4065 </span>                :            : 
<span class="lineNum">    4066 </span>                :            :  For an ellipse, this basis set is \f$ \chi= \left(x^2, x y, y^2, x, y, 1\right) \f$,
<span class="lineNum">    4067 </span>                :            :  which is a set of six free coefficients \f$ A^T=\left\{A_{\text{xx}},A_{\text{xy}},A_{\text{yy}},A_x,A_y,A_0\right\} \f$.
<span class="lineNum">    4068 </span>                :            :  However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \f$ (a,b) \f$,
<span class="lineNum">    4069 </span>                :            :  the position \f$ (x_0,y_0) \f$, and the orientation \f$ \theta \f$. This is because the basis set includes lines,
<span class="lineNum">    4070 </span>                :            :  quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits.
<span class="lineNum">    4071 </span>                :            :  The Direct method confines the fit to ellipses by ensuring that \f$ 4 A_{xx} A_{yy}- A_{xy}^2 &gt; 0 \f$.
<span class="lineNum">    4072 </span>                :            :  The condition imposed is that \f$ 4 A_{xx} A_{yy}- A_{xy}^2=1 \f$ which satisfies the inequality
<span class="lineNum">    4073 </span>                :            :  and as the coefficients can be arbitrarily scaled is not overly restrictive.
<span class="lineNum">    4074 </span>                :            : 
<span class="lineNum">    4075 </span>                :            :  \f{equation*}{
<span class="lineNum">    4076 </span>                :            :  \epsilon ^2= A^T D^T D A \quad \text{with} \quad A^T C A =1 \quad \text{and} \quad C=\left(\begin{matrix}
<span class="lineNum">    4077 </span>                :            :  0 &amp; 0  &amp; 2  &amp; 0  &amp; 0  &amp;  0  \\
<span class="lineNum">    4078 </span>                :            :  0 &amp; -1  &amp; 0  &amp; 0  &amp; 0  &amp;  0 \\
<span class="lineNum">    4079 </span>                :            :  2 &amp; 0  &amp; 0  &amp; 0  &amp; 0  &amp;  0 \\
<span class="lineNum">    4080 </span>                :            :  0 &amp; 0  &amp; 0  &amp; 0  &amp; 0  &amp;  0 \\
<span class="lineNum">    4081 </span>                :            :  0 &amp; 0  &amp; 0  &amp; 0  &amp; 0  &amp;  0 \\
<span class="lineNum">    4082 </span>                :            :  0 &amp; 0  &amp; 0  &amp; 0  &amp; 0  &amp;  0
<span class="lineNum">    4083 </span>                :            :  \end{matrix} \right)
<span class="lineNum">    4084 </span>                :            :  \f}
<span class="lineNum">    4085 </span>                :            : 
<span class="lineNum">    4086 </span>                :            :  The minimum cost is found by solving the generalized eigenvalue problem.
<span class="lineNum">    4087 </span>                :            : 
<span class="lineNum">    4088 </span>                :            :  \f{equation*}{
<span class="lineNum">    4089 </span>                :            :  D^T D A = \lambda  \left( C\right) A
<span class="lineNum">    4090 </span>                :            :  \f}
<span class="lineNum">    4091 </span>                :            : 
<span class="lineNum">    4092 </span>                :            :  The system produces only one positive eigenvalue \f$ \lambda\f$ which is chosen as the solution
<span class="lineNum">    4093 </span>                :            :  with its eigenvector \f$\mathbf{u}\f$. These are used to find the coefficients
<span class="lineNum">    4094 </span>                :            : 
<span class="lineNum">    4095 </span>                :            :  \f{equation*}{
<span class="lineNum">    4096 </span>                :            :  A = \sqrt{\frac{1}{\mathbf{u}^T C \mathbf{u}}}  \mathbf{u}
<span class="lineNum">    4097 </span>                :            :  \f}
<span class="lineNum">    4098 </span>                :            :  The scaling factor guarantees that  \f$A^T C A =1\f$.
<span class="lineNum">    4099 </span>                :            : 
<span class="lineNum">    4100 </span>                :            :  @param points Input 2D point set, stored in std::vector\&lt;\&gt; or Mat
<span class="lineNum">    4101 </span>                :            :  */
<span class="lineNum">    4102 </span>                :            : CV_EXPORTS_W RotatedRect fitEllipseDirect( InputArray points );
<span class="lineNum">    4103 </span>                :            : 
<span class="lineNum">    4104 </span>                :            : /** @brief Fits a line to a 2D or 3D point set.
<span class="lineNum">    4105 </span>                :            : 
<span class="lineNum">    4106 </span>                :            : The function fitLine fits a line to a 2D or 3D point set by minimizing \f$\sum_i \rho(r_i)\f$ where
<span class="lineNum">    4107 </span>                :            : \f$r_i\f$ is a distance between the \f$i^{th}\f$ point, the line and \f$\rho(r)\f$ is a distance function, one
<span class="lineNum">    4108 </span>                :            : of the following:
<span class="lineNum">    4109 </span>                :            : -  DIST_L2
<span class="lineNum">    4110 </span>                :            : \f[\rho (r) = r^2/2  \quad \text{(the simplest and the fastest least-squares method)}\f]
<span class="lineNum">    4111 </span>                :            : - DIST_L1
<span class="lineNum">    4112 </span>                :            : \f[\rho (r) = r\f]
<span class="lineNum">    4113 </span>                :            : - DIST_L12
<span class="lineNum">    4114 </span>                :            : \f[\rho (r) = 2  \cdot ( \sqrt{1 + \frac{r^2}{2}} - 1)\f]
<span class="lineNum">    4115 </span>                :            : - DIST_FAIR
<span class="lineNum">    4116 </span>                :            : \f[\rho \left (r \right ) = C^2  \cdot \left (  \frac{r}{C} -  \log{\left(1 + \frac{r}{C}\right)} \right )  \quad \text{where} \quad C=1.3998\f]
<span class="lineNum">    4117 </span>                :            : - DIST_WELSCH
<span class="lineNum">    4118 </span>                :            : \f[\rho \left (r \right ) =  \frac{C^2}{2} \cdot \left ( 1 -  \exp{\left(-\left(\frac{r}{C}\right)^2\right)} \right )  \quad \text{where} \quad C=2.9846\f]
<span class="lineNum">    4119 </span>                :            : - DIST_HUBER
<span class="lineNum">    4120 </span>                :            : \f[\rho (r) =  \fork{r^2/2}{if \(r &lt; C\)}{C \cdot (r-C/2)}{otherwise} \quad \text{where} \quad C=1.345\f]
<span class="lineNum">    4121 </span>                :            : 
<span class="lineNum">    4122 </span>                :            : The algorithm is based on the M-estimator ( &lt;http://en.wikipedia.org/wiki/M-estimator&gt; ) technique
<span class="lineNum">    4123 </span>                :            : that iteratively fits the line using the weighted least-squares algorithm. After each iteration the
<span class="lineNum">    4124 </span>                :            : weights \f$w_i\f$ are adjusted to be inversely proportional to \f$\rho(r_i)\f$ .
<span class="lineNum">    4125 </span>                :            : 
<span class="lineNum">    4126 </span>                :            : @param points Input vector of 2D or 3D points, stored in std::vector\&lt;\&gt; or Mat.
<span class="lineNum">    4127 </span>                :            : @param line Output line parameters. In case of 2D fitting, it should be a vector of 4 elements
<span class="lineNum">    4128 </span>                :            : (like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line and
<span class="lineNum">    4129 </span>                :            : (x0, y0) is a point on the line. In case of 3D fitting, it should be a vector of 6 elements (like
<span class="lineNum">    4130 </span>                :            : Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector collinear to the line
<span class="lineNum">    4131 </span>                :            : and (x0, y0, z0) is a point on the line.
<span class="lineNum">    4132 </span>                :            : @param distType Distance used by the M-estimator, see #DistanceTypes
<span class="lineNum">    4133 </span>                :            : @param param Numerical parameter ( C ) for some types of distances. If it is 0, an optimal value
<span class="lineNum">    4134 </span>                :            : is chosen.
<span class="lineNum">    4135 </span>                :            : @param reps Sufficient accuracy for the radius (distance between the coordinate origin and the line).
<span class="lineNum">    4136 </span>                :            : @param aeps Sufficient accuracy for the angle. 0.01 would be a good default value for reps and aeps.
<span class="lineNum">    4137 </span>                :            :  */
<span class="lineNum">    4138 </span>                :            : CV_EXPORTS_W void fitLine( InputArray points, OutputArray line, int distType,
<span class="lineNum">    4139 </span>                :            :                            double param, double reps, double aeps );
<span class="lineNum">    4140 </span>                :            : 
<span class="lineNum">    4141 </span>                :            : /** @brief Performs a point-in-contour test.
<span class="lineNum">    4142 </span>                :            : 
<span class="lineNum">    4143 </span>                :            : The function determines whether the point is inside a contour, outside, or lies on an edge (or
<span class="lineNum">    4144 </span>                :            : coincides with a vertex). It returns positive (inside), negative (outside), or zero (on an edge)
<span class="lineNum">    4145 </span>                :            : value, correspondingly. When measureDist=false , the return value is +1, -1, and 0, respectively.
<span class="lineNum">    4146 </span>                :            : Otherwise, the return value is a signed distance between the point and the nearest contour edge.
<span class="lineNum">    4147 </span>                :            : 
<span class="lineNum">    4148 </span>                :            : See below a sample output of the function where each image pixel is tested against the contour:
<span class="lineNum">    4149 </span>                :            : 
<span class="lineNum">    4150 </span>                :            : ![sample output](pics/pointpolygon.png)
<span class="lineNum">    4151 </span>                :            : 
<span class="lineNum">    4152 </span>                :            : @param contour Input contour.
<span class="lineNum">    4153 </span>                :            : @param pt Point tested against the contour.
<span class="lineNum">    4154 </span>                :            : @param measureDist If true, the function estimates the signed distance from the point to the
<span class="lineNum">    4155 </span>                :            : nearest contour edge. Otherwise, the function only checks if the point is inside a contour or not.
<span class="lineNum">    4156 </span>                :            :  */
<span class="lineNum">    4157 </span>                :            : CV_EXPORTS_W double pointPolygonTest( InputArray contour, Point2f pt, bool measureDist );
<span class="lineNum">    4158 </span>                :            : 
<span class="lineNum">    4159 </span>                :            : /** @brief Finds out if there is any intersection between two rotated rectangles.
<span class="lineNum">    4160 </span>                :            : 
<span class="lineNum">    4161 </span>                :            : If there is then the vertices of the intersecting region are returned as well.
<span class="lineNum">    4162 </span>                :            : 
<span class="lineNum">    4163 </span>                :            : Below are some examples of intersection configurations. The hatched pattern indicates the
<span class="lineNum">    4164 </span>                :            : intersecting region and the red vertices are returned by the function.
<span class="lineNum">    4165 </span>                :            : 
<span class="lineNum">    4166 </span>                :            : ![intersection examples](pics/intersection.png)
<span class="lineNum">    4167 </span>                :            : 
<span class="lineNum">    4168 </span>                :            : @param rect1 First rectangle
<span class="lineNum">    4169 </span>                :            : @param rect2 Second rectangle
<span class="lineNum">    4170 </span>                :            : @param intersectingRegion The output array of the vertices of the intersecting region. It returns
<span class="lineNum">    4171 </span>                :            : at most 8 vertices. Stored as std::vector\&lt;cv::Point2f\&gt; or cv::Mat as Mx1 of type CV_32FC2.
<span class="lineNum">    4172 </span>                :            : @returns One of #RectanglesIntersectTypes
<span class="lineNum">    4173 </span>                :            :  */
<span class="lineNum">    4174 </span>                :            : CV_EXPORTS_W int rotatedRectangleIntersection( const RotatedRect&amp; rect1, const RotatedRect&amp; rect2, OutputArray intersectingRegion  );
<span class="lineNum">    4175 </span>                :            : 
<span class="lineNum">    4176 </span>                :            : /** @brief Creates a smart pointer to a cv::GeneralizedHoughBallard class and initializes it.
<span class="lineNum">    4177 </span>                :            : */
<span class="lineNum">    4178 </span>                :            : CV_EXPORTS Ptr&lt;GeneralizedHoughBallard&gt; createGeneralizedHoughBallard();
<span class="lineNum">    4179 </span>                :            : 
<span class="lineNum">    4180 </span>                :            : /** @brief Creates a smart pointer to a cv::GeneralizedHoughGuil class and initializes it.
<span class="lineNum">    4181 </span>                :            : */
<span class="lineNum">    4182 </span>                :            : CV_EXPORTS Ptr&lt;GeneralizedHoughGuil&gt; createGeneralizedHoughGuil();
<span class="lineNum">    4183 </span>                :            : 
<span class="lineNum">    4184 </span>                :            : //! @} imgproc_shape
<span class="lineNum">    4185 </span>                :            : 
<span class="lineNum">    4186 </span>                :            : //! @addtogroup imgproc_colormap
<span class="lineNum">    4187 </span>                :            : //! @{
<span class="lineNum">    4188 </span>                :            : 
<span class="lineNum">    4189 </span>                :            : //! GNU Octave/MATLAB equivalent colormaps
<span class="lineNum">    4190 </span>                :            : enum ColormapTypes
<span class="lineNum">    4191 </span>                :            : {
<span class="lineNum">    4192 </span>                :            :     COLORMAP_AUTUMN = 0, //!&lt; ![autumn](pics/colormaps/colorscale_autumn.jpg)
<span class="lineNum">    4193 </span>                :            :     COLORMAP_BONE = 1, //!&lt; ![bone](pics/colormaps/colorscale_bone.jpg)
<span class="lineNum">    4194 </span>                :            :     COLORMAP_JET = 2, //!&lt; ![jet](pics/colormaps/colorscale_jet.jpg)
<span class="lineNum">    4195 </span>                :            :     COLORMAP_WINTER = 3, //!&lt; ![winter](pics/colormaps/colorscale_winter.jpg)
<span class="lineNum">    4196 </span>                :            :     COLORMAP_RAINBOW = 4, //!&lt; ![rainbow](pics/colormaps/colorscale_rainbow.jpg)
<span class="lineNum">    4197 </span>                :            :     COLORMAP_OCEAN = 5, //!&lt; ![ocean](pics/colormaps/colorscale_ocean.jpg)
<span class="lineNum">    4198 </span>                :            :     COLORMAP_SUMMER = 6, //!&lt; ![summer](pics/colormaps/colorscale_summer.jpg)
<span class="lineNum">    4199 </span>                :            :     COLORMAP_SPRING = 7, //!&lt; ![spring](pics/colormaps/colorscale_spring.jpg)
<span class="lineNum">    4200 </span>                :            :     COLORMAP_COOL = 8, //!&lt; ![cool](pics/colormaps/colorscale_cool.jpg)
<span class="lineNum">    4201 </span>                :            :     COLORMAP_HSV = 9, //!&lt; ![HSV](pics/colormaps/colorscale_hsv.jpg)
<span class="lineNum">    4202 </span>                :            :     COLORMAP_PINK = 10, //!&lt; ![pink](pics/colormaps/colorscale_pink.jpg)
<span class="lineNum">    4203 </span>                :            :     COLORMAP_HOT = 11, //!&lt; ![hot](pics/colormaps/colorscale_hot.jpg)
<span class="lineNum">    4204 </span>                :            :     COLORMAP_PARULA = 12 //!&lt; ![parula](pics/colormaps/colorscale_parula.jpg)
<span class="lineNum">    4205 </span>                :            : };
<span class="lineNum">    4206 </span>                :            : 
<span class="lineNum">    4207 </span>                :            : /** @example samples/cpp/falsecolor.cpp
<span class="lineNum">    4208 </span>                :            : An example using applyColorMap function
<span class="lineNum">    4209 </span>                :            : */
<span class="lineNum">    4210 </span>                :            : 
<span class="lineNum">    4211 </span>                :            : /** @brief Applies a GNU Octave/MATLAB equivalent colormap on a given image.
<span class="lineNum">    4212 </span>                :            : 
<span class="lineNum">    4213 </span>                :            : @param src The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.
<span class="lineNum">    4214 </span>                :            : @param dst The result is the colormapped source image. Note: Mat::create is called on dst.
<span class="lineNum">    4215 </span>                :            : @param colormap The colormap to apply, see #ColormapTypes
<span class="lineNum">    4216 </span>                :            : */
<span class="lineNum">    4217 </span>                :            : CV_EXPORTS_W void applyColorMap(InputArray src, OutputArray dst, int colormap);
<span class="lineNum">    4218 </span>                :            : 
<span class="lineNum">    4219 </span>                :            : /** @brief Applies a user colormap on a given image.
<span class="lineNum">    4220 </span>                :            : 
<span class="lineNum">    4221 </span>                :            : @param src The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.
<span class="lineNum">    4222 </span>                :            : @param dst The result is the colormapped source image. Note: Mat::create is called on dst.
<span class="lineNum">    4223 </span>                :            : @param userColor The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256
<span class="lineNum">    4224 </span>                :            : */
<span class="lineNum">    4225 </span>                :            : CV_EXPORTS_W void applyColorMap(InputArray src, OutputArray dst, InputArray userColor);
<span class="lineNum">    4226 </span>                :            : 
<span class="lineNum">    4227 </span>                :            : //! @} imgproc_colormap
<span class="lineNum">    4228 </span>                :            : 
<span class="lineNum">    4229 </span>                :            : //! @addtogroup imgproc_draw
<span class="lineNum">    4230 </span>                :            : //! @{
<span class="lineNum">    4231 </span>                :            : 
<span class="lineNum">    4232 </span>                :            : 
<span class="lineNum">    4233 </span>                :            : /** OpenCV color channel order is BGR[A] */
<span class="lineNum">    4234 </span>                :            : #define CV_RGB(r, g, b)  cv::Scalar((b), (g), (r), 0)
<span class="lineNum">    4235 </span>                :            : 
<span class="lineNum">    4236 </span>                :            : /** @brief Draws a line segment connecting two points.
<span class="lineNum">    4237 </span>                :            : 
<span class="lineNum">    4238 </span>                :            : The function line draws the line segment between pt1 and pt2 points in the image. The line is
<span class="lineNum">    4239 </span>                :            : clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected
<span class="lineNum">    4240 </span>                :            : or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased
<span class="lineNum">    4241 </span>                :            : lines are drawn using Gaussian filtering.
<span class="lineNum">    4242 </span>                :            : 
<span class="lineNum">    4243 </span>                :            : @param img Image.
<span class="lineNum">    4244 </span>                :            : @param pt1 First point of the line segment.
<span class="lineNum">    4245 </span>                :            : @param pt2 Second point of the line segment.
<span class="lineNum">    4246 </span>                :            : @param color Line color.
<span class="lineNum">    4247 </span>                :            : @param thickness Line thickness.
<span class="lineNum">    4248 </span>                :            : @param lineType Type of the line. See #LineTypes.
<span class="lineNum">    4249 </span>                :            : @param shift Number of fractional bits in the point coordinates.
<span class="lineNum">    4250 </span>                :            :  */
<span class="lineNum">    4251 </span>                :            : CV_EXPORTS_W void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color,
<span class="lineNum">    4252 </span>                :            :                      int thickness = 1, int lineType = LINE_8, int shift = 0);
<span class="lineNum">    4253 </span>                :            : 
<span class="lineNum">    4254 </span>                :            : /** @brief Draws a arrow segment pointing from the first point to the second one.
<span class="lineNum">    4255 </span>                :            : 
<span class="lineNum">    4256 </span>                :            : The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also #line.
<span class="lineNum">    4257 </span>                :            : 
<span class="lineNum">    4258 </span>                :            : @param img Image.
<span class="lineNum">    4259 </span>                :            : @param pt1 The point the arrow starts from.
<span class="lineNum">    4260 </span>                :            : @param pt2 The point the arrow points to.
<span class="lineNum">    4261 </span>                :            : @param color Line color.
<span class="lineNum">    4262 </span>                :            : @param thickness Line thickness.
<span class="lineNum">    4263 </span>                :            : @param line_type Type of the line. See #LineTypes
<span class="lineNum">    4264 </span>                :            : @param shift Number of fractional bits in the point coordinates.
<span class="lineNum">    4265 </span>                :            : @param tipLength The length of the arrow tip in relation to the arrow length
<span class="lineNum">    4266 </span>                :            :  */
<span class="lineNum">    4267 </span>                :            : CV_EXPORTS_W void arrowedLine(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color,
<span class="lineNum">    4268 </span>                :            :                      int thickness=1, int line_type=8, int shift=0, double tipLength=0.1);
<span class="lineNum">    4269 </span>                :            : 
<span class="lineNum">    4270 </span>                :            : /** @brief Draws a simple, thick, or filled up-right rectangle.
<span class="lineNum">    4271 </span>                :            : 
<span class="lineNum">    4272 </span>                :            : The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners
<span class="lineNum">    4273 </span>                :            : are pt1 and pt2.
<span class="lineNum">    4274 </span>                :            : 
<span class="lineNum">    4275 </span>                :            : @param img Image.
<span class="lineNum">    4276 </span>                :            : @param pt1 Vertex of the rectangle.
<span class="lineNum">    4277 </span>                :            : @param pt2 Vertex of the rectangle opposite to pt1 .
<span class="lineNum">    4278 </span>                :            : @param color Rectangle color or brightness (grayscale image).
<span class="lineNum">    4279 </span>                :            : @param thickness Thickness of lines that make up the rectangle. Negative values, like #FILLED,
<span class="lineNum">    4280 </span>                :            : mean that the function has to draw a filled rectangle.
<span class="lineNum">    4281 </span>                :            : @param lineType Type of the line. See #LineTypes
<span class="lineNum">    4282 </span>                :            : @param shift Number of fractional bits in the point coordinates.
<span class="lineNum">    4283 </span>                :            :  */
<span class="lineNum">    4284 </span>                :            : CV_EXPORTS_W void rectangle(InputOutputArray img, Point pt1, Point pt2,
<span class="lineNum">    4285 </span>                :            :                           const Scalar&amp; color, int thickness = 1,
<span class="lineNum">    4286 </span>                :            :                           int lineType = LINE_8, int shift = 0);
<span class="lineNum">    4287 </span>                :            : 
<span class="lineNum">    4288 </span>                :            : /** @overload
<span class="lineNum">    4289 </span>                :            : 
<span class="lineNum">    4290 </span>                :            : use `rec` parameter as alternative specification of the drawn rectangle: `r.tl() and
<span class="lineNum">    4291 </span>                :            : r.br()-Point(1,1)` are opposite corners
<span class="lineNum">    4292 </span>                :            : */
<span class="lineNum">    4293 </span>                :            : CV_EXPORTS_W void rectangle(InputOutputArray img, Rect rec,
<span class="lineNum">    4294 </span>                :            :                           const Scalar&amp; color, int thickness = 1,
<span class="lineNum">    4295 </span>                :            :                           int lineType = LINE_8, int shift = 0);
<span class="lineNum">    4296 </span>                :            : 
<span class="lineNum">    4297 </span>                :            : /** @example samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_2.cpp
<span class="lineNum">    4298 </span>                :            : An example using drawing functions
<span class="lineNum">    4299 </span>                :            : */
<span class="lineNum">    4300 </span>                :            : 
<span class="lineNum">    4301 </span>                :            : /** @brief Draws a circle.
<span class="lineNum">    4302 </span>                :            : 
<span class="lineNum">    4303 </span>                :            : The function cv::circle draws a simple or filled circle with a given center and radius.
<span class="lineNum">    4304 </span>                :            : @param img Image where the circle is drawn.
<span class="lineNum">    4305 </span>                :            : @param center Center of the circle.
<span class="lineNum">    4306 </span>                :            : @param radius Radius of the circle.
<span class="lineNum">    4307 </span>                :            : @param color Circle color.
<span class="lineNum">    4308 </span>                :            : @param thickness Thickness of the circle outline, if positive. Negative values, like #FILLED,
<span class="lineNum">    4309 </span>                :            : mean that a filled circle is to be drawn.
<span class="lineNum">    4310 </span>                :            : @param lineType Type of the circle boundary. See #LineTypes
<span class="lineNum">    4311 </span>                :            : @param shift Number of fractional bits in the coordinates of the center and in the radius value.
<span class="lineNum">    4312 </span>                :            :  */
<span class="lineNum">    4313 </span>                :            : CV_EXPORTS_W void circle(InputOutputArray img, Point center, int radius,
<span class="lineNum">    4314 </span>                :            :                        const Scalar&amp; color, int thickness = 1,
<span class="lineNum">    4315 </span>                :            :                        int lineType = LINE_8, int shift = 0);
<span class="lineNum">    4316 </span>                :            : 
<span class="lineNum">    4317 </span>                :            : /** @brief Draws a simple or thick elliptic arc or fills an ellipse sector.
<span class="lineNum">    4318 </span>                :            : 
<span class="lineNum">    4319 </span>                :            : The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic
<span class="lineNum">    4320 </span>                :            : arc, or a filled ellipse sector. The drawing code uses general parametric form.
<span class="lineNum">    4321 </span>                :            : A piecewise-linear curve is used to approximate the elliptic arc
<span class="lineNum">    4322 </span>                :            : boundary. If you need more control of the ellipse rendering, you can retrieve the curve using
<span class="lineNum">    4323 </span>                :            : #ellipse2Poly and then render it with #polylines or fill it with #fillPoly. If you use the first
<span class="lineNum">    4324 </span>                :            : variant of the function and want to draw the whole ellipse, not an arc, pass `startAngle=0` and
<span class="lineNum">    4325 </span>                :            : `endAngle=360`. If `startAngle` is greater than `endAngle`, they are swapped. The figure below explains
<span class="lineNum">    4326 </span>                :            : the meaning of the parameters to draw the blue arc.
<span class="lineNum">    4327 </span>                :            : 
<span class="lineNum">    4328 </span>                :            : ![Parameters of Elliptic Arc](pics/ellipse.svg)
<span class="lineNum">    4329 </span>                :            : 
<span class="lineNum">    4330 </span>                :            : @param img Image.
<span class="lineNum">    4331 </span>                :            : @param center Center of the ellipse.
<span class="lineNum">    4332 </span>                :            : @param axes Half of the size of the ellipse main axes.
<span class="lineNum">    4333 </span>                :            : @param angle Ellipse rotation angle in degrees.
<span class="lineNum">    4334 </span>                :            : @param startAngle Starting angle of the elliptic arc in degrees.
<span class="lineNum">    4335 </span>                :            : @param endAngle Ending angle of the elliptic arc in degrees.
<span class="lineNum">    4336 </span>                :            : @param color Ellipse color.
<span class="lineNum">    4337 </span>                :            : @param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
<span class="lineNum">    4338 </span>                :            : a filled ellipse sector is to be drawn.
<span class="lineNum">    4339 </span>                :            : @param lineType Type of the ellipse boundary. See #LineTypes
<span class="lineNum">    4340 </span>                :            : @param shift Number of fractional bits in the coordinates of the center and values of axes.
<span class="lineNum">    4341 </span>                :            :  */
<span class="lineNum">    4342 </span>                :            : CV_EXPORTS_W void ellipse(InputOutputArray img, Point center, Size axes,
<span class="lineNum">    4343 </span>                :            :                         double angle, double startAngle, double endAngle,
<span class="lineNum">    4344 </span>                :            :                         const Scalar&amp; color, int thickness = 1,
<span class="lineNum">    4345 </span>                :            :                         int lineType = LINE_8, int shift = 0);
<span class="lineNum">    4346 </span>                :            : 
<span class="lineNum">    4347 </span>                :            : /** @overload
<span class="lineNum">    4348 </span>                :            : @param img Image.
<span class="lineNum">    4349 </span>                :            : @param box Alternative ellipse representation via RotatedRect. This means that the function draws
<span class="lineNum">    4350 </span>                :            : an ellipse inscribed in the rotated rectangle.
<span class="lineNum">    4351 </span>                :            : @param color Ellipse color.
<span class="lineNum">    4352 </span>                :            : @param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
<span class="lineNum">    4353 </span>                :            : a filled ellipse sector is to be drawn.
<span class="lineNum">    4354 </span>                :            : @param lineType Type of the ellipse boundary. See #LineTypes
<span class="lineNum">    4355 </span>                :            : */
<span class="lineNum">    4356 </span>                :            : CV_EXPORTS_W void ellipse(InputOutputArray img, const RotatedRect&amp; box, const Scalar&amp; color,
<span class="lineNum">    4357 </span>                :            :                         int thickness = 1, int lineType = LINE_8);
<span class="lineNum">    4358 </span>                :            : 
<span class="lineNum">    4359 </span>                :            : /* ----------------------------------------------------------------------------------------- */
<span class="lineNum">    4360 </span>                :            : /* ADDING A SET OF PREDEFINED MARKERS WHICH COULD BE USED TO HIGHLIGHT POSITIONS IN AN IMAGE */
<span class="lineNum">    4361 </span>                :            : /* ----------------------------------------------------------------------------------------- */
<span class="lineNum">    4362 </span>                :            : 
<span class="lineNum">    4363 </span>                :            : /** @brief Draws a marker on a predefined position in an image.
<span class="lineNum">    4364 </span>                :            : 
<span class="lineNum">    4365 </span>                :            : The function cv::drawMarker draws a marker on a given position in the image. For the moment several
<span class="lineNum">    4366 </span>                :            : marker types are supported, see #MarkerTypes for more information.
<span class="lineNum">    4367 </span>                :            : 
<span class="lineNum">    4368 </span>                :            : @param img Image.
<span class="lineNum">    4369 </span>                :            : @param position The point where the crosshair is positioned.
<span class="lineNum">    4370 </span>                :            : @param color Line color.
<span class="lineNum">    4371 </span>                :            : @param markerType The specific type of marker you want to use, see #MarkerTypes
<span class="lineNum">    4372 </span>                :            : @param thickness Line thickness.
<span class="lineNum">    4373 </span>                :            : @param line_type Type of the line, See #LineTypes
<span class="lineNum">    4374 </span>                :            : @param markerSize The length of the marker axis [default = 20 pixels]
<span class="lineNum">    4375 </span>                :            :  */
<span class="lineNum">    4376 </span>                :            : CV_EXPORTS_W void drawMarker(InputOutputArray img, Point position, const Scalar&amp; color,
<span class="lineNum">    4377 </span>                :            :                              int markerType = MARKER_CROSS, int markerSize=20, int thickness=1,
<span class="lineNum">    4378 </span>                :            :                              int line_type=8);
<span class="lineNum">    4379 </span>                :            : 
<span class="lineNum">    4380 </span>                :            : /* ----------------------------------------------------------------------------------------- */
<span class="lineNum">    4381 </span>                :            : /* END OF MARKER SECTION */
<span class="lineNum">    4382 </span>                :            : /* ----------------------------------------------------------------------------------------- */
<span class="lineNum">    4383 </span>                :            : 
<span class="lineNum">    4384 </span>                :            : /** @overload */
<span class="lineNum">    4385 </span>                :            : CV_EXPORTS void fillConvexPoly(InputOutputArray img, const Point* pts, int npts,
<span class="lineNum">    4386 </span>                :            :                                const Scalar&amp; color, int lineType = LINE_8,
<span class="lineNum">    4387 </span>                :            :                                int shift = 0);
<span class="lineNum">    4388 </span>                :            : 
<span class="lineNum">    4389 </span>                :            : /** @brief Fills a convex polygon.
<span class="lineNum">    4390 </span>                :            : 
<span class="lineNum">    4391 </span>                :            : The function cv::fillConvexPoly draws a filled convex polygon. This function is much faster than the
<span class="lineNum">    4392 </span>                :            : function #fillPoly . It can fill not only convex polygons but any monotonic polygon without
<span class="lineNum">    4393 </span>                :            : self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line)
<span class="lineNum">    4394 </span>                :            : twice at the most (though, its top-most and/or the bottom edge could be horizontal).
<span class="lineNum">    4395 </span>                :            : 
<span class="lineNum">    4396 </span>                :            : @param img Image.
<span class="lineNum">    4397 </span>                :            : @param points Polygon vertices.
<span class="lineNum">    4398 </span>                :            : @param color Polygon color.
<span class="lineNum">    4399 </span>                :            : @param lineType Type of the polygon boundaries. See #LineTypes
<span class="lineNum">    4400 </span>                :            : @param shift Number of fractional bits in the vertex coordinates.
<span class="lineNum">    4401 </span>                :            :  */
<span class="lineNum">    4402 </span>                :            : CV_EXPORTS_W void fillConvexPoly(InputOutputArray img, InputArray points,
<span class="lineNum">    4403 </span>                :            :                                  const Scalar&amp; color, int lineType = LINE_8,
<span class="lineNum">    4404 </span>                :            :                                  int shift = 0);
<span class="lineNum">    4405 </span>                :            : 
<span class="lineNum">    4406 </span>                :            : /** @overload */
<span class="lineNum">    4407 </span>                :            : CV_EXPORTS void fillPoly(InputOutputArray img, const Point** pts,
<span class="lineNum">    4408 </span>                :            :                          const int* npts, int ncontours,
<span class="lineNum">    4409 </span>                :            :                          const Scalar&amp; color, int lineType = LINE_8, int shift = 0,
<span class="lineNum">    4410 </span>                :            :                          Point offset = Point() );
<span class="lineNum">    4411 </span>                :            : 
<span class="lineNum">    4412 </span>                :            : /** @example samples/cpp/tutorial_code/ImgProc/basic_drawing/Drawing_1.cpp
<span class="lineNum">    4413 </span>                :            : An example using drawing functions
<span class="lineNum">    4414 </span>                :            : Check @ref tutorial_random_generator_and_text &quot;the corresponding tutorial&quot; for more details
<span class="lineNum">    4415 </span>                :            : */
<span class="lineNum">    4416 </span>                :            : 
<span class="lineNum">    4417 </span>                :            : /** @brief Fills the area bounded by one or more polygons.
<span class="lineNum">    4418 </span>                :            : 
<span class="lineNum">    4419 </span>                :            : The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill
<span class="lineNum">    4420 </span>                :            : complex areas, for example, areas with holes, contours with self-intersections (some of their
<span class="lineNum">    4421 </span>                :            : parts), and so forth.
<span class="lineNum">    4422 </span>                :            : 
<span class="lineNum">    4423 </span>                :            : @param img Image.
<span class="lineNum">    4424 </span>                :            : @param pts Array of polygons where each polygon is represented as an array of points.
<span class="lineNum">    4425 </span>                :            : @param color Polygon color.
<span class="lineNum">    4426 </span>                :            : @param lineType Type of the polygon boundaries. See #LineTypes
<span class="lineNum">    4427 </span>                :            : @param shift Number of fractional bits in the vertex coordinates.
<span class="lineNum">    4428 </span>                :            : @param offset Optional offset of all points of the contours.
<span class="lineNum">    4429 </span>                :            :  */
<span class="lineNum">    4430 </span>                :            : CV_EXPORTS_W void fillPoly(InputOutputArray img, InputArrayOfArrays pts,
<span class="lineNum">    4431 </span>                :            :                            const Scalar&amp; color, int lineType = LINE_8, int shift = 0,
<span class="lineNum">    4432 </span>                :            :                            Point offset = Point() );
<span class="lineNum">    4433 </span>                :            : 
<span class="lineNum">    4434 </span>                :            : /** @overload */
<span class="lineNum">    4435 </span>                :            : CV_EXPORTS void polylines(InputOutputArray img, const Point* const* pts, const int* npts,
<span class="lineNum">    4436 </span>                :            :                           int ncontours, bool isClosed, const Scalar&amp; color,
<span class="lineNum">    4437 </span>                :            :                           int thickness = 1, int lineType = LINE_8, int shift = 0 );
<span class="lineNum">    4438 </span>                :            : 
<span class="lineNum">    4439 </span>                :            : /** @brief Draws several polygonal curves.
<span class="lineNum">    4440 </span>                :            : 
<span class="lineNum">    4441 </span>                :            : @param img Image.
<span class="lineNum">    4442 </span>                :            : @param pts Array of polygonal curves.
<span class="lineNum">    4443 </span>                :            : @param isClosed Flag indicating whether the drawn polylines are closed or not. If they are closed,
<span class="lineNum">    4444 </span>                :            : the function draws a line from the last vertex of each curve to its first vertex.
<span class="lineNum">    4445 </span>                :            : @param color Polyline color.
<span class="lineNum">    4446 </span>                :            : @param thickness Thickness of the polyline edges.
<span class="lineNum">    4447 </span>                :            : @param lineType Type of the line segments. See #LineTypes
<span class="lineNum">    4448 </span>                :            : @param shift Number of fractional bits in the vertex coordinates.
<span class="lineNum">    4449 </span>                :            : 
<span class="lineNum">    4450 </span>                :            : The function cv::polylines draws one or more polygonal curves.
<span class="lineNum">    4451 </span>                :            :  */
<span class="lineNum">    4452 </span>                :            : CV_EXPORTS_W void polylines(InputOutputArray img, InputArrayOfArrays pts,
<span class="lineNum">    4453 </span>                :            :                             bool isClosed, const Scalar&amp; color,
<span class="lineNum">    4454 </span>                :            :                             int thickness = 1, int lineType = LINE_8, int shift = 0 );
<span class="lineNum">    4455 </span>                :            : 
<span class="lineNum">    4456 </span>                :            : /** @example samples/cpp/contours2.cpp
<span class="lineNum">    4457 </span>                :            : An example program illustrates the use of cv::findContours and cv::drawContours
<span class="lineNum">    4458 </span>                :            : \image html WindowsQtContoursOutput.png &quot;Screenshot of the program&quot;
<span class="lineNum">    4459 </span>                :            : */
<span class="lineNum">    4460 </span>                :            : 
<span class="lineNum">    4461 </span>                :            : /** @example samples/cpp/segment_objects.cpp
<span class="lineNum">    4462 </span>                :            : An example using drawContours to clean up a background segmentation result
<span class="lineNum">    4463 </span>                :            : */
<span class="lineNum">    4464 </span>                :            : 
<span class="lineNum">    4465 </span>                :            : /** @brief Draws contours outlines or filled contours.
<span class="lineNum">    4466 </span>                :            : 
<span class="lineNum">    4467 </span>                :            : The function draws contour outlines in the image if \f$\texttt{thickness} \ge 0\f$ or fills the area
<span class="lineNum">    4468 </span>                :            : bounded by the contours if \f$\texttt{thickness}&lt;0\f$ . The example below shows how to retrieve
<span class="lineNum">    4469 </span>                :            : connected components from the binary image and label them: :
<span class="lineNum">    4470 </span>                :            : @include snippets/imgproc_drawContours.cpp
<span class="lineNum">    4471 </span>                :            : 
<span class="lineNum">    4472 </span>                :            : @param image Destination image.
<span class="lineNum">    4473 </span>                :            : @param contours All the input contours. Each contour is stored as a point vector.
<span class="lineNum">    4474 </span>                :            : @param contourIdx Parameter indicating a contour to draw. If it is negative, all the contours are drawn.
<span class="lineNum">    4475 </span>                :            : @param color Color of the contours.
<span class="lineNum">    4476 </span>                :            : @param thickness Thickness of lines the contours are drawn with. If it is negative (for example,
<span class="lineNum">    4477 </span>                :            : thickness=#FILLED ), the contour interiors are drawn.
<span class="lineNum">    4478 </span>                :            : @param lineType Line connectivity. See #LineTypes
<span class="lineNum">    4479 </span>                :            : @param hierarchy Optional information about hierarchy. It is only needed if you want to draw only
<span class="lineNum">    4480 </span>                :            : some of the contours (see maxLevel ).
<span class="lineNum">    4481 </span>                :            : @param maxLevel Maximal level for drawn contours. If it is 0, only the specified contour is drawn.
<span class="lineNum">    4482 </span>                :            : If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function
<span class="lineNum">    4483 </span>                :            : draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This
<span class="lineNum">    4484 </span>                :            : parameter is only taken into account when there is hierarchy available.
<span class="lineNum">    4485 </span>                :            : @param offset Optional contour shift parameter. Shift all the drawn contours by the specified
<span class="lineNum">    4486 </span>                :            : \f$\texttt{offset}=(dx,dy)\f$ .
<span class="lineNum">    4487 </span>                :            : @note When thickness=#FILLED, the function is designed to handle connected components with holes correctly
<span class="lineNum">    4488 </span>                :            : even when no hierarchy date is provided. This is done by analyzing all the outlines together
<span class="lineNum">    4489 </span>                :            : using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved
<span class="lineNum">    4490 </span>                :            : contours. In order to solve this problem, you need to call #drawContours separately for each sub-group
<span class="lineNum">    4491 </span>                :            : of contours, or iterate over the collection using contourIdx parameter.
<span class="lineNum">    4492 </span>                :            :  */
<span class="lineNum">    4493 </span>                :            : CV_EXPORTS_W void drawContours( InputOutputArray image, InputArrayOfArrays contours,
<span class="lineNum">    4494 </span>                :            :                               int contourIdx, const Scalar&amp; color,
<span class="lineNum">    4495 </span>                :            :                               int thickness = 1, int lineType = LINE_8,
<span class="lineNum">    4496 </span>                :            :                               InputArray hierarchy = noArray(),
<span class="lineNum">    4497 </span>                :            :                               int maxLevel = INT_MAX, Point offset = Point() );
<span class="lineNum">    4498 </span>                :            : 
<span class="lineNum">    4499 </span>                :            : /** @brief Clips the line against the image rectangle.
<span class="lineNum">    4500 </span>                :            : 
<span class="lineNum">    4501 </span>                :            : The function cv::clipLine calculates a part of the line segment that is entirely within the specified
<span class="lineNum">    4502 </span>                :            : rectangle. it returns false if the line segment is completely outside the rectangle. Otherwise,
<span class="lineNum">    4503 </span>                :            : it returns true .
<span class="lineNum">    4504 </span>                :            : @param imgSize Image size. The image rectangle is Rect(0, 0, imgSize.width, imgSize.height) .
<span class="lineNum">    4505 </span>                :            : @param pt1 First line point.
<span class="lineNum">    4506 </span>                :            : @param pt2 Second line point.
<span class="lineNum">    4507 </span>                :            :  */
<span class="lineNum">    4508 </span>                :            : CV_EXPORTS bool clipLine(Size imgSize, CV_IN_OUT Point&amp; pt1, CV_IN_OUT Point&amp; pt2);
<span class="lineNum">    4509 </span>                :            : 
<span class="lineNum">    4510 </span>                :            : /** @overload
<span class="lineNum">    4511 </span>                :            : @param imgSize Image size. The image rectangle is Rect(0, 0, imgSize.width, imgSize.height) .
<span class="lineNum">    4512 </span>                :            : @param pt1 First line point.
<span class="lineNum">    4513 </span>                :            : @param pt2 Second line point.
<span class="lineNum">    4514 </span>                :            : */
<span class="lineNum">    4515 </span>                :            : CV_EXPORTS bool clipLine(Size2l imgSize, CV_IN_OUT Point2l&amp; pt1, CV_IN_OUT Point2l&amp; pt2);
<span class="lineNum">    4516 </span>                :            : 
<span class="lineNum">    4517 </span>                :            : /** @overload
<span class="lineNum">    4518 </span>                :            : @param imgRect Image rectangle.
<span class="lineNum">    4519 </span>                :            : @param pt1 First line point.
<span class="lineNum">    4520 </span>                :            : @param pt2 Second line point.
<span class="lineNum">    4521 </span>                :            : */
<span class="lineNum">    4522 </span>                :            : CV_EXPORTS_W bool clipLine(Rect imgRect, CV_OUT CV_IN_OUT Point&amp; pt1, CV_OUT CV_IN_OUT Point&amp; pt2);
<span class="lineNum">    4523 </span>                :            : 
<span class="lineNum">    4524 </span>                :            : /** @brief Approximates an elliptic arc with a polyline.
<span class="lineNum">    4525 </span>                :            : 
<span class="lineNum">    4526 </span>                :            : The function ellipse2Poly computes the vertices of a polyline that approximates the specified
<span class="lineNum">    4527 </span>                :            : elliptic arc. It is used by #ellipse. If `arcStart` is greater than `arcEnd`, they are swapped.
<span class="lineNum">    4528 </span>                :            : 
<span class="lineNum">    4529 </span>                :            : @param center Center of the arc.
<span class="lineNum">    4530 </span>                :            : @param axes Half of the size of the ellipse main axes. See #ellipse for details.
<span class="lineNum">    4531 </span>                :            : @param angle Rotation angle of the ellipse in degrees. See #ellipse for details.
<span class="lineNum">    4532 </span>                :            : @param arcStart Starting angle of the elliptic arc in degrees.
<span class="lineNum">    4533 </span>                :            : @param arcEnd Ending angle of the elliptic arc in degrees.
<span class="lineNum">    4534 </span>                :            : @param delta Angle between the subsequent polyline vertices. It defines the approximation
<span class="lineNum">    4535 </span>                :            : accuracy.
<span class="lineNum">    4536 </span>                :            : @param pts Output vector of polyline vertices.
<span class="lineNum">    4537 </span>                :            :  */
<span class="lineNum">    4538 </span>                :            : CV_EXPORTS_W void ellipse2Poly( Point center, Size axes, int angle,
<span class="lineNum">    4539 </span>                :            :                                 int arcStart, int arcEnd, int delta,
<span class="lineNum">    4540 </span>                :            :                                 CV_OUT std::vector&lt;Point&gt;&amp; pts );
<span class="lineNum">    4541 </span>                :            : 
<span class="lineNum">    4542 </span>                :            : /** @overload
<span class="lineNum">    4543 </span>                :            : @param center Center of the arc.
<span class="lineNum">    4544 </span>                :            : @param axes Half of the size of the ellipse main axes. See #ellipse for details.
<span class="lineNum">    4545 </span>                :            : @param angle Rotation angle of the ellipse in degrees. See #ellipse for details.
<span class="lineNum">    4546 </span>                :            : @param arcStart Starting angle of the elliptic arc in degrees.
<span class="lineNum">    4547 </span>                :            : @param arcEnd Ending angle of the elliptic arc in degrees.
<span class="lineNum">    4548 </span>                :            : @param delta Angle between the subsequent polyline vertices. It defines the approximation accuracy.
<span class="lineNum">    4549 </span>                :            : @param pts Output vector of polyline vertices.
<span class="lineNum">    4550 </span>                :            : */
<span class="lineNum">    4551 </span>                :            : CV_EXPORTS void ellipse2Poly(Point2d center, Size2d axes, int angle,
<span class="lineNum">    4552 </span>                :            :                              int arcStart, int arcEnd, int delta,
<span class="lineNum">    4553 </span>                :            :                              CV_OUT std::vector&lt;Point2d&gt;&amp; pts);
<span class="lineNum">    4554 </span>                :            : 
<span class="lineNum">    4555 </span>                :            : /** @brief Draws a text string.
<span class="lineNum">    4556 </span>                :            : 
<span class="lineNum">    4557 </span>                :            : The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered
<span class="lineNum">    4558 </span>                :            : using the specified font are replaced by question marks. See #getTextSize for a text rendering code
<span class="lineNum">    4559 </span>                :            : example.
<span class="lineNum">    4560 </span>                :            : 
<span class="lineNum">    4561 </span>                :            : @param img Image.
<span class="lineNum">    4562 </span>                :            : @param text Text string to be drawn.
<span class="lineNum">    4563 </span>                :            : @param org Bottom-left corner of the text string in the image.
<span class="lineNum">    4564 </span>                :            : @param fontFace Font type, see #HersheyFonts.
<span class="lineNum">    4565 </span>                :            : @param fontScale Font scale factor that is multiplied by the font-specific base size.
<span class="lineNum">    4566 </span>                :            : @param color Text color.
<span class="lineNum">    4567 </span>                :            : @param thickness Thickness of the lines used to draw a text.
<span class="lineNum">    4568 </span>                :            : @param lineType Line type. See #LineTypes
<span class="lineNum">    4569 </span>                :            : @param bottomLeftOrigin When true, the image data origin is at the bottom-left corner. Otherwise,
<span class="lineNum">    4570 </span>                :            : it is at the top-left corner.
<span class="lineNum">    4571 </span>                :            :  */
<span class="lineNum">    4572 </span>                :            : CV_EXPORTS_W void putText( InputOutputArray img, const String&amp; text, Point org,
<span class="lineNum">    4573 </span>                :            :                          int fontFace, double fontScale, Scalar color,
<span class="lineNum">    4574 </span>                :            :                          int thickness = 1, int lineType = LINE_8,
<span class="lineNum">    4575 </span>                :            :                          bool bottomLeftOrigin = false );
<span class="lineNum">    4576 </span>                :            : 
<span class="lineNum">    4577 </span>                :            : /** @brief Calculates the width and height of a text string.
<span class="lineNum">    4578 </span>                :            : 
<span class="lineNum">    4579 </span>                :            : The function cv::getTextSize calculates and returns the size of a box that contains the specified text.
<span class="lineNum">    4580 </span>                :            : That is, the following code renders some text, the tight box surrounding it, and the baseline: :
<span class="lineNum">    4581 </span>                :            : @code
<span class="lineNum">    4582 </span>                :            :     String text = &quot;Funny text inside the box&quot;;
<span class="lineNum">    4583 </span>                :            :     int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;
<span class="lineNum">    4584 </span>                :            :     double fontScale = 2;
<span class="lineNum">    4585 </span>                :            :     int thickness = 3;
<span class="lineNum">    4586 </span>                :            : 
<span class="lineNum">    4587 </span>                :            :     Mat img(600, 800, CV_8UC3, Scalar::all(0));
<span class="lineNum">    4588 </span>                :            : 
<span class="lineNum">    4589 </span>                :            :     int baseline=0;
<span class="lineNum">    4590 </span>                :            :     Size textSize = getTextSize(text, fontFace,
<span class="lineNum">    4591 </span>                :            :                                 fontScale, thickness, &amp;baseline);
<span class="lineNum">    4592 </span>                :            :     baseline += thickness;
<span class="lineNum">    4593 </span>                :            : 
<span class="lineNum">    4594 </span>                :            :     // center the text
<span class="lineNum">    4595 </span>                :            :     Point textOrg((img.cols - textSize.width)/2,
<span class="lineNum">    4596 </span>                :            :                   (img.rows + textSize.height)/2);
<span class="lineNum">    4597 </span>                :            : 
<span class="lineNum">    4598 </span>                :            :     // draw the box
<span class="lineNum">    4599 </span>                :            :     rectangle(img, textOrg + Point(0, baseline),
<span class="lineNum">    4600 </span>                :            :               textOrg + Point(textSize.width, -textSize.height),
<span class="lineNum">    4601 </span>                :            :               Scalar(0,0,255));
<span class="lineNum">    4602 </span>                :            :     // ... and the baseline first
<span class="lineNum">    4603 </span>                :            :     line(img, textOrg + Point(0, thickness),
<span class="lineNum">    4604 </span>                :            :          textOrg + Point(textSize.width, thickness),
<span class="lineNum">    4605 </span>                :            :          Scalar(0, 0, 255));
<span class="lineNum">    4606 </span>                :            : 
<span class="lineNum">    4607 </span>                :            :     // then put the text itself
<span class="lineNum">    4608 </span>                :            :     putText(img, text, textOrg, fontFace, fontScale,
<span class="lineNum">    4609 </span>                :            :             Scalar::all(255), thickness, 8);
<span class="lineNum">    4610 </span>                :            : @endcode
<span class="lineNum">    4611 </span>                :            : 
<span class="lineNum">    4612 </span>                :            : @param text Input text string.
<span class="lineNum">    4613 </span>                :            : @param fontFace Font to use, see #HersheyFonts.
<span class="lineNum">    4614 </span>                :            : @param fontScale Font scale factor that is multiplied by the font-specific base size.
<span class="lineNum">    4615 </span>                :            : @param thickness Thickness of lines used to render the text. See #putText for details.
<span class="lineNum">    4616 </span>                :            : @param[out] baseLine y-coordinate of the baseline relative to the bottom-most text
<span class="lineNum">    4617 </span>                :            : point.
<span class="lineNum">    4618 </span>                :            : @return The size of a box that contains the specified text.
<span class="lineNum">    4619 </span>                :            : 
<span class="lineNum">    4620 </span>                :            : @see putText
<span class="lineNum">    4621 </span>                :            :  */
<span class="lineNum">    4622 </span>                :            : CV_EXPORTS_W Size getTextSize(const String&amp; text, int fontFace,
<span class="lineNum">    4623 </span>                :            :                             double fontScale, int thickness,
<span class="lineNum">    4624 </span>                :            :                             CV_OUT int* baseLine);
<span class="lineNum">    4625 </span>                :            : 
<span class="lineNum">    4626 </span>                :            : 
<span class="lineNum">    4627 </span>                :            : /** @brief Calculates the font-specific size to use to achieve a given height in pixels.
<span class="lineNum">    4628 </span>                :            : 
<span class="lineNum">    4629 </span>                :            : @param fontFace Font to use, see cv::HersheyFonts.
<span class="lineNum">    4630 </span>                :            : @param pixelHeight Pixel height to compute the fontScale for
<span class="lineNum">    4631 </span>                :            : @param thickness Thickness of lines used to render the text.See putText for details.
<span class="lineNum">    4632 </span>                :            : @return The fontSize to use for cv::putText
<span class="lineNum">    4633 </span>                :            : 
<span class="lineNum">    4634 </span>                :            : @see cv::putText
<span class="lineNum">    4635 </span>                :            : */
<span class="lineNum">    4636 </span>                :            : CV_EXPORTS_W double getFontScaleFromHeight(const int fontFace,
<span class="lineNum">    4637 </span>                :            :                                            const int pixelHeight,
<span class="lineNum">    4638 </span>                :            :                                            const int thickness = 1);
<span class="lineNum">    4639 </span>                :            : 
<span class="lineNum">    4640 </span>                :            : /** @brief Line iterator
<span class="lineNum">    4641 </span>                :            : 
<span class="lineNum">    4642 </span>                :            : The class is used to iterate over all the pixels on the raster line
<span class="lineNum">    4643 </span>                :            : segment connecting two specified points.
<span class="lineNum">    4644 </span>                :            : 
<span class="lineNum">    4645 </span>                :            : The class LineIterator is used to get each pixel of a raster line. It
<span class="lineNum">    4646 </span>                :            : can be treated as versatile implementation of the Bresenham algorithm
<span class="lineNum">    4647 </span>                :            : where you can stop at each pixel and do some extra processing, for
<span class="lineNum">    4648 </span>                :            : example, grab pixel values along the line or draw a line with an effect
<span class="lineNum">    4649 </span>                :            : (for example, with XOR operation).
<span class="lineNum">    4650 </span>                :            : 
<span class="lineNum">    4651 </span>                :            : The number of pixels along the line is stored in LineIterator::count.
<span class="lineNum">    4652 </span>                :            : The method LineIterator::pos returns the current position in the image:
<span class="lineNum">    4653 </span>                :            : 
<span class="lineNum">    4654 </span>                :            : @code{.cpp}
<span class="lineNum">    4655 </span>                :            : // grabs pixels along the line (pt1, pt2)
<span class="lineNum">    4656 </span>                :            : // from 8-bit 3-channel image to the buffer
<span class="lineNum">    4657 </span>                :            : LineIterator it(img, pt1, pt2, 8);
<span class="lineNum">    4658 </span>                :            : LineIterator it2 = it;
<span class="lineNum">    4659 </span>                :            : vector&lt;Vec3b&gt; buf(it.count);
<span class="lineNum">    4660 </span>                :            : 
<span class="lineNum">    4661 </span>                :            : for(int i = 0; i &lt; it.count; i++, ++it)
<span class="lineNum">    4662 </span>                :            :     buf[i] = *(const Vec3b*)*it;
<span class="lineNum">    4663 </span>                :            : 
<span class="lineNum">    4664 </span>                :            : // alternative way of iterating through the line
<span class="lineNum">    4665 </span>                :            : for(int i = 0; i &lt; it2.count; i++, ++it2)
<span class="lineNum">    4666 </span>                :            : {
<span class="lineNum">    4667 </span>                :            :     Vec3b val = img.at&lt;Vec3b&gt;(it2.pos());
<span class="lineNum">    4668 </span>                :            :     CV_Assert(buf[i] == val);
<span class="lineNum">    4669 </span>                :            : }
<span class="lineNum">    4670 </span>                :            : @endcode
<span class="lineNum">    4671 </span>                :            : */
<span class="lineNum">    4672 </span>                :            : class CV_EXPORTS LineIterator
<span class="lineNum">    4673 </span>                :            : {
<span class="lineNum">    4674 </span>                :            : public:
<span class="lineNum">    4675 </span>                :            :     /** @brief initializes the iterator
<span class="lineNum">    4676 </span>                :            : 
<span class="lineNum">    4677 </span>                :            :     creates iterators for the line connecting pt1 and pt2
<span class="lineNum">    4678 </span>                :            :     the line will be clipped on the image boundaries
<span class="lineNum">    4679 </span>                :            :     the line is 8-connected or 4-connected
<span class="lineNum">    4680 </span>                :            :     If leftToRight=true, then the iteration is always done
<span class="lineNum">    4681 </span>                :            :     from the left-most point to the right most,
<span class="lineNum">    4682 </span>                :            :     not to depend on the ordering of pt1 and pt2 parameters
<span class="lineNum">    4683 </span>                :            :     */
<span class="lineNum">    4684 </span>                :            :     LineIterator( const Mat&amp; img, Point pt1, Point pt2,
<span class="lineNum">    4685 </span>                :            :                   int connectivity = 8, bool leftToRight = false );
<span class="lineNum">    4686 </span>                :            :     /** @brief returns pointer to the current pixel
<span class="lineNum">    4687 </span>                :            :     */
<span class="lineNum">    4688 </span>                :            :     uchar* operator *();
<span class="lineNum">    4689 </span>                :            :     /** @brief prefix increment operator (++it). shifts iterator to the next pixel
<span class="lineNum">    4690 </span>                :            :     */
<span class="lineNum">    4691 </span>                :            :     LineIterator&amp; operator ++();
<span class="lineNum">    4692 </span>                :            :     /** @brief postfix increment operator (it++). shifts iterator to the next pixel
<span class="lineNum">    4693 </span>                :            :     */
<span class="lineNum">    4694 </span>                :            :     LineIterator operator ++(int);
<span class="lineNum">    4695 </span>                :            :     /** @brief returns coordinates of the current pixel
<span class="lineNum">    4696 </span>                :            :     */
<span class="lineNum">    4697 </span>                :            :     Point pos() const;
<span class="lineNum">    4698 </span>                :            : 
<span class="lineNum">    4699 </span>                :            :     uchar* ptr;
<span class="lineNum">    4700 </span>                :            :     const uchar* ptr0;
<span class="lineNum">    4701 </span>                :            :     int step, elemSize;
<span class="lineNum">    4702 </span>                :            :     int err, count;
<span class="lineNum">    4703 </span>                :            :     int minusDelta, plusDelta;
<span class="lineNum">    4704 </span>                :            :     int minusStep, plusStep;
<span class="lineNum">    4705 </span>                :            : };
<span class="lineNum">    4706 </span>                :            : 
<span class="lineNum">    4707 </span>                :            : //! @cond IGNORED
<span class="lineNum">    4708 </span>                :            : 
<span class="lineNum">    4709 </span>                :            : // === LineIterator implementation ===
<span class="lineNum">    4710 </span>                :            : 
<span class="lineNum">    4711 </span>                :            : inline
<span class="lineNum">    4712 </span>                :            : uchar* LineIterator::operator *()
<span class="lineNum">    4713 </span>                :            : {
<span class="lineNum">    4714 </span>                :            :     return ptr;
<span class="lineNum">    4715 </span>                :            : }
<span class="lineNum">    4716 </span>                :            : 
<span class="lineNum">    4717 </span>                :            : inline
<span class="lineNum">    4718 </span>                :            : LineIterator&amp; LineIterator::operator ++()
<span class="lineNum">    4719 </span>                :            : {
<span class="lineNum">    4720 </span>                :            :     int mask = err &lt; 0 ? -1 : 0;
<span class="lineNum">    4721 </span>                :            :     err += minusDelta + (plusDelta &amp; mask);
<span class="lineNum">    4722 </span>                :            :     ptr += minusStep + (plusStep &amp; mask);
<span class="lineNum">    4723 </span>                :            :     return *this;
<span class="lineNum">    4724 </span>                :            : }
<span class="lineNum">    4725 </span>                :            : 
<span class="lineNum">    4726 </span>                :            : inline
<span class="lineNum">    4727 </span>                :            : LineIterator LineIterator::operator ++(int)
<span class="lineNum">    4728 </span>                :            : {
<span class="lineNum">    4729 </span>                :            :     LineIterator it = *this;
<span class="lineNum">    4730 </span>                :            :     ++(*this);
<span class="lineNum">    4731 </span>                :            :     return it;
<span class="lineNum">    4732 </span>                :            : }
<span class="lineNum">    4733 </span>                :            : 
<span class="lineNum">    4734 </span>                :            : inline
<span class="lineNum">    4735 </span>                :            : Point LineIterator::pos() const
<span class="lineNum">    4736 </span>                :            : {
<span class="lineNum">    4737 </span>                :            :     Point p;
<span class="lineNum">    4738 </span>                :            :     p.y = (int)((ptr - ptr0)/step);
<span class="lineNum">    4739 </span>                :            :     p.x = (int)(((ptr - ptr0) - p.y*step)/elemSize);
<span class="lineNum">    4740 </span>                :            :     return p;
<span class="lineNum">    4741 </span>                :            : }
<span class="lineNum">    4742 </span>                :            : 
<span class="lineNum">    4743 </span>                :            : //! @endcond
<span class="lineNum">    4744 </span>                :            : 
<span class="lineNum">    4745 </span>                :            : //! @} imgproc_draw
<span class="lineNum">    4746 </span>                :            : 
<span class="lineNum">    4747 </span>                :            : //! @} imgproc
<span class="lineNum">    4748 </span>                :            : 
<span class="lineNum">    4749 </span>                :            : } // cv
<span class="lineNum">    4750 </span>                :            : 
<span class="lineNum">    4751 </span>                :            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
